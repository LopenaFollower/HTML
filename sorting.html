<!DOCTYPE html>
<html>
	<head>
		<title></title>
		<meta name="viewport"content="width=device-width,initial-scale=1">
		<style>
			body{
				overflow:scroll;
				padding:0;
				margin:0 auto;
				zoom:.6;
			}
			.container{display:flex}
			#cvs{
				background:#000;
				aspect-ratio:auto;
			}
			.lfa{text-align:right}
			td,#names{
				font-family:monospace;
				color:#fff;
			}
			fieldset{width:fit-content}
		</style>
	</head>
	<body bgcolor=#222>
		<br>
		<span id=names></span>
		<div class=container>
			<fieldset>
				<table>
					<tr>
						<td colspan=2 style='text-align:center'>Options</td>
					</tr>
					<tr>
						<td id=m0>bar</td>
						<td><input type=checkbox oninput='m0.innerText=dtype.checked?"bar":"pixel"'id=dtype checked/></td>
					</tr>
					<tr>
						<td>loop</td>
						<td><input type=checkbox id=loopsort /></td>
					</tr>
					<tr>
						<td>pause</td>
						<td><input type=checkbox id=pause /></td>
					</tr>
					<tr>
						<td>zoom (25-200)</td>
						<td>
							<input style='width:40px'value=60 type=number oninput='if(this["value"]>=25&&this["value"]<=200)document.body.style.zoom=this["value"]/100'/>
						</td>
					</tr>
					<tr>
						<td>skip</td>
						<td>
							<button style='width:40px'onclick='canskip&&arr.sort((a,b)=>a-b)&&(didskip=true)'>btn</button>
						</td>
					</tr>
				</table>
			</fieldset>
			<fieldset>
				<table>
					<tr>
						<td colspan=2 style='text-align:center'>Info</td>
					</tr>
					<tr>
						<td>Elements</td>
						<td class=lfa id=elementcount></td>
					</tr>
					<tr>
						<td>FPS</td>
						<td class=lfa id=fpsdisplay>60</td>
					</tr>
					<tr>
						<td>Swaps</td>
						<td class=lfa id=swapdisplay>0</td>
					</tr>
					<tr>
						<td>Writes</td>
						<td class=lfa id=writedisplay>0</td>
					</tr>
					<tr>
						<td>Input</td>
						<td id=inputdisplay></td>
					</tr>
				</table>
			</fieldset>
			<fieldset>
				<table>
					<tr>
						<td colspan=2 style='text-align:center'>Debug</td>
					</tr>
					<tr>
						<td>Frame</td>
						<td class=lfa id=framecount></td>
					</tr>
					<tr>
						<td>Rate</td>
						<td class=lfa id=framerate></td>
					</tr>
					<tr>
						<td>Sorted</td>
						<td class=lfa id=finalresult></td>
					</tr>
					<tr>
						<td>Duration</td>
						<td class=lfa id=duration></td>
					</tr>
					<tr>
						<td>Estim Finish</td>
						<td class=lfa id=estimated></td>
					</tr>
				</table>
			</fieldset>
		</div>
		<canvas id=cvs></canvas>
		<br>
		<script>
window.onresize=resize;
window.onblur=function(){pause.checked=true}
window.onfocus=function(){pause.checked=false}
const ctx=cvs.getContext("2d"),count=512,len=count,{random,ceil,floor,round,sqrt,cbrt,log,abs,pow}=Math,math=Math;
let swaps=0,writes=0,bw=(maxVal(window.innerWidth,window.innerHeight)/minVal(window.innerWidth,window.innerHeight)).toFixed(2),arr,canskip=1,didskip=0;
const logs=[],sn={};
let curDur=Date.now(),dcd=false;
function resize(){
	bw=(maxVal(window.innerWidth,window.innerHeight)/minVal(window.innerWidth,window.innerHeight)).toFixed(2);let horizontal=maxVal(window.innerWidth,window.innerHeight),vertical=minVal(window.innerWidth,window.innerHeight);Array.from(document.getElementsByTagName("td")).map(e=>e.style.fontSize=horizontal/50+"px");names.style.fontSize=horizontal/50+"px";cvs.width=count*bw;cvs.height=count;cvs.style.width=horizontal*.75+"px";cvs.style.height=vertical*.75+"px";elementcount.innerText=count;
}
resize()
const fps=(()=>{
	let elapsed=Date.now(),el2=Date.now(),frame=0,fps=60;
	let update=()=>{
		let rate=1;
		if(Date.now()-elapsed<=1e3/rate){
			frame+=rate
		}else{
			elapsed=Date.now()
			fps=frame
			fpsdisplay.innerText=frame
			frame=0
		}
		if(Date.now()-el2>=1e3/16){
			el2=Date.now()
			swapdisplay.innerText=swaps.toLocaleString()
			writedisplay.innerText=writes.toLocaleString()
			dcd&&(duration.innerText=((Date.now()-curDur)/1000).toFixed(1)+"s");
		}
		requestAnimationFrame(update)
	}
	requestAnimationFrame(update)
	return{g:()=>fps}
})();
const isSorted=a=>a.every((e,i)=>!i||a[i-1]<=e);
function display(a){
	ctx.clearRect(0,0,cvs.width,cvs.height)
	ctx.fillStyle="#fff";
	for(let i=0;i<len;i++)ctx.fillRect(i*bw,count-a[i],bw,dtype.checked?a[i]:bw)
}
function mark(i,after){
	if(fps.g()>=30){
		ctx.fillStyle="#f00";
		ctx.fillRect(i*bw,count-arr[i],bw,dtype.checked?arr[i]:bw)
	}
	if(after)ctx.fillStyle=after;
}
function rdisp(args){
	if(args.length==3){
		var[interval,m,onfinish]=args
		var refresh=24
	}else if(args.length==4){
		var[interval,m,refresh,onfinish]=args
	}else return;
	let elapsed=Date.now();
	let sm=m;
	let clen=logs.length
	const orlen=clen
	let tr=maxVal(len*.001,clen*.0005)|0
	if(interval<0){
		tr=len*abs(interval)|0
		interval=10
	}
	let tmp=[...arr];
	logs.forEach(e=>{
		let el=e.split(",").map(e=>parseInt(e))
		if(el.length==2)swap(tmp,...el)
		else tmp[el[0]]=el[1];
	})
	finalresult.innerText=isSorted(tmp);
	finalresult.style.color=isSorted(tmp)?"#fff":"#f00";
	tmp.splice(0,Infinity)
	swaps=0;writes=0;
	let frames=0;
	dcd=true
	curDur=Date.now();
	let updts=0,avrge=0,ticks=0;
	let n=setInterval(()=>{
		if(pause.checked)return;
		if(Date.now()-elapsed>1e3/refresh){
			elapsed=Date.now()
			display(arr)
			perms=0
			framecount.innerText=(orlen-clen).toLocaleString()+" / "+orlen.toLocaleString();
			framerate.innerText=frames+"/s"
			if(ticks++%5==0)
				estimated.innerText=(avrge/updts-3.5).toFixed(1)+"s";
		}
		for(let rate=0;rate<=tr;rate++){
			if(frames>=5e3)return;
			frames++
			setTimeout(()=>frames--,1e3)
			updts++
			avrge+=orlen/(frames)
			if(clen&&!didskip){
				let c=logs.shift().split(",")
				clen--
				if(c.length==2)
					swap(arr,...c,sm)
				else{
					arr[c[0]]=c[1]
					mark(c[2])
					writes++
				}
			}else{
				clearLogs()
				arr.sort((a,b)=>a-b);
				clearInterval(n)
				onfinish()
				dcd=false
				setTimeout(()=>{
					finalresult.innerText="...";
					framecount.innerText="...";
					framerate.innerText="...";
				},5)
				break;
			}
		}
	},interval)
}
function create(c){
	return Array(c).fill().map((e,i)=>++i)
}
/* Sauces: 
* https://github.com/Gaming32/ArrayV/blob/main/src/main/java/io/github/arrayv/sorts/
* https://github.com/Gaming32/ArrayV-Extra-Sorts/blob/main/src/main/java/io/github/arrayv/sorts/
* https://github.com/PCBoyGames/ArrayV-v4.0/tree/ad703423641022a396437e2025405916f2435b13/src/sorts
*/
function getDigit(a,p,r){
	return(a/pow(r,p))%r|0;
}
function minVal(...a){
	return math.min(...a)
}
function maxVal(...a){
	return math.max(...a)
}
function maxLog(a,l,b){
	let m=i=0;
	for(;i<l;i++){
		let v=a[i];
		if(v>m)m=v;
	}
	return log(m)/log(b)|0;
}
function reversal(a,s,l){
	if(l-s<0)return;
	for(let i=s;i<s+((l-s+1)/2);i++)
		rswap(a,i,s+l-i);
}
function compareValues(a,b){
	a|=0;b|=0
	return a==b?0:a>b?1:-1
}
function compareIndices(a,b,c){
	b|=0;c|=0
	return a[b]==a[c]?0:a[b]>a[c]?1:-1
}
function swap(a,f,t,m=0){
	f|=0;t|=0;
	if(m){
		mark(f);
		mark(t);
	}
	let o=a[f];
	a[f]=a[t];
	a[t]=o;
	swaps++
	writes+=2
}
function multiSwap(a,p,t,r){
	if(t-p>0)for(let i=p;i<t;i++)
		if(r)rswap(a,i,i+1);
		else swap(a,i,i+1);
	else for(let i=p;i>t;i--)
		if(r)rswap(a,i,i-1);
		else swap(a,i,i-1);
}
function write(a,t,v){
	a[t]=v|0;
	writes++
}
function clearLogs(){
	logs.splice(0,Infinity)
}
function rswap(arr,f,t){
	logs[logs.length]=f+","+t
	swap(arr,f,t)
	swaps--
	writes-=2
}
function rset(arr,i,val){
	logs[logs.length]=[i,val,i].join(",")
	arr[i]=val
}
function arraycopy(s,sp,d,dp,l,r){
	let b=s!=d||dp<sp;
	let st=b?0:l-1,
		e=b?l:-1,
		dr=b?1:-1;
	for(let i=st;i!=e;i+=dr)
		if(r)rset(d,dp+i,s[sp+i]);
		else write(d,dp+i,s[sp+i]);
}
function insertTo(a,p,t){
	let tp=a[p];
	if(t-p>0)
		for(let i=p;i<t;i++)rset(a,i,a[i+1]);
	else if(t-p<0)
		for(let i=p;i>t;i--)rset(a,i,a[i-1]);
	if(p!=t)rset(a,t,tp);
}
function getMax(a,l){
	let m=0;
	for(let i=0;i<l;i++)
		if(a[i]>m)m=a[i];
	return m;
}
function getMaxIndex(a,l){
	let i=0;
	for(let n=0;n<l;++n)
		if(a[n]>a[i])i=n;
	return i;
}
function getMin(a,l){
	let m=Infinity;
	for(let i=0;i<l;i++)
		if(a[i]<m)m=a[i];
	return m;
}
const circleDepth=parseFloat("1e-"+(len*.9|0).toString().length)
/*templates*/
function rcsr(a,l,h,s){
	if(l==h)return s;
	let hi=h,lo=l,m=(h-l)/2|0;
	while(l<h)
		if(h<len&&compareIndices(a,l++,h--)>0)
			rswap(a,l-1,h+1,s++);
	s=rcsr(a,lo,lo+m,s);
	if(lo+m+1<len)s=rcsr(a,lo+m+1,hi,s);
	return s;
}
function insertSort(a,s,e){
	for(let i=s;i<e;i++){
		let p=i-1,c=a[i];
		while(p>=s&&compareValues(a[p],c)>0)
			rset(a,p+1,a[p--]);
		rset(a,p+1,c);
	}
}
function siftDown(a,r,d,s,m){
	let cv=m?-1:1;
	while(r<=d/2){
		let l=2*r;
		if(l<d&&compareIndices(a,s+l-1,s+l)==cv)l++;
		if(compareIndices(a,s+r-1,s+l-1)==cv){
			rswap(a,s+r-1,s+l-1);
			r=l;
		}else break;
	}
}
function heapify(ar,lw,h,m){
	let le=h-lw;
	for(let i=le/2;i>=1;i--)
		siftDown(ar,i,le,lw,m)
}
function iclsr(a,l,e){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)
		for(let s=0;s+g<e;s+=2*g)
			for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)
				if(h<e&&compareIndices(a,lw,h)>0)
					reversal(a,lw,h,sc++);
	return sc;
}
function rclsr(a,lo,hi,sc,e){
	if(lo==hi)return sc;
	let h=hi;
	let l=lo;
	let m=(hi-lo)/2|0;
	for(;lo<hi;lo++,hi--)
		if(hi<e&&compareIndices(a,lo,hi)>0)
			reversal(a,lo,hi,sc++);
	sc=rclsr(a,l,l+m,sc,e);
	if(l+m+1<e)
		sc=rclsr(a,l+m+1,h,sc,e);
	return sc;
}
/*end*/
function iterativeBitonicSort(){
	let array=[...arr];
	let i,j,k;
	for(k=2;k<len*2;k=2*k){
		let m=(((len+(k-1))/k)%2)!=0;
		for(j=k>>1;j>0;j=j>>1){
			for(i=0;i<len;i++){
				let ij=i^j;
				if(ij>i&&ij<len){
					if((((i&k)==0)==m)&&compareIndices(array,i,ij)>0)rswap(array,i,ij);
					if((((i&k)!=0)==m)&&compareIndices(array,i,ij)<0)rswap(array,i,ij);
				}
			}
		}
	}
	return[5,1];
}
function batcherBitonicSort(){
	let array=[...arr];
	const bm=(a,l,n,dir)=>{
		if(n<=1)return;
		let m=1
		while(m<<1<n)m<<=1;
		for(let i=l;i<l+n-m;i++)
			if(dir==(compareIndices(array,i,i+m)==1))
				rswap(a,i,i+m);
		bm(a,l,m,dir);
		bm(a,l+m,n-m,dir);
	}
	const bs=(a,l,n,dir)=>{
		if(n<=1)return;
		let m=n/2;
		bs(a,l,m,!dir);
		bs(a,l+m,n-m,dir);
		bm(a,l,n,dir);
	}
	bs(array,0,len,1)
	return[5,1];
}
function iterativeBoseNelsonSort(){
	let array=[...arr];
	let clen=1<<ceil(log(len)/log(2));
	for(let a=2;a<=clen;a*=2){
		for(let b=0;b<a/2;b++){
			for(let c=0;c+b<len;c+=a){
				let g=c
				let half=(c+a-g)/2,m=g+half;
				g+=b;
				for(let d=0;d<half-b;d++){
					if((d&~b)==d){
						let e=g+d,f=m+d
						if(f<len&&compareIndices(array,e,f)==1)
							rswap(array,e,f);
					}
				}
			}
		}
	}
	return[5,1]
}
function recursiveBoseNelsonSort(){
	let array=[...arr];
	const cs=(a,s,e)=>{
		if(compareIndices(a,s,e)==1)
			rswap(a,s,e);
	}
	const bn=(a,s,l)=>{
		if(l<=1)return;
		let m=l/2|0;
		bn(a,s,m);
		bn(a,s+m,l-m);
		bnm(a,s,m,s+m,l-m);
	}
	
	const bnm=(a,s1,l1,s2,l2)=>{
		if(l1==1&&l2==1){
			cs(a,s1,s2);
		}else if(l1==1&&l2==2){
			cs(a,s1,s2+1);
			cs(a,s1,s2);
		}else if(l1==2&&l2==1){
			cs(a,s1,s2);
			cs(a,s1+1,s2);
		}else{
			let m1=l1/2|0;
			let m2=(l1%2==1?l2/2:(l2+1)/2)|0;
			bnm(a,s1,m1,s2,m2);
			bnm(a,s1+m1,l1-m1,s2+m2,l2-m2);
			bnm(a,s1+m1,l1-m1,s2,m2);
		}
	}
	bn(array,0,len);
	return[5,1]
}
function creaseSort(){
	let array=[...arr];
	let max=1;
	for(;max*2<len;max*=2);
	let next=max;
	while(next>0){
		for(let i=0;i+1<len;i+=2)
			if(compareIndices(array,i,i+1)==1)
				rswap(array,i,i+1);
		for(let j=max;j>=next&&j>1;j/=2)
			for(let i=1;i+j-1<len;i+=2)
				if(compareIndices(array,i,i+j-1)==1)
					rswap(array,i,i+j-1);
		next/=2;
	}
	return[5,1]
}
function iterativeDiamondSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	let m=4;
	for(;m<=n;m*=2){
		for(let k=0;k<m/2;k++){
			let cnt=k<=m/4?k:m/2-k;
			for(let j=0;j<len;j+=m)
				if(j+cnt+1<len)
					for(let i=j+cnt;i+1<minVal(len,j+m-cnt);i+=2)
						if(compareIndices(array,i,i+1)==1)
							rswap(array,i,i+1);
		}
	}
	m/=2;
	for(let k=0;k<=m/2;k++)
		for(let i=k;i+1<minVal(len,m-k);i+=2)
			if(compareIndices(array,i,i+1)==1)
				rswap(array,i,i+1);
	return[0,0]
}
function recursiveDiamondSort(){
	let array=[...arr];
	const sort=(array,start,stop,merge)=>{
		if(stop-start==2){
			if(compareIndices(array,start,stop-1)==1)
				rswap(array,start,stop-1);
		}else if(stop-start>=3){
			let div=(stop-start)/4;
			let mid=(stop-start)/2+start;
			if(merge){
				sort(array,start,mid,1);
				sort(array,mid,stop,1);
			}
			sort(array,div+start|0,div*3+start|0,0);
			sort(array,start,mid,0);
			sort(array,mid,stop,0);
			sort(array,div+start|0,div*3+start|0,0);
		}
	}
	sort(array,0,len,true);
	return[5,1]
}
function foldSort(){
	let array=[...arr];
	let ceilLog=1;
	for(;1<<ceilLog<len;ceilLog++);
	let size=1<<ceilLog;
	for(let k=size>>1;k>0;k>>=1){
		for(let i=size;i>=k;i>>=1){
			for(let j=0;j<len;j+=i){
				let low=j-1,high=j+i
				while(++low<--high)
					if(high<len&&compareIndices(array,low,high)==1)
						rswap(array,low,high);
			}
		}
	}
	return[5,1]
}
function batcherMergeExchangeSort(){
	let array=[...arr];
	let t=log(len-1)/log(2)+1|0;
	let p0=1<<(t-1);
	for(let p=p0;p>0;p>>=1){
		let q=p0;
		let r=0;
		let d=p;
		while(1){
			for(let i=0;i<len-d;i++)
				if((i&p)==r&&compareIndices(array,i,i+d)==1)
					rswap(array,i,i+d);
			if(q==p)break;
			d=q-p;
			q>>=1;
			r=p;
		}
	}
	return[5,1]
}
function recursiveOddEvenMergeSort(){
	let array=[...arr];
	const oemc=(a,i,j)=>{
		if(compareIndices(a,i,j)>0)
			rswap(a,i,j);
	}
	const oem=(a,lo,m2,n,r)=>{
		let m=r*2;
		if(m<n){
			if((n/r|0)%2!=0){
				oem(a,lo,(m2+1)/2,n+r,m);
				oem(a,lo+r,m2/2,n-r,m);
			}else{
				oem(a,lo,(m2+1)/2,n,m);
				oem(a,lo+r,m2/2,n,m);
			}
			if(m2%2|0!=0){
				for(let i=lo;i+r<lo+n;i+=m)
					oemc(a,i,i+r);
			}else
				for(let i=lo+r;i+r<lo+n;i+=m)
					oemc(a,i,i+r);
		}else
			if(n>r)
				oemc(a,lo,lo+r);
	}
	const oems=(a,lo,n)=>{
		if(n>1){
			let m=n/2;
			oems(a,lo,m);
			oems(a,lo+m,n-m);
			oem(a,lo,m,n,1);
		}
	}
	oems(array,0,len);
	return[5,1]
}
function iterativePairwiseMergeSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n<<=1);
	for(let k=n>>1;k>0;k>>=1)
		for(let j=0;j<len;j+=k<<1)
			for(let i=0;i<k;i++)
				if(j+k+i<len&&compareIndices(array,j+i,j+k+i)==1)
					rswap(array,j+i,j+k+i);
	for(let k=2;k<n;k<<=1)
		for(let m=k>>1;m>0;m>>=1)
			for(let j=0;j<len;j+=k<<1)
				for(let p=m;p<((k-m)<<1);p+=m<<1)
					for(let i=0;i<m;i++)
						if(j+p+m+i<len&&compareIndices(array,j+p+i,j+p+m+i)==1)
							rswap(array,j+p+i,j+p+m+i);
	return[5,1]
}
function recursivePairwiseMergeSort(){
	let array=[...arr];
	const pm=(array,a,b)=>{
		let m=(a+b)/2,m1=(a+m)/2,g=m-m1;
		for(let i=0;m1+i<m;i++)
			for(let j=m1,k=g;k>0;k>>=1,j-=k-(i&k))
				if(j+i+k<len&&compareIndices(array,j+i,j+i+k)==1)
					rswap(array,j+i+k,j+i);
		if(b-a>4)pm(array,m,b);
	}
	const pms=(array,a,b)=>{
		let m=(a+b)/2;
		for(let i=a,j=m;i<m;i++,j++)
			if(j<len&&compareIndices(array,i,j)==1)
				rswap(array,i,j);
		if(b-a>2){
			pms(array,a,m);
			pms(array,m,b);
			pm(array,a,b);
		}
	}
	let n=1;
	for(;n<len;n<<=1);
	pms(array,0,n);
	return[5,1]
}
function iterativeWeaveSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	for(let i=1;i<n;i*=2)
		for(let j=1;j<=i;j*=2)
			for(let k=0;k<n;k+=n/j)
				for(let d=n/i/2,m=0,l=n/j-d;l>=n/j/2;l-=d)
					for(let p=0;p<d;p++,m++)
						if(k+l+p<len&&compareIndices(array,k+m,k+l+p)==1)
							rswap(array,k+m,k+l+p);
	return[5,1]
}
function recursiveWeaveSort(){
	let array=[...arr];
	const cr=(array,pos,length,gap)=>{
		if(length<2)return;
		for(let i=0;2*i<(length-1)*gap;i+=gap)
			if(pos+(length-1)*gap-i<len&&compareIndices(array,pos+i,pos+(length-1)*gap-i)==1)
				rswap(array,pos+i,pos+(length-1)*gap-i);
		cr(array,pos,length/2,gap);
		if(pos+length*gap/2<len)cr(array,pos+length*gap/2,length/2,gap);
	}
	const wc=(array,pos,length,gap)=>{
		if(length<2)return;
		wc(array,pos,length/2,2*gap);
		wc(array,pos+gap,length/2,2*gap);
		cr(array,pos,length,gap);
	}
	let n=1;
	for(;n<len;n*=2);
	wc(array,0,n,1);
	return[5,1]
}
function LSDRadixSort(){
	let array=[...arr];
	let base=10
	let c=2,
		min=getMin(array,len),
		max=getMax(array,len),
		exp=1;
	while((max-min)/exp>=1){
		let n,b=new Array(base).fill(0),output=new Array(len);
		for(n=0;n<len;n++)b[((array[n]-min)/exp)%base|0]++;
		for(n=1;n<base;n++)b[n]+=b[n-1];
		for(n=len-1;n>=0;n--)output[--b[((array[n]-min)/exp)%base|0]]=array[n];
		for(n=0;n<len;n++)rset(array,n,output[n]);
		exp*=10;
	}
	return[0,1]
}
function indexSort(){
	let array=[...arr];
	let min=getMin(array,len)
	for(let i=0;i<len;i++){
		let cmpCount=0;
		while(compareValues(i,array[i]-min)!=0&&cmpCount<len)
			rswap(array,i,array[i]-min,cmpCount++);
		if(cmpCount>=len-1)break;
	}
	return[5,1]
}
function bubbleSort(){
	let array=[...arr];
	for(let i=len-1;i>0;i--){
		let s=1;
		for(let j=0;j<i;j++){
			if(compareIndices(array,j,j+1)==1){
				rswap(array,j,j+1);
				s=0;
			}
		}
		if(s)break;
	}
	return[-.2,1]
}
function circloidSort(){
	let array=[...arr];
	const c=(a,l,r)=>{
		let s=0;
		while(l<r){
			if(compareIndices(a,l,r)==1){
				rswap(a,l,r);
				s=1;
			}
			l++;
			r--;
			if(l==r)r++;
		}
		return s;
	}
	const cp=(a,l,r)=>{
		if(l>=r)return false;
		let mid=(l+r)/2|0;
		let lf=cp(a,l,mid);
		let rt=cp(a,mid+1,r);
		return c(a,l,r)||lf||rt;
	}
	while(cp(array,0,len-1));
	return[5,1]
}
function combSort(){
	let array=[...arr];
	for(let i=0;!isSorted(array);i++,i%=len){
		let n=len;
		let d=1;
		while(n!=1||d){
			n=(n*10)/13|0
			if(n<1)n=1;
			d=0;
			if(i>n-len&&compareIndices(array,i,i+n)==1){
				rswap(array,i,i+n)
				d=1
			}
		}
		
	}
	return[5,1]
}
function completeGraphSort(){
	let array=[...arr];
	const cs=(array,a,b)=>{
		if(compareIndices(array,a,b)>0)
			rswap(array,a,b);
	}
	const split=(array,a,m,b)=>{
		if(b-a<2)return;
		let c=0,len1=(b-a)/2;
		let odd=(b-a)%2==1;
		if(odd){
			if(m-a>b-m)c=a++;
			else c=--b;
		}
		for(let s=0;s<len1;s++){
			let i=a;
			for(let j=s;j<len1;j++)
				cs(array,i++,m+j);
			for(let j=0;j<s;j++)
				cs(array,i++,m+j);
		}
		if(odd){
			if(c<m)
				for(let j=0;j<len1;j++)
					cs(array,c,m+j);
			else
				for(let j=0; j<len1;j++)
					cs(array,a+j,c);
		}
	}
	let n=len;
	let d=2,end=1<<(log(n-1)/log(2)|0+1);
	while(d<=end){
		let i=0,dec=0;
		while(i<n){
			let j=i;
			dec+=n;
			while(dec>=d){
				dec-=d;
				j++;
			}
			let k=j;
			dec+=n;
			while(dec>=d){
				dec-=d;
				k++;
			}
			split(array,i,j,k);
			i=k;
		}
		d*=2;
	}
	return[5,1]
}
function funSort(){
	let array=[...arr];
	function bs(array,start,end,value){
		while(start<end){
			let mid=(start+end)>>>1;
			if(compareValues(array[mid],value)<0)start=mid+1;
			else end=mid;
		}
		return start;
	}
	for(let i=1;i<len;i++){
		let done=false;
		do{
			done=true;
			let pos=bs(array,0,len-1,array[i]);
			if(compareIndices(array,pos,i)!=0){
				if(i<pos-1)
					rswap(array,i,pos-1);
				else if(i>pos)
					rswap(array,i,pos);
				done=false;
			}
		}while(!done);
	}
	return[-.05,1]
}
function cocktailShakerSort(){
	let array=[...arr];
	let i=0;
	while(i<len/2){
		let s=true;
		for(let j=i;j<len-i-1;j++){
			if(compareIndices(array,j,j+1)==1){
				rswap(array,j,j+1);
				s=false;
			}
		}
		for(let j=len-i-1;j>i;j--){
			if(compareIndices(array,j,j-1)==-1){
				rswap(array,j,j-1);
				s=false;
			}	
		}
		if(s)break;
		else i++;
	}
	return[-.05,1]
}
function gnomeSort(){
	let array=[...arr];
	for(let i=1;i<len;){
		if(compareIndices(array,i,i-1)>=0)i++;
		else{
			rswap(array,i,i-1);
			if(i>1)i--;
		}
	}
	return[5,1]
}
function LLQuickSort(){
	let array=[...arr];
	function partition(array,lo,hi){
		let pivot=array[hi];
		let i=lo;
		for(let j=lo;j<hi;j++)
			if(compareValues(array[j],pivot)<0)
				rswap(array,i++,j);
		rswap(array,i,hi);
		return i;
	}	
	function quickSort(array,lo,hi){
		if(lo<hi){
			let p=partition(array,lo,hi);
			quickSort(array,lo,p-1);
			quickSort(array,p+1,hi);
		}
	}
	quickSort(array,0,len-1)
	return[5,1]
}
function LRQuickSort(){
	let array=[...arr];
	function quickSort(a,p,r){
		let pivot=p+(r-p+1)/2|0;
		let x=a[pivot];
		let i=p;
		let j=r;
		while(i<=j){
			while(compareValues(a[i],x)==-1)i++;
			while(compareValues(a[j],x)==1)j--;
			if(i<=j)rswap(a,i++,j--);
		}
		if(p<j)quickSort(a,p,j);
		if(i<r)quickSort(a,i,r);
	}
	quickSort(array,0,len-1);
	return[5,1]
}
function oddEvenSort(){
	let array=[...arr];
	while(!isSorted(array)){
		for(let n=0;n<=len-2;n+=2)
			if(compareIndices(array,n,n+1)==1)
				rswap(array,n,n+1);
		for(let n=1;n<=len-2;n+=2)
			if(compareIndices(array,n,n+1)==1)
				rswap(array,n,n+1);
	}
	return[-.05,1]
}
function stoogeSort(){
	let array=[...arr];
	const ss=(a,i,j)=>{
		if(compareIndices(a,i,j)==1)
			rswap(a,i,j);
		if(j-i+1>=3){
			let t=(j-i+1)/3|0;
			ss(a,i,j-t);
			ss(a,i+t,j);
			ss(a,i,j-t);
		}
	}
	ss(array,0,len-1)
	return[4,1]
}
function slopeSort(){
	let array=[...arr];
	for(let i=1,j=1;i<len;i=j,j++)
		for(let k=i-1;k>=0;k--,i--)
			if(compareIndices(array,i,k)<0)
				rswap(array,i,k);
	return[5,1]
}
function shellSort(){
	let array=[...arr];
	for(let i=0;!isSorted(array);i++,i%=len){
		for(let n=len/2|0;n>0;n=n/2|0){
			let j,o=array[i];
			for(j=i;j>=n&&compareValues(array[j-n],o)==1;j-=n)
				rswap(array,j,j-n,1);
			rset(array,j,o);
		}
	}
	return[-.1,1]
}
function recursiveShellSort(){
	let array=[...arr];
	function gis(a,b,c,g){
		for(let i=b+g;i<c;i+=g){
			let k=a[i]
			let j=i-g;
			while(j>=b&&compareValues(k,a[j])<0){
				rset(a,j+g,a[j]);
				j-=g;
			}
			rset(a,j+g,k);
		}
	}
	function rss(a,s,e,g){
		if(s+g<=e){
			rss(a,s,e,3*g);
			rss(a,s+g,e,3*g);
			rss(a,s+2*g,e,3*g);
			gis(a,s,e,g);
		}
	}
	rss(array,0,len,1);
	return[5,1]
}
function andreySort(){
	let array=[...arr];
	function sort(a,b,c){
		while(c>1){
			let k=0;
			for(let i=1;i<c;i++)
				if(compareIndices(a,b+k,b+i)>0)
					k=i;
			rswap(a,b,b+k);
			b++;c--;
		}
	}
	function aswap(a,a1,a2,l){
		while(l-->0)rswap(a,a1++,a2++);
	}
	function backmerge(a,a1,l1,a2,l2){
		let a0=a2+l1;
		for(;;){
			if(compareIndices(a,a1,a2)>0){
				rswap(a,a1--,a0--);
				if(--l1==0)return 0;
			}else{
				rswap(a,a2--,a0--);
				if(--l2==0)break;
			}
		}
		let res=l1;
		do rswap(a,a1--,a0--);while(--l1!=0);
		return res;
	}
	function rmerge(array,a,l,r){
		for(let i=0;i<l;i+=r){
			let q=i;
			for(let j=i+r;j<l;j+=r)
				if(compareIndices(array,a+q,a+j)>0)
					q=j;
			if(q!=i)
				aswap(array,a+i,a+q,r);
			if(i!=0){
				aswap(array,a+l,a+i,r);
				backmerge(array,a+(l+r-1),r,a+(i-1),r);
			}
		}
	}
	function rbnd(l){
		l/=2;
		let k=0;
		for(let i=1;i<l|0;i*=2)
			k++;
		l/=k;
		for(k=1;k<=l|0;k*=2);
		return k;
	}
	function msort(array,a,l){
		if(l<12){
			sort(array,a,l);
			return;
		}
		let r=rbnd(l);
		let lr=(l/r-1)*r;
		for(let p=2;p<=lr;p+=2){
			if(compareIndices(array,a+(p-2),a+(p-1))>0)
				rswap(array,a+(p-2),a+(p-1));
			if((p&2)!=0)continue;
			aswap(array,a+(p-2),a+p,2);
			let m=l-p;
			let q=2;
			for(;;){
				let q0=q*2;
				if(q0>m||(p&q0)!=0)break;
				backmerge(array,a+(p-q-1),q,a+(p+q-1),q);
				q=q0;
			}
			backmerge(array,a+(p+q-1),q,a+(p-q-1),q);
			let q1=q;
			q*=2;
			while((q&p)==0){
				q*=2;
				rmerge(array,a+(p-q),q,q1);
			}
		}
		let q1=0;
		for(let q=r;q<lr;q*=2){
			if((lr&q)!=0){
				q1+=q;
				if(q1!=q)
					rmerge(array,a+(lr-q1),q1,r);
			}
		}
		let s=l-lr;
		msort(array,a+lr,s);
		aswap(array,a,a+lr,s);
		s+=backmerge(array,a+s-1,s,a+lr-1,lr-s)
		msort(array,a,s);
	}
	msort(array,0,len);
	let n=1;
	for(;n*2<=len;n*=2);
	msort(array,0,n*.23|0);
	return[5,1]
}
function blockSwapMergeSort(){
	let array=[...arr];
	const bin=(ar,s,md,e)=>{
		let a=0,
			b=minVal(md-s,e-md),
			m=a+(b-a)/2|0;
		while(b>a){
			if(compareIndices(ar,md-m-1,md+m)==1)a=m+1;
			else b=m;
			m=a+(b-a)/2|0;
		}
		return m;
	}
	const msm=(a,s,md,e)=>{
		let m=bin(a,s,md,e);
		while(m>0){
			for(let i=0;i<m;i++)
				rswap(a,md-m+i,md+i);
			msm(a,md,md+m,e);
			e=md;
			md-=m;
			m=bin(a,s,md,e);
		}
	}
	const msms=(a,b,c)=>{
		let len=c-b,i;
		for(let j=1;j<len;j*=2){
			for(i=b;i+2*j<=c;i+=j*2)
				msm(a,i,i+j,i+j*2);
			if(i+j<c)
				msm(a,i,i+j,c);
		}
	}
	msms(array,0,len);
	return[5,1]
}
function inPlaceMergeSort(){
	let array=[...arr];
	const push=(array,p,a,b)=>{
		if(a==b)return;
		let tmp=array[p];
		rset(array,p,array[a]);
		for(let i=a+1;i<b;i++)
			rset(array,i-1,array[i]);
		rset(array,b-1,tmp);
	}
	const M=(a,b,m,c)=>{
		let i=b,j=m;
		while(i<m&&j<c)
			if(compareIndices(a,i,j)==1)j++;
			else push(a,i++,m,j);
		while(i<m)push(a,i++,m,c);
	}
	const ms=(a,b,c)=>{
		let m=b+(c-b)/2|0;
		if(c-b>2){
			if(c-b>3)
				ms(a,b,m);
			ms(a,m,c);
		}
		M(a,b,m,c);
	}
	ms(array,0,len);
	return[-.05,1]
}
function rotateMergeSort(){
	let array=[...arr];
	function ms(array,a,b,l){
		for(let i=0;i<l;i++)
			rswap(array,a+i,b+i);
	}
	function rotate(array,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				ms(array,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				ms(array,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function bs(array,a,b,value,left){
		while(a<b){
			let m=a+(b-a)/2|0;
			let comp=left?compareValues(value,array[m])<=0:compareValues(value,array[m])<0;
			if(comp)b=m;
			else a=m+1;
		}
		return a;
	}
	function rotateMerge(array,a,m,b){
		let m1,m2,m3;
		if(m-a>=b-m){
			m1=a+(m-a)/2|0;
			m2=bs(array,m,b,array[m1],true);
			m3=m1+(m2-m);
		}else{
			m2=m+(b-m)/2|0;
			m1=bs(array,a,m,array[m2],false);
			m3=(m2++)-(m-m1);
		}
		rotate(array,m1,m,m2);
		if(m2-m3+1>0&&b-m2>0)rotateMerge(array,m3+1,m2,b);
		if(m1-a>0&&m3-m1>0)rotateMerge(array,a,m1,m3);
	}
	function rotateMergeSort(array,a,b){
		let len=b-a,i;
		for(let j=1;j<len;j*=2){
			for(i=a;i+2*j<=b;i+=2*j)
				rotateMerge(array,i,i+j,i+2*j);
			if(i+j<b)
				rotateMerge(array,i,i+j,b);
		}
	}
	rotateMergeSort(array,0,len);
	return[5,1]
}
function strandSort(){
	let array=[...arr];
	function mergeTo(array,subList,a,m,b){
		let i=0,s=m-a;
		while(i<s&&m<b)
			if(compareValues(subList[i],array[m])<0)rset(array,a++,subList[i++]);
			else rset(array,a++,array[m++]);
		while(i<s)rset(array,a++,subList[i++]);
	}
	let subList=new Array(len);
	let j=len,k=j;
	while(j>0){
		write(subList,0,array[0]);
		for(let i=0,p=0,m=1;m<j;m++){
			if(compareValues(array[m],subList[i])>=0){
				write(subList,++i,array[m]);
				k--;
			}else rset(array,p++,array[m]);
		}
		mergeTo(array,subList,--k,j,len);
		j=k;
	}
	return[-.01,1]
}
function weavedMergeSort(){
	let array=[...arr];
	function merge(array,tmp,length,residue,modulus){
		if(residue+modulus>=length)return;
		let low=residue;
		let high=residue+modulus;
		let dmodulus=modulus<<1;
		merge(array,tmp,length,low,dmodulus);
		merge(array,tmp,length,high,dmodulus);
		let nxt=residue;
		for(;low<length&&high<length;nxt+=modulus){
			let cmp=compareIndices(array,low,high);
			if(cmp==1||cmp==0&&low>high){
				write(tmp,nxt,array[high]);
				high+=dmodulus;
			}else{
				write(tmp,nxt,array[low]);
				low+=dmodulus;
			}
		}
		if(low>=length){
			while(high<length){
				write(tmp,nxt,array[high]);
				nxt+=modulus;
				high+=dmodulus;
			}
		}else{
			while(low<length){
				write(tmp,nxt,array[low]);
				nxt+=modulus;
				low+=dmodulus;
			}
		}
		for(let i=residue;i<length;i+=modulus)
			rset(array,i,tmp[i]);
	}
	let tmp=new Array(len);
	merge(array,tmp,len,0,1);
	return[-.01,1]
}
function pancakeSort(){
	let array=[...arr];
	let i=len
	while(i>=0&&!isSorted(array)){
		let c=getMaxIndex(array,i);
		if(c!=--i){
			reversal(array,0,c)
			reversal(array,0,i)
		}
	}
	return[5,1]
}
function maxHeapSort(){
	let array=[...arr];
	heapify(array,0,len,1)
	for(let i=len;i>1;i--){
		rswap(array,0,i-1);
		siftDown(array,1,i-1,0,1);
	}
	return[-.01,1]
}
function minHeapSort(){
	let array=[...arr];
	heapify(array,0,len,0)
	for(let i=len;i>1;i--){
		rswap(array,0,i-1);
		siftDown(array,1,i-1,0,0);
	}
	reversal(array,0,len-1)
	return[-.01,1]
}
function cycleSort(){
	let array=[...arr];
	let i=0
	while(i<len){
		let c=array[i]-1;
		if(compareIndices(array,i,c)!=0)
			rswap(array,i--,c)
		i++
	}
	return[5,1]
}
function inPlaceMSDRadixSort(){
	let array=[...arr];
	const radixMSD=(a,l,min,max,r,p)=>{
		if(min>=max||p<0)return;
		let b=new Array(r);
		for(let i=0;i<r;i++)b[i]=min;
		for(let i=min;i<max;i++){
			let t=a[i];
			let d=getDigit(t,p,r);
			for(let j=r-1;j>d;j--){
				if(b[j]!=b[j-1])
					rset(a,b[j],a[b[j-1]]);
				write(b,j,b[j]+1);
			}
			rset(a,b[d],t);
			write(b,d,b[d]+1);
		}
		for(let i=0;i<r;i++)radixMSD(a,l,i==0?min:b[i-1],b[i],r,p-1);
	}
	let base=4
	let hp=maxLog(array,len,base);
	radixMSD(array,len,0,len,base,hp);
	return[5,1]
}
function asteraceaeSort(){
	let array=[...arr];
	let i=1;
	let fs=2;
	let as=1;
	let ls=0;
	while(as){
		if(fs-1==0)i=1;
		else i=fs-1;
		as=0;ls=0;
		while(i<len){
			if(compareIndices(array,i-1,i)>0){
				rswap(array,i-1,i++);
				if(!as)fs=i-1;
				as=ls=1;
			}else{
				if(ls)i+=floor(sqrt(len));
				else i++;
				ls=0;
			}
		}
	}
	return[5,0]
}
function LMSDRadixSort(){
	let array=[...arr];
	function radixSort(a,s,e,p){
		let regs=new Array(base);
		for(let i=0;i<base;i++)regs[i]=[];
		for(let i=s;i<e;i++){
			let digit=getDigit(a[i],p,base);
			regs[digit]=regs[digit].concat([a[i]]);
		}
		let c=s;
		for(let i=0;i<base;i++)
			for(let j=0;j<regs[i].length;j++)
				rset(a,c++,regs[i][j])
		return regs;
	}
	function lmsdRadixSort(array,mina,maxa,place,maxPlace){
		if(maxPlace<place||maxa-mina<=1)return;
		let regs=radixSort(array,mina,maxa,place);
		if(place!=maxPlace){
			regs=radixSort(array,mina,maxa,maxPlace);
			let sum=0;
			for(let i=0;i<regs.length;i++){
				lmsdRadixSort(array,sum+mina,sum+mina+regs[i].length,place+1,maxPlace-1);
				sum+=regs[i].length;
			}
		}
	}
	let base=4;
	let hp=maxLog(array,len,base);
	lmsdRadixSort(array,0,len,0,hp);
	return[20,1]
}
function awkwardSort(){
	let array=[...arr];
	const awkward=(arr,l,p)=>{
		if(l==1)return;
		l|=0
		p|=0
		awkward(arr,l/2,p);
		awkward(arr,l/2+l%2,p+l/2);
		for(let i=0;i<l/2;i++){
			let a=p+i;
			let b=p+l/2+l%2+i;
			if(compareIndices(arr,a,b)==1)
				rswap(arr,a,b);
		}
		awkward(arr,l/2+l%2,p+l/4);
		awkward(arr,l/2,p);
		awkward(arr,l/2+l%2,p+l/2);
	}
	awkward(array,len,0);
	return[5,1]
}
function chinottoSort(){
	let array=[...arr];
	let d=0;
	let gap=1;
	while(!d){
		let i=0;
		d=1;
		for(;i+gap<len;i++){
			if(compareIndices(array,i,i+gap)==1){
				d=0;
				multiSwap(array,i,i+gap,1);
				gap++;
			}else if(gap>=2)
				gap--;
		}
		for(;i-gap>0;i--){
			if(compareIndices(array,i-gap,i)==1){
				d=0;
				multiSwap(array,i,i-gap,1);
				gap++;
			}else if(gap>=2)gap--;
		}
	}
	return[5,1]
}
function circleMergeSort(){
	let array=[...arr];
	const csr=(a,l)=>{
		let sc=0;
		for(let g=l/2;g>circleDepth;g/=2){
			for(let s=0;s+g<len;s+=2*g){
				let h=s+2*g-1|0;
				let lw=s|0;
				for(;lw<h;){
					if(h<len&&compareIndices(a,lw,h)>0)
						rswap(a,lw,h,sc++);
					lw++;
					h--;
				}
			}
		}
		return sc;
	}
	for(let n=1;n<=len;n*=2)
		while(csr(array,n));
	return[5,1]
}
function clamberSort(){
	let array=[...arr];
	for(let i=1;i<len;i++)
		for(let j=0;j<i;j++)
			if(compareIndices(array,i,j)<0)
				rswap(array,i,j);
	return[5,1]
}
function cocktailGrateSort(){
	let array=[...arr];
	let n=1;
	while(n){
		n=0;
		let i,j;
		for(i=0;i<len-1;i++){
			for(j=len-1;j>i;j--){
				if(compareIndices(array,i,j)>0){
					n=1;
					rswap(array,i,j);
					break;
				}
			}
		}
		if(!n)break;
		for(i=0;i<len-1;i++){
			for(j=i+1;j<len;j++){
				if(compareIndices(array,i,j)>0){
					rswap(array,i,j);
					break;
				}
			}
		}
	}
	return[5,1]
}
function cocktailPushSort(){
	let array=[...arr];
	let as=1;
	while(as){
		as=0;
		let i=1,
			gap=1;
		while(i+gap<=len){
			if(compareIndices(array,i-1,i-1+gap)>0){
				for(let j=1;j<=gap;j++)rswap(array,i-1,i-1+j);
				as=1;
				gap++;
			}else i++;
		}
		i=len;
		gap=1;
		while(i-gap>0){
			if(compareIndices(array,i-1-gap,i-1)>0){
				for(let j=1;j<=gap;j++)rswap(array,i-1,i-1-j);
				as=1;
				gap++;
			}else i--;
		}
	}
	return[0,0]
}
function dandelionSort(){
	let array=[...arr];
	for(let b=0;b<len;){
		let pointer=b;
		let as=0;
		while(pointer<len-1&&compareIndices(array,pointer+1,pointer)<0){
			rswap(array,pointer,pointer+1);
			as=1;
			pointer++;
		}
		if(as){
			if(b>0)b--;
			continue;
		}
		b++;
	}
	return[5,0]
}
function floatSort(){
	let array=[...arr];
	let n=1;
	while(n){
		let h=0;
		n=0;
		for(let g=len-1;g>0;g--){
			let i=h;
			let j=h+1;
			while(i>=0&&compareIndices(array,i,j)>0){
				rswap(array,i--,j--);
				n=1;
			}
			if(i>=0){
				i++;
				j++;
				while(j<len&&compareIndices(array,i,j)>0){
					rswap(array,i++,j++);
					n=1;
				}
			}
			h++;
		}
	}
	return[5,1]
}
function iterativeQuickSort(){
	let array=[...arr];
	let s=0,e=len-1
	let st=new Array(len);
	let top=-1;
	write(st,++top,s);
	write(st,++top,e);
	while(top>=0){
		e=st[top--];
		s=st[top--];
		let pv=array[e];
		let i=s-1;
		for(let j=s;j<e;j++)
			if(compareValues(array[j],pv)<=0)
				rswap(array,++i,j);
		rswap(array,++i,e);
		let p=i
		if(compareValues(p-1,s)==1){
			write(st,++top,s);
			write(st,++top,p-1);
		}
		if(compareValues(e,p+1)==1){
			write(st,++top,p+1);
			write(st,++top,e);
		}
	}
	return[5,1]
}
function indexQuickSort(){
	let array=[...arr];
	const iqs=(array,idx,a,b)=>{
		while(a<b){
			if(compareValues(a,idx[a])!=0){
				let t=array[a];
				let i=a,nxt=idx[a];
				do{
					rset(array,i,array[nxt]);
					write(idx,i,i);
					i=nxt;
					nxt=idx[nxt];
				}while(compareValues(nxt,a)!=0);
				rset(array,i,t);
				write(idx,i,i);
			}
			a++;
		}
	}
	const sort=(array,idx,a,b)=>{
		if(b-a<2)return;
		let c0=a,c1=c0,i;
		let m=a+random()*(b-a)|0;
		for(i=a;i<m;i++)
			if(compareIndices(array,i,m)<=0)
				c1++;
		i++;
		c1++;
		for(;i<b;i++)
			if(compareIndices(array,i,m)<0)
				c1++;
		let p=c1-1;
		for(i=a;i<m;i++){
			if(compareIndices(array,i,m)<=0)
				write(idx,c0++,i);
			else write(idx,c1++,i);
		}
		write(idx,p,i++);
		for(;i<b;i++){
			if(compareIndices(array,i,m)<0)
				write(idx,c0++,i);
			else write(idx,c1++,i);
		}
		iqs(array,idx,a,b);
		sort(array,idx,a,p);
		sort(array,idx,p+1,b);
	}
	let idx=new Array(len);
	sort(array,idx,0,len);
	return[5,1]
}
function pseudoHeapSort(){
	let array=[...arr];
	function sift_down(array,start,length,root){
		let swapped=0;
		let j=root;
		while(2*j<length){
			let k=2*j;
			if(k<length&&compareIndices(array,start+k-1,start+k)==1)
				k++;
			if(compareIndices(array,start+j-1,start+k-1)==1){
				rswap(array,start+j-1,start+k-1);
				j=k;
				swapped=1;
				continue;
			}
			break;
		}
		return swapped;
	}
	let s=1
	while(s--)
		for(let i=len-2;i>=0;i--)sift_down(array,i,len-i+1,1)&&(s=1)
	return[1,1]
}
function circleSort(){
	let array=[...arr];
	const csr=(a,l)=>{
		let sc=0;
		for(let g=l/2;g>circleDepth;g/=2){
			for(let s=0;s+g<len;s+=2*g){
				let h=s+2*g-1|0;
				let lw=s|0;
				for(;lw<h;){
					if(h<len&&compareIndices(a,lw,h)>0)
						rswap(a,lw,h,sc++);
					lw++;
					h--;
				}
			}
		}
		return sc;
	}
	let n=1;
	for(;n<len;n*=2);
	while(csr(array,n)!=0);
	return[5,1]
}
function LLQuickSortMiddlePivotSort(){
	let array=[...arr];
	function partition(array,a,b){
		let i=a,j=i,m=(a+b)/2|0;
		while(j<m){
			if(compareIndices(array,j,m)<=0)
				rswap(array,i++,j);
			j++;
		}
		rswap(array,i,m);
		j=m+1;
		m=i++;
		while(j<b){
			if(compareIndices(array,j,m)<0)
				rswap(array,i++,j);
			j++;
		}
		rswap(array,--i,m);
		return i;
	}
	function quickSort(array,a,b){
		if(b-a>1){
			let p=partition(array,a,b);
			quickSort(array,a,p);
			quickSort(array,p+1,b);
		}
	}
	quickSort(array,0,len);
	return[5,1]
}
function pushSort(){
	let array=[...arr];
	let as=1;
	let i=1;
	let gap=1;
	while(as){
		as=0;
		i=1;
		gap=1;
		while(i+gap<=len){
			if(compareIndices(array,i-1,i-1+gap)>0){
				for(let j=1;j<=gap;j++)rswap(array,i-1,i-1+j);
				as=1;
				gap++;
			}else i++;
		}
	}
	return[5,0]
}
function reflectionSort(){
	let array=[...arr];
	let as=1;
	let i=0;
	while(as){
		i=0;
		as=0;
		while(i<len){
			if(compareIndices(array,i,i+1)>0){
				rswap(array,i,i+1);
				i=(len-1)-i;
				as=1;
			}else i++;
		}
		i=len;
		as=0;
		while(i>1){
			if(compareIndices(array,i-1,i)>0){
				rswap(array,i-1,i);
				i=(len-1)-i;
				as=1;
			}else i--;
		}
	}
	return[5,1]
}
function splitCenterSort(){
	let array=[...arr];
	let way=1;
	let i=1;
	for(let r=1;r<len;r++){
		i=len/2|0;
		while(i<len&&i>0){
			if(compareIndices(array,i-1,i)>0)rswap(array,i-1,i);
			i+=way;
		}
		way*=-1;
	}
	return[5,1]
}
function wiggleSort(){
	let array=[...arr];
	const ws=(a,l,s,e)=>{
		if(e-s<2)return;
		let lp=s;
		let rp=e;
		let mp=(lp+rp)/2|0;
		let sl=1;
		let j=mp;
		for(let i=lp;i<mp;i++){
			for(let k=mp;k<e;k++){
				if(compareIndices(a,i,j)>=0)rswap(a,i,j);
				if(sl)j++;
				else j--;
			}
			if(sl)j--;
			else j++;
			sl=!sl
		}
		ws(a,l,s,mp);
		ws(a,l,mp,e);
	}
	ws(array,len,0,len);
	return[5,1]
}
function zipperSort(){
	let array=[...arr];
	let i=0;
	let gap=2;
	let f=0;
	while(gap>1){
		gap=1;
		i=f>1?f-1:0;
		while(i+gap<len){
			if(compareIndices(array,i,i+gap)>0){
				rswap(array,i,i+gap);
				if(gap==1)f=i;
				gap++;
			}else i++;
		}
	}
	return[5,1]
}
function pairwiseCircleSort(){
	let array=[...arr];
	const pairs=(ar,l,r,g)=>{
		if(l+g>=r)return;
		let a=l;
		while(a+g<=r){
			if(compareIndices(ar,a,a+g)==1)
				rswap(ar,a,a+g);
			a+=g*2;
		}
		pairs(ar,l,r,g*2);
		pairs(ar,l+g,r,g*2);
	}
	const circle=(ar,l,r)=>{
		let a=l;
		let b=r;
		while(l<r){
			if(compareIndices(ar,l,r)==1)
				rswap(ar,l,r);
			l++;
			r--;
		}
	}
	const pairCircle=(a,l,r)=>{
		if(l>=r)return;
		let m=(l+r)/2|0;
		pairs(a,l,r,1);
		circle(a,l,r);
		pairCircle(a,l,m);
		pairCircle(a,m+1,r);
	}
	pairCircle(array,0,len-1);
	insertSort(array,0,len);
	return[5,1]
}
function iterativeSinkingMergeSort(){
	let array=[...arr];
	const bs=(a,s,e)=>{
		let cs=1;
		for(let i=e-1;i>s;i-=cs){
			cs=1;
			for(let j=s;j<i;j++){
				if(compareIndices(a,j,j+1)>0){
					rswap(a,j,j+1);
					cs=1;
				}else cs++;
			}
		}
	}
	let mRun=len;
	for(;mRun>=32;mRun=(mRun+1)/2);
	let i;
	for(i=0;i+mRun<len;i+=mRun)
		bs(array,i,i+mRun);
	bs(array,i,len);
	for(let j=mRun;j<len;j*=2){
		for(i=0;i+2*j<=len;i+=2*j)
			bs(array,i,i+2*j);
		if(i+j<len)
			bs(array,i,len);
	}
	return[5,0]
}
function recursiveSinkingMergeSort(){
	let array=[...arr];
	const bs=(a,s,e)=>{
		let cs=1;
		for(let i=e-1;i>s;i-=cs){
			cs=1;
			for(let j=s;j<i;j++){
				if(compareIndices(a,j,j+1)>0){
					rswap(a,j,j+1);
					cs=1;
				}else cs++;
			}
		}
	}
	function sort(a,s,e){
		if(e-s>16){
			let m=s+(e-s)/2|0;
			sort(a,s,m);
			sort(a,m,e);
			bs(a,s,e);
		} else
			bs(a,s,e);
	}
	sort(array,0,len);
	return[5,0]
}
function cocktailShellSort(){
	let array=[...arr];
	let g=len/2;
	let dir=1;
	while(g>=1){
		if(dir){
			for(let i=g;i<len;i++){
				let tmp=array[i],j=i;
				while(j>=g&&compareValues(array[j-g],tmp)==1){
					rset(array,j,array[j-g]);
					j-=g;
				}
				rset(array,j,tmp);
			}
		}else{
			for(let i=len-g;i>=0;i--){
				let tmp=array[i],j=i;
				while(j<len-g&&compareValues(array[j+g],tmp)==-1){
					rset(array,j,array[j+g]);
					j+=g;
				}
				rset(array,j,tmp);
			}
		}
		g/=2;
		dir=!dir;
	}
	return[5,1]
}
function indexMergeSort(){
	let array=[...arr];
	function sort(ar,idx,a,b){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		sort(ar,idx,a,m);
		sort(ar,idx,m,b);
		let i=a,j=m,c=a;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<=0)write(idx,c++,i++);
			else write(idx,c++,j++);
		}
		while(i<m)write(idx,c++,i++);
		while(j<b)write(idx,c++,j++);
		while(a<b){
			if(compareValues(a,idx[a])!=0){
				let t=array[a];
				let i=a,nxt=idx[a];
				do{
					rset(array,i,array[nxt]);
					write(idx,i,i);
					i=nxt;
					nxt=idx[nxt];
				}while(compareValues(nxt,a)!=0);
				rset(array,i,t);
				write(idx,i,i);
			}
			a++;
		}
	}
	let idx=new Array(len);
	sort(array,idx,0,len);
	return[5,1]
}
function mobMergeSort(){
	let array=[...arr];
	const bubble=(array,start,end)=>{
		let c=1;
		let s;
		let f=start+((end-start)/2)|0;
		let a=false;
		for(let j=end-1;j>0;j-=c){
			if(f-1<start)s=start;
			else s=f-1;
			a=false;
			c=1;
			for(let i=s;i<j;i++){
				if(compareIndices(array,i,i+1)>0){
					rswap(array,i,i+1);
					if(!a)f=i;
					a=true;
					c=1;
				}else c++;
			}
		}
	}
	let l=2;
	let index=0;
	while(l<=len){
		index=0;
		while(index+l<=len){
			if(l==2){
				if(compareIndices(array,index,index+1)>0)rswap(array,index,index+1);
			}else bubble(array,index,index+l);
			index+=l;
		}
		if(index!=len)bubble(array,index,len);
		l*=2;
	}
	bubble(array,0,len);
	return[5,0]
}
function moduloMergeSort(){
	let array=[...arr];
	const mr=(a,s,m,e,mx)=>{
		let l=s;
		let r=m+1;
		let f=s;
		while(l<=m&&r<=e){
			if(compareValues(a[l]%mx,a[r]%mx)<=0)rset(a,f,a[f]+(a[l++]%mx)*mx);
			else rset(a,f,a[f]+(a[r++]%mx)*mx);
			f++;
		}
		while(l<=m)rset(a,f,a[f++]+(a[l++]%mx)*mx);
		while(r<=e)rset(a,f,a[f++]+(a[r++]%mx)*mx);
		for(let i=s;i<=e;i++)rset(a,i,a[i]/mx|0);
	}
	const ms=(a,s,e,mx)=>{
		if(s<e){
			let m=s+((e-s)/2)|0;
			ms(a,s,m,mx);
			ms(a,m+1,e,mx);
			mr(a,s,m,e,mx);
		}
	}
	ms(array,0,len-1,getMax(array,len)+1);
	return[5,1]
}
function split16MergeSort(){
	let array=[...arr];
	let moss=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16,1,5,9,13,2,6,10,14,3,7,11,15,4,8,12,16,1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16,6,11,7,10,4,13,14,15,8,12,2,3,5,9,2,5,8,14,3,9,12,15,6,7,10,11,3,5,12,14,4,9,8,13,7,9,11,13,4,6,8,10,4,5,6,7,8,9,10,11,12,13,7,8,9,10];
	const cs1=(a,b,c)=>{
		if(compareIndices(a,b,c)>0)
			rswap(a,b,c);
	}
	const cs2=(a,b,c,g,s)=>{
		if(compareIndices(a,s+b*g,s+c*g)>0)
			rswap(a,s+b*g,s+c*g);
	}
	const mos=(a,b,g)=>{
		for(let i=0;i<moss.length;i+=2)
			cs2(a,moss[i]-1,moss[i+1]-1,g,b);
	}
	const merge=(a,st,sz)=>{
		let gap=sz/16;
		for(let i=0;i<gap;i++)
			mos(a,st+i,gap);
		for(let s=gap/2;s>0;s/=2)
			for(let i=0;i<sz-s;i++)
				cs1(a,st+i,st+i+s);
	}
	for(let i=0;i<len-15;i+=16)
		mos(array,i,1);
	for(let gap=32;gap<=len;gap*=2)
		for(let i=0;i+gap<=len;i+=gap)
			merge(array,i,gap);
	return[5,1]
}
function cbrtQuickSort(){
	let array=[...arr];
	const sort=(a,start,stop)=>{
		let l=stop-start;
		if(l>=2){
			let root=cbrt(l)|0;
			let newStart=start+root;
			sort(a,start,newStart);
			let pivots=new Array(root);
			for(let i=0;i<root;i++)
				write(pivots,i,i+start);
			for(let i=newStart;i<stop;i++){
				let left=0,right=root;
				while(left<right){
					let mid=(right-left)/2+left|0;
					if(compareIndices(a,pivots[mid],i)==1)right=mid;
					else left=mid+1;
				}
				let pos=i;
				for(let j=root-1;j>=left;j--){
					rswap(a,pivots[j]+1,pos);
					rswap(a,pos=pivots[j],pivots[j]+1);
					write(pivots,j,pivots[j]+1);
				}
			}
			sort(a,start,pivots[0]);
			for(let i=1;i<root;i++)
				sort(a,pivots[i-1]+1,pivots[i]);
			sort(a,pivots[root-1]+1,stop);
		}
	}
	sort(array,0,len)
	return[5,1]
}
function apollyonSort(){
	let array=[...arr];
	const apm=(A,lo,n,d)=>{
		if(n<=1)return;
		let m=1;
		while(m<<1<n)m<<=1;
		for(let i=lo;i<lo+n-m;i++)
			if(d==(compareIndices(A,i,i+m)==1))
				rswap(A,i,i+m)
		apm(A,lo,m,d);
		apm(A,lo+m,n-m,d);
	}
	const aps=(A,lo,n,d)=>{
		if(n<=1)return;
		let m=n/2|0;
		aps(A,lo,m,!d);
		apm(A,lo,n,d);
	}
	aps(array,0,len,1);
	while(rcsr(array,0,len-1,0));
	return[5,1]
}
function optimizedPancakeSort(){
	let array=[...arr];
	function cursedRotate(a,b,m,c){
		reversal(a,0,b-1);
		reversal(a,0,m-1);
		reversal(a,0,c-1);
		reversal(a,0,c-m+b-1);
	}
	function bs(array,a,b,value,left){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(left?compareValues(value,array[m])<=0:compareValues(value,array[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function pm(array,m,b){
		let m1,m2,m3;
		if(m>=b-m){
			m1=m/2|0;
			m2=bs(array,m,b,array[m1],0);
			m3=m1+(m2-m);
		}else{
			m2=m+(b-m)/2|0;
			m1=bs(array,0,m,array[m2],1);
			m3=(m2++)-(m-m1);
		}
		cursedRotate(array,m1,m,m2);
		if(m1>0&&m3>m1)pm(array,m1,m3);
		m3++;
		if(m2>m3&&b>m2){
			cursedRotate(array,0,m3,b);
			pm(array,m2-m3,b-m3);
			cursedRotate(array,0,b-m3,b);
		}
	}
	function pms(array,n){
		if(n<=1)return;
		if(compareIndices(array,0,1)<=0){
			let i=2;
			for(;i<n&&compareIndices(array,i-1,i)<=0;i++);
			if(i==n)return;
		}else{
			let i=2;
			for(;i<n&&compareIndices(array,i-1,i)>0;i++);
			if(i==n){
				reversal(array,0,n-1);
				return;
			}
		}
		let m=n/2|0;
		pms(array,m);
		cursedRotate(array,0,m,n);
		m=n-m;
		pms(array,m);
		pm(array,m,n);
	}
	pms(array,len);
	return[5,1]
}
function magneticaQuickSort(){
	let array=[...arr];
	let left=0,right=len-1,threshold=17,i,j,pl,pr,entries=right-left+1,stack=new Array(entries),stackptr=2,p,lback=left,rback=right,midmid,gear=0,cmp;
	write(stack,1,left);
	write(stack,2,right);
	do{
		right=stack[stackptr];
		left=stack[stackptr-1];
		stackptr-=2;
		for(;left+threshold<right;){
			j=right;
			pl=left;
			pr=left;
			if(right-left>31){
				midmid=left+((right-left)>>2);
				if(gear==0){
					insertSort(array,midmid,midmid+3);
					rswap(array,midmid+1,pr);
				}else{
					insertSort(array,midmid,midmid+7);
					rswap(array,midmid+3,pr);
				}
			}
			p=array[pr];
			for(;pr<j;){
				pr++;
				cmp=compareValues(p,array[pr]);
				if(cmp>0){
					rswap(array,pl,pr);
					pl++;
				}else if(cmp<0){
					for(;compareValues(p,array[j])<0;)j--;
					if(pr<j)rswap(array,pr,j);
					j--;
					pr--;
				}
			}
			j=pl-1;
			i=pr+1;
			gear=(maxVal(right-i,j-left)>(minVal(right-i,j-left)<<6)?1:0);
			if(i+threshold<right){
				stackptr+=2;
				write(stack,stackptr-1,i);
				write(stack,stackptr,right);
				stackptr*=(stackptr+2<=entries-1?1:0);
				right*=(stackptr+2<=entries-1?1:0);
			}
			right=j;
		}
	}while(stackptr!=0);
	insertSort(array,lback,rback+1);
	return[5,1]
}
function cocktailPeelSort(){
	let array=[...arr];
	for(let l=0;l<len;l++){
		let s=0;
		for(let r=len-1;r>l;r--){
			if(compareIndices(array,l,r+s)>0){
				let i=array[r+s];
				for(let p=r+s;p>l;p--)rset(array,p,array[p-1]);
				rset(array,l,i);
				s++;
			}
		}
		l++;
		for(let r=l+1;r<len;r++){
			if(compareIndices(array,l,r)>0){
				let i=array[r];
				for(let p=r;p>l;p--)rset(array,p,array[p-1]);
				rset(array,l,i);
			}
		}
	}
	return[5,1]
}
function ecoloSort(){
	let array=[...arr];
	let l=1;
	let r=len;
	let w=1;
	let i=1;
	while(l<=r){
		if(w==1)i=l;
		else i=r;
		while((w==1&&i<r)||(w==-1&&i>l)){
			if(compareIndices(array,l-1,i-1)>0)rswap(array,l-1,i-1);
			if(compareIndices(array,i-1,r-1)>0)rswap(array,i-1,r-1);
			i+=w;
		}
		l++;
		r--;
		w*=-1;
	}
	return[5,1]
}
function fallSort(){
	let array=[...arr];
	let l=1;
	let r=2;
	let hl=0;
	while(l<=len){
		r=l+1;
		hl=0;
		while(r<=len){
			if(compareIndices(array,l-1,r-1)>0){
				if(hl==0)hl=r;
				else if(compareIndices(array,hl-1,r-1)<0)hl=r;
			}
			r++;
		}
		if(hl==0)l++;
		else rswap(array,l-1,hl-1);
	}
	return[5,1]
}
function heavyHeapSort(){
	let array=[...arr];
	function bitReversal(ar,a,b){
		let len=b-a,m=0;
		let d1=len>>1,d2=d1+(d1>>1);
		for(let i=1;i<len-1;i++){
			let j=d1;
			for(let k=i,n=d2;(k&1)==0;j-=n,k>>=1,n>>=1);
			m+=j;
			if(m>i)rswap(ar,a+i,a+m);
		}
	}
	let dir=1;
	for(let i=0;i<len;i++){
		heapify(array,i,len,dir=!dir);
		for(let n=1;n<i;n+=2){
			if(array[n]>array[n-2])
				rswap(array,n,n-2)
		}
	}
	for(let i=1,j=len-1;i<j;i+=2,j-=2)
		rswap(array,i,j);
	bitReversal(array,0,len);
	bitReversal(array,0,len/2|0);
	bitReversal(array,len/2|0,len);
	return[15,1]
}
function sandPaperSort(){
	let array=[...arr];
	for(let i=0;i<len-1;i++)
		for(let j=i+1;j<len;j++)
			if(compareIndices(array,i,j)>0)
				rswap(array,i,j);
	return[5,1]
}
function recursiveBurningSort(){
	let array=[...arr];
	function sort(array,start,end){
		if(start==end)return;
		let mid=(start+end)/2|0,g0=mid-start;
		if (start==mid)return;
		sort(array,start,mid);
		sort(array,mid,end);
		for(let i=0;i<g0;i++)
			if(i+start!=end-i-1&&compareIndices(array,i+start,end-i-1)==1)
				rswap(array,i+start,end-i-1);
		sort(array,start,mid);
		sort(array,mid,end);
	}
	sort(array,0,len,0);
	return[5,1]
}
function corruptSort(){
	let array=[...arr];
	const comp=(a,s,e)=>{
		if(compareIndices(a,s,e)==1)
			rswap(a,s,e);
	}
	const pass=(a,s,e,l,g,t)=>{
		for(let i=s;i<e;i++)
			for(let g2=g;g2>t;g2/=2)
				if(i+g2<l)
					comp(a,i,i+g2);
	}
	const merge=(a,s,e,b)=>{
		if(e<=s)return;
		let m=(s+e)/2|0,g0=m-s,g1=g0/2|0;
		if(!b)
			for(let i=s;i<m;i++)
				if(i+g0<e)
					comp(a,i,i+g0);
		if(s==m)return;
		if(e-s>4)
			pass(a,s+g1,m,e,g1,1);
		merge(a,s,m,1);
		merge(a,m,e,1);
	}
	const sort=(a,s,e)=>{
		if(e<=s)return;
		let m=(s+e)/2|0;
		if(s==m)merge(a,s,e,0);
		else{
			sort(a,s,m);
			sort(a,m,e);
			merge(a,s,e,0);
		}
	}
	let n=1;
	while(n*2<=len)n*=2;
	sort(array,0,len);
	pass(array,0,len,len,n-1,0);
	return[5,1]
}
function circleHalverSort(){
	let array=[...arr];
	let end;
	const cs=(a,b,c)=>{
		let m=b<c&&c<len&&compareIndices(a,b,c)>0
		m&&rswap(a,b,c);
		return m;
	}
	const bc=(a,b,c)=>{
		let d=0
		for(let i=b,j=c-1;i<j;i++,j--)
			d=cs(a,i,j);
		return d;
	}
	const halver=(a,b,c)=>{
		let n=c-b,e=-1;
		while(1){
			for(let j=1;j<n/2;j*=2)
				for(let i=b;i<minVal(len,c);i+=2*j)
					for(let k=0;k<j;k++)
						cs(a,i+k,i+j+k);
			if(!bc(a,b,c))break;
			e++;
		}
	}
	let l=1<<(log(len-1)/log(2))+1|0;
	halver(array,0,l);
	for(let j=l/2;j>4;j/=2)
		for(let i=0;i+j/2<len;i+=j)
			if(bc(array,i,i+j))
				halver(array,i,i+j);
	for(let i=2;i<len;i+=4)
		cs(array,i-1,i);
	return[5,1]
}
function iterativePairwiseSort(){
	let array=[...arr];
	const sort=(ar,l)=>{
		let a=1,b=0,c=0,d=0,e=0;
		while(a<l){
			b=a;
			c=0;
			while(b<l){
				if(compareIndices(ar,b-a,b)==1)
					rswap(ar,b-a,b);
				c=(c+1)%a;
				b++;
				if(c==0)b+=a;
			}
			a*=2;
		}
		a/=4;
		e=1;
		while(a>circleDepth){
			d=++e;
			while(d>0){
				b=(d+1)*a;
				c=0;
				while(b<l){
					if(compareIndices(ar,b-d*a,b)==1)
						rswap(ar,b-d*a,b);
					c=(c+1)%a;
					b++;
					if(c==0)b+=a;
				}
				d/=2;
			}
			a/=2;
			e*=2;
		}
	}
	sort(array,len);
	return[5,1]
}
function iterativeVanVoorhisSort(){
	let array=[...arr];
	const cs=(a,b,c)=>{
		if(compareIndices(array,b,c)>0)rswap(a,b,c);
	}
	const cr=(a,b,c,s)=>{
		while(s-->0)cs(a,b++,c++);
	}
	for(let k=4;k/4<=len;k*=4){
		let f=k/4;
		for(let i=0;i<len;i+=k){
			cr(array,i,i+f,f);
			cr(array,i+f+f,i+f+f+f,f);
		}
		for(let i=0;i<len;i+=k){
			cr(array,i,i+f+f,f);
			cr(array,i+f,i+f+f+f,f);
		}
		for(let i=0;i<len;i+=k)
			cr(array,i+f,i+f+f,f);
		for(let m=16;m<=k;m*=4){
			let s=k/m;
			for(let i=0;i<len;i+=k){
				for(let j=2;j+7<m;j+=4){
					cr(array,i+j*s,i+(j+6)*s,s);
					cr(array,i+(j+1)*s,i+(j+7)*s,s);
				}
			}
			for(let i=0;i<len;i+=k){
				for(let j=1;j+5<m;j+=4){
					cr(array,i+j*s,i+(j+3)*s,s);
					cr(array,i+(j+2)*s,i+(j+5)*s,s);
				}
			}
			for(let i=0;i<len;i+=k){
				for(let j=2;j+3<m;j+=4){
					cr(array,i+j*s,i+(j+2)*s,s);
					cr(array,i+(j+1)*s,i+(j+3)*s,s);
				}
			}
			for(let i=0;i<len;i+=k)
				for(let j=3;j+3<m;j+=2)
					cr(array,i+j*s,i+(j+1)*s,s);
		}
	}
	return[5,1]
}
function rotateLSDRadixSort(){
	let array=[...arr];
	const multiSwap=(a,b,c,l)=>{
		for(let i=0;i<l;i++)rswap(a,b+i,c+i);
	}
	function rotate(a,b,c,m){
		let l=m-b,r=c-m;
		while(l>0&&r>0){
			if(r<l){
				multiSwap(a,m-r,m,r);
				c-=r;m-=r;l-=r;
			}else{
				multiSwap(a,b,m,l);
				b+=l;m+=l;r-=l;
			}
		}
	}
	function bs(ar,a,b,d,p){
		while(a<b){
			let m=(a+b)/2|0;
			if(getDigit(ar[m],p,base)>=d)b=m;
			else a=m+1;
		}
		return a;
	}
	function merge(array,a,m,b,da,db,p){
		if(b-a<2||db-da<2)return;
		let dm=(da+db)/2|0;
		let m1=bs(array,a,m,dm,p);
		let m2=bs(array,m,b,dm,p);
		rotate(array,m1,m2,m);
		m=m1+(m2-m);
		merge(array,m,m2,b,dm,db,p);
		merge(array,a,m1,m,da,dm,p);
	}

	function ms(ar,a,b,p){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		ms(ar,a,m,p);
		ms(ar,m,b,p);
		merge(ar,a,m,b,0,base,p);
	}
	let base=10;
	let max=maxLog(array,len,base);
	for(let i=0;i<=max;i++)
		ms(array,0,len,i);
	return[5,1]
}
function digSort(){
	let array=[...arr];
	function par(ar,a,b){
		let mx=new Array(b-a),
			max=ar[a];
		for(let i=1;i<b-a;i++){
			if(ar[a+i]>max){
				max=ar[a+i];
				mx[i]=1;
			}
		}
		let p=1;
		for(let i=b-a-1,j=b-a-1;j>=0&&i>=p;j--){
			while(!mx[j]&&j>0)j--;
			max=array[a+j];
			while(max<=ar[a+i]&&i>=p)i--;
			if(compareIndices(ar,a+j,a+i)==1&&p<i-j)p=i-j;
		}
		return p;
	}
	let ls=0,le=0,ms=len-2,sw=1;
	for(let i=0;i<len&&sw;i=ls){
		le=par(array,0,len);
		sw=0;
		let msed=0;
		for(let j=ms;j>=i;j--){
			if(compareIndices(array,j,j+1)>0){
				rswap(array,ls=j,j+1);
				sw=1
				if(msed){
					msed=1;
					ms=j+1<len-1?j+1:len-2;
				}
			}
		}
		for(let l=ls+1;l<=ms&&sw;l++){
			if(compareIndices(array,l,l+1)>0){
				let bl=l+le<len-1?l+le:len-2;
				for(let r=l+1;r<=bl;r++){
					if(compareIndices(array,l,r)>0){
						rswap(array,l++,r);
						if(r>ms)ms=r;
					}
				}
			}
		}
	}
	return[5,0]
}
function cityscapeSort(){
	let array=[...arr];
	function csdep(a,i,j){
		if(i==j)return;
		let b=math.min(i,j),c=math.max(i,j);
		if(compareIndices(a,b,c)>0)rswap(a,b,c);
	}
	function sp(a,s,e,g){
		for(let h=g,i=h+s;i<e;i++){
			let v=a[i],j=i,w=0;
			for(;j>=h&&j-h>=s&&compareValues(a[j-h],v)==1;j-=h)rset(a,j,a[j-h],w=1);
			if(w)rset(a,j,v);
		}
	}
	function sh(a,s,e){
		for(let g=((e-s)/2.25)|0;g>=2;g/=2.25)sp(a,s,e,g|0);
		sp(a,s,e,1);
	}
	function mxs(ar,st,e){
		let a=e-1,b=e-1,sg=1;
		while(sg){
			if(b-1<st)return st;
			if(compareIndices(ar,b-1,b)>0)sg=0;
			else b--;
		}
		let sel=b-1;
		for(let s=b-2;s>=st;s--)
			if(compareIndices(ar,sel,s)<0)sel=s;
		while(compareIndices(ar,sel,a)<=0)
			if(--a<st)break;
		return a+1;
	}
	function shuffle(a,s,e){
		for(let i=s;i<e;i++){
			let r=random()*(e-i)+i|0;
			if(r!=i)rswap(array,i,r);
		}
	}
	let i=len;
	while(i>0){
		let h=i,j=0;
		for(;j<i;j++){
			csdep(array,j,j+1);
			for(h=i-1;h>i-j-2;h--){
				csdep(array,j,h);
				if(h<=j)break;
			}
			if(h<=j)break;
		}
		sh(array,j,i);
		i=mxs(array,0,i);
		shuffle(array,0,i);
	}
	return[5,1]
}
function iterativeClericSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(iclsr(array,n,len));
	return[5,1]
}
function recursiveClericSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rclsr(array,0,n-1,0,len));
	return[5,1]
}
function debrisSort(){
	let array=[...arr];
	let i=0;
	let f=1;
	let l=len-1;
	let nl=len-1;
	let ar=true;
	while(ar){
		ar=false;
		let ff=false;
		if(f>0)i=f-1;
		else i=0;
		for(;i<l;i++){
			let s=i;
			for(;compareIndices(array,i,i+1)>0&&i<l;i++){
				if(!ff){
					f=i;
					ff=true;
				}
				nl=i+1;
			}
			let e=i;
			if(s!=e){
				if(e-s<3)rswap(array,s,e,ar=true);
				else reversal(array,s,e,ar=true);
			}
		}
		if(nl+1<len)l=nl+1;
		else l=len-1;
	}
	return[5,1]
}
function testSort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function s(m=0,i=0){
	arr=create(count).sort((a,b)=>a-b);
	let start=0,end=len-1,done=0,d=1,ticks=0;
	let shuffling=setInterval(()=>{
		ticks++
		if(ticks%3==0)display(arr)
		if(!done){
			canskip=0
			names.innerText="Shuffling...";
			inputdisplay.innerText=""
			if(i==0){
				for(let fv=0;fv<len*.01&&start<count;fv++)swap(arr,start++,random()*len|0,1);
				done=start>=count
			}else if(i==1){
				for(let fv=0;fv<len/100;fv++){
					d=start>=end
					if(!d)swap(arr,start++,end--,1)
				}
				done=d
			}else if(i==2){
				for(let fv=0;fv<len/100;fv++){
					d=start>=len/4|0
					if(!d)swap(arr,start,len-1-start++,1)
				}
				done=d
			}else if(i==3){
				for(let fv=0;fv<len*.01&&start<count;fv++,++start)random()>.8&&swap(arr,start-1,random()*start|0,1);
				done=start>=count
			}else if(i==4&&d){
				d=0
				let tmp=0,s1=1,shuf=setInterval(()=>{
					if(tmp<len/5|0&&s1){
						s1=0
						if(random()>.8){
							let j=tmp+maxVal(random()*len-tmp|0,0),k=setInterval(()=>{
								for(let x=0;x<=len*.25|0;x++){
									if(j<len-1-random()*tmp|0)
										swap(arr,j,++j,1)
									else{
										clearInterval(k)
										tmp++
										s1=1
										break;
									}
								}
							})
						}
						else
							s1=1;
					}else if(s1){
						clearInterval(shuf)
						done=1
					}
				})
			}else if(i==5&&d){
				d=0
				let tmp=0,s1=1,shuf=setInterval(()=>{
					if(tmp<len/5|0&&s1){
						s1=0
						if(random()>.8){
							let j=minVal(random()*len+tmp|0,len-1)-tmp,k=setInterval(()=>{
								for(let x=0;x<=len*.25|0;x++){
									if(j>random()*tmp|0)
										swap(arr,j,--j,1)
									else{
										clearInterval(k)
										tmp++
										s1=1
										break;
									}
								}
							})
						}
						else
							s1=1;
					}else if(s1){
						clearInterval(shuf)
						done=1
					}
				})
			}else if(i==6){
				let tmp=[]
				for(let fv=len-1;fv>1;fv-=2)
					tmp[tmp.length]=arr.splice(fv,1)[0]
				arr=tmp.reverse().concat(arr)
				done=1
			}else if(i==7){
				let half=len/2|0
				let tmp=arr.splice(half,len)
				arr=tmp.concat(arr)
				done=1
			}else if(i==8){
				let tmp=[]
				for(let fv=len-1;fv>1;fv-=2)
					tmp[tmp.length]=arr.splice(fv,1)[0]
				arr=arr.concat(tmp)
				done=1
			}else if(i==9){
				let e=0
				while(e+2<len)e+=2
				for(let start=0,end=e;start<end;start+=2,end-=2)
					swap(arr,start,end)
				done=1
			}else if(i==10){
				let rm=(sqrt(len)/4|0);
				arr=arr.filter((e,i)=>!(++i%rm))
				let temp=[...arr]
				for(let i=0;i<rm;i++)
					arr=arr.concat(temp)
				arr=arr.sort((a,b)=>a-b).splice(0,len)
				let c=len-1;
				while(c)
					swap(arr,c,random()*c--|0)
				done=1
			}else if(i==11){
				swap(arr,random()*len|0,random()*len|0,1)
				done=1
			}else if(i==12&&d){
				d=0
				let k1;
				let n=len/2
				k1=setInterval(()=>{
					if(n>=1){
						for(let x=0;x<=len|0;x++){
							let b=1
							while(n<=len/2&&b){
								let leaf=2*n;
								if(leaf<len&&arr[leaf-1]<arr[leaf])
									leaf++;
								if(arr[n-1]<arr[leaf-1]){
									swap(arr,n-1,leaf-1,1);
									n=leaf;
								}
								else b=0;
							}
							n--
						}
					}else{
						clearInterval(k1)
						done=1
					}
				})
			}else if(i==13&&d){
				d=0
				let c=2,
					min=arr[0],
					max=arr[0],
					exp=1,
					pass=0;
				for(let n=1;n<len;n++){
					if(arr[n]<min)
						min=arr[n];
					if(arr[n]>max)
						max=arr[n];
				}
				let k1,w1=1,k2
				k1=setInterval(()=>{
					if(w1){
						w1=0;
						pass++
						if((max-min)/exp>=1){
							let n,b=new Array(10).fill(0),output=new Array(len);
							for(n=0;n<len;n++)b[((arr[n]-min)/exp)%10|0]++;
							for(n=1;n<10;n++)b[n]+=b[n-1];
							for(n=len-1;n>=0;n--)output[--b[((arr[n]-min)/exp)%10|0]]=arr[n];
							n=-1
							while(n<len){
								if(++n<len)
									arr[n]=output[n];
								else if(pass<2){
									clearInterval(k2);
									w1=1;
									exp*=10;
									break;
								}else{
									clearInterval(k2);
									clearInterval(k1);
									done=1
									break;
								}
							}
						}
					}
				});
			}else if(i==14&&d){
				d=0
				done=1
			}
		}else{
			clearInterval(shuffling);
			canskip=1
			setTimeout(()=>{
				names.innerText=sn[m][0]+" ("+(m+1)+"/"+Object.keys(sn).length+")";
				inputdisplay.innerText=inputs[i]
				rdisp([...sn[m][1](),function(){
					didskip=0
					display(arr)
					let z=-1,y=setInterval(()=>{
						if(z>=len){
							clearInterval(y);
							setTimeout(()=>{
								if(!loopsort.checked){
									m++
									let snl=Object.keys(sn).length
									if(m==snl){
										i++
										i%=inputs.length
										m%=snl
									}
								}
								s(m,i)
							},3e2)
						}
						for(let n=0;n<len*.04;n++){
							mark(++z+1,"lime")
							ctx.fillRect(z*bw,count-arr[z],bw,arr[z])
						}
					},1e3/50)
				}])
			},200);
			display(arr)
		}
	})
}
let c=0
function set(i,v){
	sn[i]=v
}
function get(n,cs=0){
	n=cs?n:n.toLowerCase();
	let offset=[];
	for(let i=0;i<c;i++){
		let v=cs?sn[i][0]:sn[i][0].toLowerCase();
		offset[i]=[0,i]
		for(let j=0;j<n.length;j++,offset[i][0]+=n.length)
			for(let k=j;k<j+n.length;k++)
				if(n[k-j]!==v[k])offset[i][0]--
	}
	return offset.sort((a,b)=>b[0]-a[0])[0][1]
}
set(c++,["Iterative Bitonic Sort",iterativeBitonicSort])
set(c++,["Batcher's Bitonic Sort",batcherBitonicSort])
set(c++,["Iterative Bose-Nelson Sort",iterativeBoseNelsonSort])
set(c++,["Recursive Bose-Nelson Sort",recursiveBoseNelsonSort])
set(c++,["Crease Sort",creaseSort])
set(c++,["Iterative Diamond Sort",iterativeDiamondSort])
set(c++,["Recursive Diamond Sort",recursiveDiamondSort])
set(c++,["Fold",foldSort])
set(c++,["Batcher's Merge-Exchange Sort",batcherMergeExchangeSort])
set(c++,["Recursive Odd-Even Merge Sort",recursiveOddEvenMergeSort])
set(c++,["Iterative Pairwise Merge Sort",iterativePairwiseMergeSort])
set(c++,["Recursive Pairwise Merge Sort",recursivePairwiseMergeSort])
set(c++,["Iterative Weave Sort",iterativeWeaveSort])
set(c++,["Recursive Weave Sort",recursiveWeaveSort])
set(c++,["LSD Radix Sort",LSDRadixSort])
set(c++,["In-Place MSD Radix Sort",inPlaceMSDRadixSort])
set(c++,["L/MSD Radix Sort",LMSDRadixSort])
set(c++,["Index Sort",indexSort])
set(c++,["Bubble Sort",bubbleSort])
set(c++,["Circloid Sort",circloidSort])
set(c++,["Comb Sort",combSort])
set(c++,["Complete Graph Sort",completeGraphSort])
set(c++,["Cocktail Shaker Sort",cocktailShakerSort])
set(c++,["Gnome Sort",gnomeSort])
set(c++,["Left/Left Quick Sort",LLQuickSort])
set(c++,["Left/Right Quick Sort",LRQuickSort])
set(c++,["Odd-Even Sort",oddEvenSort])
set(c++,["Stooge Sort",stoogeSort])
set(c++,["Slope Sort",slopeSort])
set(c++,["Shell Sort",shellSort])
set(c++,["Recursive Shell Sort",recursiveShellSort])
set(c++,["Andrey Astrelin's In-Place Merge Sort",andreySort])
set(c++,["Block-Swap Merge Sort",blockSwapMergeSort])
set(c++,["In-Place Merge Sort",inPlaceMergeSort])
set(c++,["Rotate Merge Sort",rotateMergeSort])
set(c++,["Strand Sort",strandSort])
set(c++,["Weaved Merge Sort",weavedMergeSort])
set(c++,["Pancake Sort",pancakeSort])
set(c++,["Max Heap Sort",maxHeapSort])
set(c++,["Min Heap Sort",minHeapSort])
set(c++,["Cycle Sort",cycleSort])
set(c++,["Fun Sort",funSort])
set(c++,["Asteraceae Sort",asteraceaeSort])
set(c++,["Awkward Sort",awkwardSort])
set(c++,["Chinotto Sort",chinottoSort])
set(c++,["Circle Merge Sort",circleMergeSort])
set(c++,["Clamber Sort",clamberSort])
set(c++,["Cocktail Grate Sort",cocktailGrateSort])
set(c++,["Cocktail Push Sort",cocktailPushSort])
set(c++,["Dandelion Sort",dandelionSort])
set(c++,["Float Sort",floatSort])
set(c++,["Iterative Quick Sort",iterativeQuickSort])
set(c++,["Index Quick Sort",indexQuickSort])
set(c++,["Pseudo Heap Sort",pseudoHeapSort])
set(c++,["Circle Sort",circleSort])
set(c++,["Left/Left Quick Sort (Middle Pivot)",LLQuickSortMiddlePivotSort])
set(c++,["Push Sort",pushSort])
set(c++,["Reflection Sort",reflectionSort])
set(c++,["Split Center Sort",splitCenterSort])
set(c++,["Wiggle Sort",wiggleSort])
set(c++,["Zipper Sort",zipperSort])
set(c++,["Pairwise Circle Sort",pairwiseCircleSort])
set(c++,["Iterative Sinking Merge Sort",iterativeSinkingMergeSort])
set(c++,["Recursive Sinking Merge Sort",recursiveSinkingMergeSort])
set(c++,["Cocktail Shell Sort",cocktailShellSort])
set(c++,["Index Merge Sort",indexMergeSort])
set(c++,["Mob Merge Sort",mobMergeSort])
set(c++,["Modulo Merge Sort",moduloMergeSort])
set(c++,["Split-16 Merge Sort",split16MergeSort])
set(c++,["Cube Root Quick Sort",cbrtQuickSort])
set(c++,["Apollyon Sort",apollyonSort])
set(c++,["Optimized Pancake Sort",optimizedPancakeSort])
set(c++,["Magnetica Quick Sort",magneticaQuickSort])
set(c++,["Cocktail Peel Sort",cocktailPeelSort])
set(c++,["Ecolo Sort",ecoloSort])
set(c++,["Fall Sort",fallSort])
set(c++,["Heavy Heap Sort",heavyHeapSort])
set(c++,["Sandpaper Sort",sandPaperSort])
set(c++,["Recursive Burning Sort",recursiveBurningSort])
set(c++,["Corrupt Sort",corruptSort])
set(c++,["Circle Halver Sort",circleHalverSort])
set(c++,["Iterative Pairwise Sort",iterativePairwiseSort])
set(c++,["Iterative [4,4] Van Voorhis Sort",iterativeVanVoorhisSort])
set(c++,["Rotate LSD Radix Sort",rotateLSDRadixSort])
set(c++,["Dig Sort",digSort])
set(c++,["Cityscape Sort",cityscapeSort])
set(c++,["Iterative Cleric Sort",iterativeClericSort])
set(c++,["Recursive Cleric Sort",recursiveClericSort])
set(c++,["Debris Sort",debrisSort])
set(c++,["test",testSort])
//set(c++,["test",testSort])
const inputs=[
	"Random",
	"Reversed",
	"Half-Reversed",
	"Slightly Scrambled",
	"Scrambled Tail",
	"Scrambled Head",
	"Final Merge",
	"Reversed Array Final Merge",
	"Pipe Organ",
	"Reversed Evens",
	"Many Similar",
	"Almost Sorted",
	"Heapified Input",
	"Final Radix Pass",
	"Sorted",
]
s(c-1)
//andrey sort only works for powers of 2
		</script>
	</body>
</html>