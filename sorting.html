<!DOCTYPE html>
<html>
	<head>
		<title></title>
		<meta name="viewport"content="width=device-width,initial-scale=1">
		<style>
			body{
				overflow:scroll;
				padding:0;
				margin:0 auto;
			}
			#cvs{
				background:#000;
				aspect-ratio:auto;
			}
			#name,td,#note{
				font-family:monospace;
				color:#fff;
			}
		</style>
	</head>
	<body bgcolor=#222>
		<table>
			<tr>
				<td id=names colspan=2></td>
			</tr>
			<tr>
				<td id=m0>bar</td>
				<td><input type=checkbox oninput='m0.innerText=dtype.checked?"bar":"pixel"'id=dtype checked/></td>
			</tr>
			<tr>
				<td>loop</td>
				<td><input type=checkbox id=loopsort /></td>
			</tr>
			<tr>
				<td>speed</td>
				<td>
					<select oninput='speed=this.value'>
						<option value=0>1x</option>
						<option value=1>2x</option>
						<option value=2>5x</option>
						<option value=3>10x</option>
					</select>
				</td>
			</tr>
		</table>
		<canvas id=cvs></canvas>
		<p id=note></p>
		<script>
const ctx=cvs.getContext("2d"),count=512,spi=[1,2,5,10];
let speed=0,bw=(Math.max(window.innerWidth,window.innerHeight)/Math.min(window.innerWidth,window.innerHeight)).toFixed(2)-.1
Array.from(document.getElementsByTagName("td")).map(e=>e.style.fontSize=count/30+"px")
names.style.fontSize=count/30+"px"
note.style.fontSize=count/40+"px"
cvs.width=count*bw
cvs.height=count
window.onresize=function(){
	bw=(Math.max(window.innerWidth,window.innerHeight)/Math.min(window.innerWidth,window.innerHeight)).toFixed(2)-.1
	cvs.width=count*bw
	cvs.height=count
}
let reqs=0;
let rps=0;
function mark(i){
	reqs++
	if(reqs%(rps%25|0)){
		ctx.fillStyle="#f00";
		ctx.fillRect(i*bw,count-arr[i],bw,dtype.checked?arr[i]:bw)
	}
	rps++
	setTimeout(()=>{
		rps--
	},1e3);
}
function swap(a,f,t){
	//mark(f);
	//mark(t);
	let o=a[f];
	a[f]=a[t];
	a[t]=o;
}
function create(c){
	let a=[...Array(c).keys()].map((e,i)=>i+1);
	while(c--)swap(a,c,Math.random()*c|0);
	return a
}
function display(arr){
	ctx.clearRect(0,0,cvs.width,cvs.height)
	ctx.fillStyle="#fff";
	for(let i=0;i<arr.length;i++)ctx.fillRect(i*bw,count-arr[i],bw,dtype.checked?arr[i]:bw)
}
const sn=[
	["homemade",0,"yes"],
	["homemade 2",0,"yes 2"],
	["cycle",0,"pretty interesting, how they find their way to the correct position"],
	["insertion",2,"pushes back lesser values"],
	["selection",0,"starts from the bottom, finds the minimum value and place it onto the selected index"],
	["shell (modified)",0,"very cool looking when sorting reversed arrays\n\n array is reversed using insertion sort"],
	["comb",0,"combing"],
	["bubble",25,"iterates through the array to find a value thats greater than the next, if it finds one it swaps them"],
	["odd-even",25,"similar to bubble sort. only difference is that it pushes greater values upwards"],
	["cocktail",50,"it works just like selection, but alternates from finding maximum and minimum values"],
	["pancake",5,"starts from the top, finds the maximum value then flips the lesser values and repeat"],
	["radix",0,"the coolest(and hardest to code, imo) sorting algorithm"],
	["bead",0,"didn't expect this result(you can search it up), but still cool"],
	["quick",0,"after days of research, i have found a non-recursive version"],
]//.map(e=>[e[0],0])
let arr=[...Array(count).keys()].map((e,i)=>i+1);
function s(m){
	let data={},sorted=JSON.parse(JSON.stringify(arr)).sort((a,b)=>a-b).join(""),i=0,int;
	let status=true;
	let c=0;
	arr=[...Array(count).keys()].map((e,i)=>i+1);
	let shuffling=setInterval(()=>{
		if(c<count){
			names.innerText="Shuffling...";
			note.innerText="";
			for(let fv=0;fv<arr.length/100&&c<count;fv++){
				swap(arr,c++,Math.random()*c|0);
				display(arr)
			}
		}else{
			clearInterval(shuffling);
			reqs=0;
			setTimeout(()=>{
				names.innerText=m+": "+sn[m-1][0]+" sort";
				note.innerText=sn[m-1][2];
				int=setInterval(()=>{
					let len=arr.length
					if(arr.join("")==sorted){
						clearInterval(int);
						let z=0,y=setInterval(()=>{
							if(z>=len){
								clearInterval(y);
								setTimeout(()=>{
									display(arr)
									!loopsort.checked&&(m%=sn.length,m++)
									s(m)
								},3e2)
							}
							ctx.fillStyle="lime";
							for(let n=0;n<len/100;n++)ctx.fillRect(z*bw,count-arr[z],bw,arr[z++])
						})
					}
					for(let speeder=0;speeder<spi[speed];speeder++){
						len=arr.length
						display(arr)
						if(m==1){//homemade 1
							let x=len-i;
							for(let n=1;n<=len;n++){
								if(arr[x]<arr[x-n])
									swap(arr,x,x-n);
							}
						}else if(m==2){//homemade 2
							for(let n=1;n<=len;n++){
								if(arr[i]>arr[i+n]){
									swap(arr,i,i+n)
								}
							}
						}else if(m==3){//cycle
							let c=arr[i]-1;
							if(arr[i]!==arr[c]){
								swap(arr,i,c)
							}
						}else if(m==4){//insertion
							let c=arr[i],
								j=i-1;
							while(j>=0&&arr[j]>c){
								mark(j+1)
								arr[j+1]=arr[j--];
							}
							arr[j+1]=c;
						}else if(m==5){//selection
							let n=i;
							for(let j=i+1;j<len;j++){
								if(arr[j]<arr[n]){
									n=j;
								}
							}
							swap(arr,n,i);
						}else if(m==6){//shell
							data.wasReversed=data.wasReversed||"n";
							if(data.wasReversed=="n"){
								let c=arr[i],
									j=i-1;
								while(arr[j]<c){
									mark(j+1);
									arr[j+1]=arr[j--];
								}
								arr[j+1]=c;
								let reversed=true
								for(let n=len-1;n>0;n--){
									if(arr[n-1]<arr[n]){
										reversed=false;
									}
								}
								data.wasReversed=reversed;
							}else{
								for(let n=len/2|0;n>0;n=n/2|0){
									let j,o=arr[i];
									for(j=i;j>=n&&arr[j-n]>o;j-=n){
										swap(arr,j,j-n);
									}
									arr[j]=o;
								}
							}
						}else if(m==7){//comb
							let n=len;
							let d=1;
							while(n!=1||d){
								n=parseInt((n*10)/13,10)
								if(n<1)n=1;
								d=0;
								if(i>n-len&&arr[i]>arr[i+n]){
									d=1
									swap(arr,i,i+n)
								}
							}
						}else if(m==8){//bubble
							for(let j=1;j<len;j++){
								if(arr[j-1]>arr[j]){
									swap(arr,j-1,j)
								}
							}
						}else if(m==9){//odd-even
							for(let n=1;n<=len-2;n+=2){
								if(arr[n]>arr[n+1]){
									swap(arr,n,n+1)
								}
							}
							for(let n=0;n<=len-2;n+=2){
								if(arr[n]>arr[n+1]){
									swap(arr,n,n+1)
								}
							}
						}else if(m==10){//cocktail
							for(let n=i;n<len-1;++n){
								if(arr[n]>arr[n+1]){
									swap(arr,n,n+1)
								}
							}
							for(let n=len-1;n>=i;n--){
								if(arr[n]>arr[n+1]){
									swap(arr,n,n+1)
								}
							}
						}else if(m==11){//pancake
							let n=len-i;
							let c=(()=>{let u,p;for(u=0,p=0;p<n;++p)if(arr[p]>arr[u])u=p;return u})()
							if(c!=n-1){
								let f=(r,s=0)=>{
									while(s<r)swap(arr,s++,r--)
								}
								f(c)
								f(--n)
							}
						}else if(m==12){//radix
							data.c=data.c||1;
							if(1===data.c){
								data={c:2,f:data.f||false,min:data.min||arr[0],max:data.max||arr[0],exp:data.exp||1,psa:data.psa||JSON.parse(JSON.stringify(arr))}
								if(!data.f){
									data.f=1;
									for(let n=1;n<len;n++){
										if(arr[n]<data.min){
											data.min=arr[n];
										}else if(arr[n]>data.max){
											data.max=arr[n];
										}
									}
								}
								if((data.max-data.min)/data.exp>=1){
									let n,b=new Array(10).fill(0),output=new Array(len);
									for(n=0;n<len;n++)b[((arr[n]-data.min)/data.exp)%10|0]++;
									for(n=1;n<10;n++)b[n]+=b[n-1];
									for(n=len-1;n>=0;n--)output[--b[((data.psa[n]-data.min)/data.exp)%10|0]]=data.psa[n];
									n=-1
									let k=setInterval(()=>{
										if(++n<len){
											data.psa[n]=output[n];
											swap(arr,n,arr.indexOf(data.psa[n]));
										}else{
											clearInterval(k);
											data.c=1;
											data.exp*=10;
										}
									})
								}
							}
						}else if(m==13){//bead
							data.f=data.f||false
							if(!data.f){
								data.f=1
								let m=arr[0];
								for(let n=1;n<len;n++)
									if(arr[n]>m)
										m=arr[n];
								let b=new Array(len).fill().map(e=>new Array(m).fill(0));
								for(let n=0;n<len;n++)
									for(let j=0;j<arr[n];j++)
										b[n][j]=1;
								for(let j=0;j<m;j++){
									let s=0;
									for(let n=0;n<len;n++){
										s+=b[n][j];
										b[n][j]=0;
									}
									for(let n=len-1;n>=len-s;n--)
										b[n][j]=1;
								}
								let psa=new Array(len).fill(0)
								for(let n=len-1;n>=0;n--){
									let j=m,k=setInterval(()=>{
										if(--j>=0){
											psa[n]+=b[n][j];
											let t=arr.indexOf(psa[n])
											if(t!=-1)
												swap(arr,n,t);
										}else clearInterval(k);
									})
								}
							}
						}else if(m==14){//quick
							data.f=data.f||false
							if(!data.f){
								data.f=1;
								let l=0,h=arr.length-1;
								let stack = new Array(h - l + 1);
								stack.fill(0);
								let top = -1;
								stack[++top] = l;
								stack[++top] = h;
								let wait=true
								let p,k1=setInterval(()=>{
									if(p){
										if(p-1>l){
											stack[++top]=l;
											stack[++top]=p-1;
										}
										if(p+1<h){
											stack[++top]=p+1;
											stack[++top]=h;
										}
										p=null;
										wait=1;
									}else if(top>=0&&wait){
										wait=0
										h=stack[top--];
										l=stack[top--];
										let pivot=arr[h];
										let n=(l-1);
										let j=l;
										let k2=setInterval(()=>{
											if(j<=h-1){
												if(arr[j]<=pivot){
													n++;
													swap(arr,n,j)
												}
											}else{
												clearInterval(k2)
												swap(arr,n+1,h)
												p=n+1
											}
											j++
										})
									}else{
										let finish=1
										for(let n=1;n<len;n++){
											if(arr[n-1]>arr[n])
												finish=0;
										}
										if(finish)clearInterval(k1)
									}
								})
							}else if(m==15){
								
							}
						}
						i++;
						i%=count;
						while(m!=1&&m!=4&&m!=9&&m!=11&&arr[i]+1==arr[i+1]&&arr[i]+2==arr[i+2]){i++;i%=count}
					}
				},sn[m-1][1])
			},250);
			display(arr)
		}
	})
}
s(14)
		</script>
	</body>
</html>