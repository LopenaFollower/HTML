<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport"content="width=device-width,initial-scale=1">
		<style>
			body{
				overflow-y:scroll;
				padding:0;
				margin:0 auto;
				zoom:.6;
				user-select:none;
			}
			div.holder{display:flex}
			#cvs{
				background:#000;
				aspect-ratio:auto;
			}
			td.lfa{text-align:right}
			td,#names,.topicname,#nextsort{
				font-family:monospace;
				color:#fff;
			}
			td{
				white-space:nowrap;
				overflow:none;
				text-overflow:clip;
			}
			legend{
				color:#fff;
				font:5px;
			}
			fieldset{width:fit-content}
			div.btnholder{
				transition-timing-function:linear;
				transition-duration:.2s;
				border-radius:4px;
				background:#1d2a35;
				border:3px black solid;
				height:0px;
				opacity:0;
				margin:0 5;
				overflow:scroll;
				width:fit-content;
			}
			div.selectbtn{
				color:#fff;
				background:#04aa6d;
				border-radius:10px;
				padding:3px;
				margin:3px;
				border:1px black solid;
			}
			div.topicname{
				margin:5px;
				border:2px dashed grey;
				padding:2px;
				text-align:center;
			}
			div.space{display:none;}
		</style>
	</head>
	<body bgcolor=#0e151a>
		<br>
		<span id=names></span>
		<div class=holder>
			<fieldset>
				<legend>Options</legend>
				<table>
					<tr>
						<td id=m0>bar</td>
						<td><input type=checkbox oninput='m0.innerText=dtype.checked?"bar":"pixel"'id=dtype checked/></td>
					</tr>
					<tr>
						<td>loop</td>
						<td><input type=checkbox id='loopsort'/></td>
					</tr>
					<tr>
						<td>pause</td>
						<td><input type=checkbox id='pause'/></td>
					</tr>
					<tr>
						<td>mark</td>
						<td><input type=checkbox id=markarray checked oninput='userinp=this.checked'/></td>
					</tr>
					<tr>
						<td>next shuffle</td>
						<td><input type=checkbox id='nextshuffle'/></td>
					</tr>
					<tr>
						<td>zoom (25-200)</td>
						<td><input style='width:40px'value=60 type=number oninput='if(this["value"]>=25&&this["value"]<=200)document.body.style.zoom=this["value"]/100'/></td>
					</tr>
					<tr>
						<td>skip</td>
						<td><button style='width:40px'onclick='canskip&&arr.sort((a,b)=>a-b)&&(didskip=true)'>btn</button></td>
					</tr>
				</table>
			</fieldset>
			<fieldset>
				<legend>Info</legend>
				<table>
					<tr>
						<td>Elements</td>
						<td class=lfa id=elementcount></td>
					</tr>
					<tr>
						<td>FPS</td>
						<td class=lfa id=fpsdisplay>60</td>
					</tr>
					<tr>
						<td>Swaps</td>
						<td class=lfa id=swapdisplay>0</td>
					</tr>
					<tr>
						<td>Writes</td>
						<td class=lfa id=writedisplay>0</td>
					</tr>
					<tr>
						<td>Input</td>
						<td class=lfa id=inputdisplay></td>
					</tr>
					<tr>
						<td>Input</td>
						<td class=lfa id=inputdisplay2></td>
					</tr>
					<tr>
						<td>sound</td>
						<td><input type=checkbox id='audio'oninput='playsound=this.checked'/></td>
					</tr>
				</table>
			</fieldset>
			<fieldset>
				<legend>Debug</legend>
				<table>
					<tr>
						<td>Frame</td>
						<td class=lfa id=framecount></td>
					</tr>
					<tr>
						<td>Rate</td>
						<td class=lfa id=framerate></td>
					</tr>
					<tr>
						<td>Sorted</td>
						<td class=lfa id=finalresult></td>
					</tr>
					<tr>
						<td>Duration</td>
						<td class=lfa id=duration></td>
					</tr>
					<tr>
						<td>Estim Finish</td>
						<td class=lfa id=estimated></td>
					</tr>
					<tr>
						<td>Rate</td>
						<td class=lfa><input type=number value='-1' id=rate style='width:60px'oninput='let tv=parseFloat(this["value"]);if(tv>=-50&&tv<=500)atr=tv'/></td>
					</tr>
					<tr>
						<td>Fixed Rate</td>
						<td class=lfa><input type=checkbox id=fixedrate checked /></td>
					</tr>
				</table>
			</fieldset>
		</div>
		<div class=holder>
			<div>
				<canvas id=cvs></canvas>
				<div id=nextsort>Next: ...</div>
			</div>
			<div>
				<div class=topicname>Shuffles<div class=space>&nbsp;</div><div class=holder><div id=shufflesholder class=btnholder></div></div></div><br>
				<div class=topicname>Sorts<div class=space>&nbsp;</div><div class=holder><div id=sortsholder class=btnholder></div></div></div>
				<div class=topicname>Merge<div class=space>&nbsp;</div><div class=holder><div id=mergesortsholder class=btnholder></div></div></div>
				<div class=topicname>Quick<div class=space>&nbsp;</div><div class=holder><div id=quicksortsholder class=btnholder></div></div></div>
				<div class=topicname>Cocktail<div class=space>&nbsp;</div><div class=holder><div id=cocktailsortsholder class=btnholder></div></div></div>
				<div class=topicname>Binary<div class=space>&nbsp;</div><div class=holder><div id=binarysortsholder class=btnholder></div></div></div>
				<div class=topicname>Recursive<div class=space>&nbsp;</div><div class=holder><div id=recursortsholder class=btnholder></div></div></div>
				<div class=topicname>Iterative<div class=space>&nbsp;</div><div class=holder><div id=itersortsholder class=btnholder></div></div></div>
			</div>
		</div>
		<br>
		<script>
window.onresize=resize;window.onblur=function(){pause.checked=1};window.onfocus=function(){pause.checked=0}
const count=512,ctx=cvs.getContext("2d"),logs=[],sn=[],len=count,{random,ceil,floor,round,sqrt,cbrt,log,abs,pow,clz32,sin,sign,PI}=Math;
let userinp=1,swaps=0,writes=0,aud=false,playsound=false,queue,queue2,atr,curDur=Date.now(),dcd=false,cancel=0,bw=(maxVal(window.innerWidth,window.innerHeight)/minVal(window.innerWidth,window.innerHeight)).toFixed(2),arr,canskip=1,canq2=0,didskip=0;
function resize(){bw=(maxVal(window.innerWidth,window.innerHeight)/minVal(window.innerWidth,window.innerHeight)).toFixed(2);let horizontal=maxVal(window.innerWidth,window.innerHeight),vertical=minVal(window.innerWidth,window.innerHeight);Array.from(document.querySelectorAll("td,legend")).map(e=>e.style.fontSize=horizontal/50+"px");names.style.fontSize=horizontal/50+"px";cvs.width=count*bw;cvs.height=count;cvs.style.width=horizontal*.75+"px";cvs.style.height=vertical*.75+"px";elementcount.innerText=count;}
resize()
const fps=(()=>{
	let el1=Date.now(),el2=Date.now(),frame=0,fps=60,rate=2;
	let update=()=>{
		if(Date.now()-el1<=1e3/rate)frame+=rate
		else{
			el1=Date.now();fps=frame
			if(fps<30)markarray.checked=0;if(fps>=55)markarray.checked=userinp;
			fpsdisplay.innerText=fps;frame=0
		}
		if(Date.now()-el2>=1e3/16){
			el2=Date.now();
			swapdisplay.innerText=swaps.toLocaleString()
			writedisplay.innerText=writes.toLocaleString()
			dcd&&(duration.innerText=((Date.now()-curDur)/1000).toFixed(1)+"s");
		}
		requestAnimationFrame(update)
	}
	requestAnimationFrame(update)
	return{g:()=>fps}
})();
const isSorted=a=>a.every((e,i)=>!i||a[i-1]<=e);
const rangeSorted=(a,s,e)=>a.every((v,i)=>!i||a[i-1]<=v||i>=e);
class Shuffles{
	constructor(){
		this.steps=[];
	}
	swap(a,f,t,aux){
		f|=0;t|=0;let o=a[f];a[f]=a[t];a[t]=o;
		if(aux)return;
		this.steps.push(["swap",f,t])
	}
	write(a,i,v,aux){
		i|=0;v|=0;a[i]=v;
		if(aux)return;
		this.steps.push(["set",i,v])
	}
	reversal(a,s,l,aux){
		if(l-s>0)
			for(let i=s,j=l-1;i<j;i++,j--)
				this.swap(a,j,i,aux);
	}
	arraycopy(s,sp,d,dp,l,aux){
		let b=s!=d||dp<sp,st=b?0:l-1,e=b?l:-1,dr=b?1:-1;
		for(let i=st;i!=e;i+=dr)
			this.write(d,dp+i,s[sp+i],aux);
	}
	multiSwap(a,p,t,aux){
		if(t-p>0)for(let i=p;i<t;i++)this.swap(a,i,i+1,aux);
		else for(let i=p;i>t;i--)this.swap(a,i,i-1,aux);
	}
	customFunc(f,args){
		this.steps.push(["custom",btoa("("+f+")"),...args])
	}
	siftDown(a,r,d,s,m,aux){
		let cv=m?-1:1;
		while(r<=d/2){
			let l=2*r;
			if(l<d&&compareIndices(a,s+l-1,s+l)==cv)l++;
			if(compareIndices(a,s+r-1,s+l-1)==cv){
				this.swap(a,s+r-1,s+l-1,aux)
				r=l;
			}else break;
		}
	}
	heapify(ar,lw,h,m,aux){
		let le=h-lw;
		for(let i=le/2;i>=1;i--)
			this.siftDown(ar,i,le,lw,m,aux)
	}
	shuffles(a,s,e,type){
		let aux,len,max,rot,sz,min,base,exp,mask,counts,mid,tmp=new Array(e),i,j,k,b,c,d,f,g,h,l,m,n,o,p,q,r,t,u,v,w,x,y,z;
		switch(type){
		case 0://random
			this.shuffle(a,s,e);
		break;
		case 1://reverse
			this.reversal(a,s,e);
		break;
		case 2://almost
			for(let i=0;i<maxVal(e/20|0,1);i++)
				this.swap(a,random()*e,random()*e);
		break;
		case 3://sorted
			this.sort(a,s,e)
		break;
		case 4://naive
			for(let i=s;i<e;i++)this.swap(a,i,random()*e);
		break;
		case 5://shuffle tail
			i=0,j=0,k=0;
			while(i<e)
				if(random()<1/7)this.write(tmp,k++,a[i++],true);
				else this.write(a,j++,a[i++]);
			this.arraycopy(tmp,0,a,j,k);
			this.shuffle(a,j,e);
		break;
		case 6://shuffle head
			i=0,j=0,k=0;
			while(i<e)
				if(random()<1/7)this.write(tmp,k++,a[i++],true);
				else this.write(a,j++,a[i++]);
			this.arraycopy(tmp,0,a,j,k);
			this.shuffle(a,j,e);
			for(let i=j-1;i>=0;i--)this.swap(a,(e-j+i)%e,(i)%e);
		break;
		case 7://Shifted Element
			while(i==j){i=random()*e|0;j=random()*e|0;}
			this.swap(a,i,j)
		break;
		case 8://Noisy
			j=maxVal(4,sqrt(e)/2|0);
			for(i=0;i+j<=e;i+=random()*(j-1)+1)this.shuffle(a,i,i+j);
			this.shuffle(a,i,e);
		break;
		case 9://Shuffled Odds
			for(let i=1;i<e;i+=2)this.swap(a,i,(random()*(e-i)/2|0)*2+i);
		break;
		case 10://Final Merge Pass
			c=2;k=0
			for(let j=0;j<c;j++)for(let i=j;i<e;i+=c)this.write(tmp,k++,a[i],true);
			for(let i=0;i<e;i++)this.write(a,i,tmp[i]);
		break;
		case 11://Shuffled Final Merge
			this.shuffle(a,s,e)
			m=e/2|0;
			this.sort(a,s,m)
			this.sort(a,m+1,e)
		break;
		case 12://Shuffled Half
			this.shuffle(a,s,e)
			this.sort(a,s,e/2|0)
		break;
		case 13://Partitioned 
			this.sort(a,s,e)
			this.shuffle(a,s,e/2|0)
			this.shuffle(a,e/2|0,e)
		break;
		case 14://Sawtooth
			c=4;k=0;
			for(let j=0;j<c;j++)for(let i=j;i<e;i+=c)this.write(tmp,k++,a[i],true);
			for(let i=0;i<e;i++)this.write(a,i,tmp[i]);
		break;
		case 15://Pipe Organ
			for(let i=0,j=0;i<e;i+=2)tmp[j++]=a[i];
			for(let i=1,j=e;i<e;i+=2)tmp[--j]=a[i];
			for(let i=0;i<e;i++)this.write(a,i,tmp[i]);
		break;
		case 16://Final Bitonic Pass
			this.reversal(a,0,e);
			for(let i=0,j=0;i<e;i+=2)tmp[j++]=a[i];
			for(let i=1,j=e;i<e;i+=2)tmp[--j]=a[i];
			for(let i=0;i<e;i++)this.write(a,i,tmp[i]);
		break;
		case 17://Interlaced
			this.arraycopy(a,0,tmp,0,e,true);
			l=1;r=e-1;
			for(let i=1;i<e;i++)
				if(i%2==0)this.write(a,i,tmp[l++]);
				else this.write(a,i,tmp[r--]);
		break;
		case 18://Double Layered
			for(let i=0;i<e/2;i+=2)this.swap(a,i,e-i-1);
		break;
		case 19://Final Radix Pass
			len=e;len-=e%2;mid=e/2;tmp=new Array(mid);
			for(let i=0;i<mid;i++)this.write(tmp,i,a[i],true);
			for(let i=mid,j=0;i<e;i++,j+=2){
				this.write(a,j,a[i]);
				this.write(a,j+1,tmp[i-mid]);
			}
		break;
		case 20://Real Final Radix
			base=10;c=2;min=minVal(a);max=maxVal(a);exp=1;p=0;
			while((max-min)/exp>=1&&p++<2){
				b=new Array(base).fill(0),o=new Array(e);
				for(n=0;n<e;n++)b[((a[n]-min)/exp)%base|0]++;
				for(n=1;n<base;n++)b[n]+=b[n-1];
				for(n=e-1;n>=0;n--)o[--b[((a[n]-min)/exp)%base|0]]=a[n];
				for(n=0;n<e;n++)this.write(a,n,o[n]);
				exp*=10;
			}
		break;
		case 21://Recursive Final Radix
			w=(a,p,l,g)=>{
				if(l<2)return;
				let m2=l%2;l-=m2;let mid=l/2|0,temp=new Array(mid);
				for(let i=p,j=0;i<p+g*mid;i+=g,j++)this.write(temp,j,a[i],true);
				for(let i=p+g*mid,j=p,k=0;i<p+g*l;i+=g,j+=2*g,k++){
					this.write(a,j,a[i]);
					this.write(a,j+g,temp[k]);
				}
				w(a,p,mid+m2,2*g);
				w(a,p+g,mid,2*g);
			}
			w(a,0,e,1);
		break;
		case 22://Half Rotation
			b=0,m=(e+1)/2|0;
			if(e%2==0)while(m<e)this.swap(a,b++,m++);
			else{
				tmp=a[b];
				while(m<e){
					this.write(a,b++,a[m]);
					this.write(a,m++,a[b]);
				}
				this.write(a,b,tmp);
			}
		break;
		case 23://Half Reversed
			for(let i=0,j=e-1;i<e/4|0;i++,j--)
				this.swap(a,i,j)
		break;
		case 24://Logarithmic Slopes
			for(let i=0;i<e;i++)this.write(tmp,i,a[i],true);
			for(let i=1;i<e;i++){
				let lg=log(i)/log(2)|0,pw=pow(2,lg),vl=tmp[2*(i-pw)+1];
				this.write(a,i,vl);
			}
		break;
		case 25://Heapified
			this.heapify(a,0,e,1)
		break;
		case 26://Triangular Heapified
			s=(a,e,r)=>{
				const trt=v=>sqrt((8*v+1)-1)/2|0;
				let t=a[r],ln=trt(r),l=r+ln+1,ri=l+1;
				while(l<e){
					if(ri>=e){
						if(compareValues(a[l],t)>0)this.write(a,r,a[l]);
						break;
					}
					let mx=compareIndices(a,l,ri)>=0?l:ri;
					if(compareValues(a[mx],t)>0){
						this.write(a,r,a[mx]);
						r=mx;ln=trt(r);l=r+ln+1;ri=l+1;
						continue;
					}
					break;
				}
				this.write(a,r,t);
			}
			for(let i=e-1;i>=0;i--)s(a,e,i);
		break;
		case 27://Circle Pass
			this.shuffle(a,0,e);
			n=1;
			for(;n<e;n*=2);
			let csrout=(a,o,i,e)=>{
				if(o==i)return;
				let h=i,l=o,m=(i-o)/2|0;
				while(o<i){
					if(i<e&&compareIndices(a,o,i)>0)this.swap(a,o,i);
					o++;i--;
				}
				csrout(a,l,l+m,e);
				if(l+m+1<e)csrout(a,l+m+1,h,e);
			}
			csrout(a,0,n-1,e);
		break;
		case 28://Final Pairwise Pass
			this.shuffle(a,0,e);
			tmp.fill(0)
			for(let i=1;i<e;i+=2)if(compareIndices(a,i-1,i)>0)this.swap(a,i-1,i);
			for(let m=0;m<2;m++){
				for(let k=m;k<e;k+=2)this.write(tmp,a[k],tmp[a[k]]+1,true);
				i=0,j=m;
				while(1){
					while(i<e&&tmp[i]==0)i++;
					if(i>=e)break;
					this.write(a,j,i);
					j+=2;
					this.write(tmp,i,tmp[i]-1,true);
				}
			}
		break;
		case 29://Recursive Reversal
			r=(ar,a,b)=>{
				if(b-a<2)return;
				this.reversal(ar,a,b-1);
				let m=(a+b)/2|0;
				r(ar,a,m);
				r(ar,m,b);
			}
			r(a,0,e+1);
		break;
		case 30://Gray Code Fractal
			r=(ar,a,b,d)=>{
				if(b-a<3)return;
				let m=(a+b)/2|0;
				if(d)this.reversal(ar,a,m-1);
				else this.reversal(ar,m,b-1);
				r(ar,a,m,0);
				r(ar,m,b,1);
			}
			r(a,0,e+1,0);
		break;
		case 31://Sierpinski Triangle
			t=(tm,a,b)=>{
				if(b-a<2)return;
				if(b-a==2)return tm[a+1]++;
				let h=(b-a)/3|0,t1=(a+a+b)/3|0,t2=(a+b+b+2)/3|0;
				for(let i=a;i<t1;i++)tm[i]+=h;
				for(let i=t1;i<t2;i++)tm[i]+=2*h;
				t(tm,a,t1);
				t(tm,t1,t2);
				t(tm,t2,b);
			}
			t(tmp.fill(0),0,e);
			aux=[...a];
			for(let i=0;i<e;i++)this.write(a,i,aux[tmp[i]]);
		break;
		case 32://Triangular
			tmp.fill(0);
			j=0,k=2;max=0;
			for(let i=1;i<e;i++,j++){
				if(i==k){
					j=0;k*=2;
				}
				tmp[i]=tmp[j]+1;
				if(tmp[i]>max)max=tmp[i];
			}
			counts=new Array(max+1).fill(0);			
			for(let i=0;i<e;i++)counts[tmp[i]]++;
			for(let i=1;i<counts.length;i++)counts[i]+=counts[i-1];
			for(let i=e-1;i>=0;i--)tmp[i]=--counts[tmp[i]];
			aux=[...a];
			for(let i=0;i<e;i++)this.write(a,i,aux[tmp[i]]);
		break;
		case 33://QuickSort Adversary
			for(let j=e-e%2-2,i=j-1;i>=0;i-=2,j--)this.swap(a,i,j);
		break;
		case 34://Grailsort Adversary
			rot=(ar,a,m,b)=>{
				this.reversal(ar,a,m-1);
				this.reversal(ar,m,b-1);
				this.reversal(ar,a,b-1);
			}
			p=(ar,a,b,bL)=>{
				let len=b-a,b1=b-len%bL,len1=b1-a,m=bL;
				if(len1<=2*bL)return;
				while(2*m<len)m*=2;
				m+=a;
				if(b1-m<bL)p(ar,a,m,bL);
				else{
					m=a+b1-m;
					rot(ar,m-(bL-2),b1-(bL-1),b1);
					this.multiSwap(ar,a,m);
					rot(ar,a,m,b1);
					m=a+b1-m;
					p(ar,a,m,bL);
					p(ar,m,b,bL);
				}
			}
			if(e<17)this.reversal(a,0,e-1);
			else{
				b=1;
				while(b*b<e)b*=2;
				n=(e-1)/b+1|0;k=b+n;
				this.shuffle(a,0,e);
				this.sort(a,0,k);
				this.reversal(a,0,k);
				this.sort(a,k,e);
				p(a,k,e,b);
			}
		break;
		case 35://Modulo
			for(let i=1;i<e;i++)if((i*2)%e!=i)this.swap(a,i,(i*2)%e);
		break;
		case 36://Quadratic
			y=x=>-(x**2)/(e/2|0)|0;
			for(k=0,i=-(e/2|0);i<e/2|0;i++,k++)this.write(a,k,(y(i)+e/2|0)*2)
			this.shuffle(a,0,e)
		break;
		case 37://Cubic
			y=x=>(1/(e/2)**2)*x**3|0;
			for(k=0,i=-(e/2|0);i<e/2|0;i++,k++)this.write(a,k,y(i)+e/2|0+1)
			this.shuffle(a,0,e)
		break;
		case 38://Bit Reversal
			len=1<<(log(e)/log(2)|0);
			p=len==e;tmp=[...a];
			for(let i=0;i<len;i++)a[i]=i;
			m=0;d=len>>1,b=d+(d>>1);			
			for(let i=1;i<len-1;i++){
				let j=d;
				for(let k=i,n=b;(k&1)==0;j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)this.swap(a,i,m);
			}
			if(!p){
				for(let i=len;i<e;i++)this.write(a,i,a[i-len]);
				aux=new Array(len).fill(0);
				for(let i=0;i<e;i++)aux[a[i]]++;
				for(let i=1;i<aux.length;i++)aux[i]+=aux[i-1];
				for(let i=e-1;i>=0;i--)this.write(a,i,--aux[a[i]]);
			}
			x=[...a];
			for(let i=0;i<e;i++)this.write(a,i,tmp[x[i]]);
		break;
		case 39://Random Blocks
			s=(ar,a,b,l)=>{
				for(let i=0;i<l;i++)this.swap(ar,(a+i)%e,(b+i)%e);
			}
			p=v=>{
				let l;
				for(l=1;l<<1<=v;l<<=1);
				return l;
			}
			c=e;b=p(sqrt(c)|0);c-=c%b;
			for(let i=0;i<c;i+=b)s(a,i,random()*((c-i)/b|0)*b+i,b);
		break;
		case 40://Block Reverse
			s=(ar,a,b,l)=>{
				for(let i=0;i<l;i++)this.swap(ar,(a+i)%e,(b+i)%e);
			}
			p=v=>{
				let l;
				for(l=1;l<<1<=v;l<<=1);
				return l;
			}
			c=e;b=p(sqrt(c)|0);c-=c%b;
			i=0,j=c-b;
			while(i<j){
				s(a,i,j,b);
				i+=b;j-=b;
			}
		break;
		case 41://Sine Wave
			n=e-1;c=2*PI/n
			for(let i=0;i<e;i++)this.write(a,i,maxVal(n*(sin(c*i)+1)/2|0,1));
			this.shuffle(a,0,e)
		break;
		case 42://Partial Merge
			this.shuffle(a,0,e)
			tmp=tmp.fill(2).map((e,i)=>e**++i)
			while(tmp.pop()>e/2);
			g=tmp[random()*tmp.length|0];i=0
			for(;i+g<e;i+=g)this.sort(a,i,i+g)
			if(i<e)this.sort(a,i,e)
		break;
		case 43://many similar
			c=e/16|0;aux=[];
			for(let i=1;i<=16;i++)
				for(let j=0;j<c;j++)
					aux.push(c*i)
			this.shuffle(aux,0,e,true);
			this.arraycopy(aux,0,a,0,e)
		break;
		case 44://perlin noise
			aux=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151];
			f=t=>t*t*t*(t*(t*6-15)+10);
			g=(h,x)=>(h&1)==0?x:-x;
			l=(t,a,b)=>a+t*(b-a);
			r=x=>{
				let i=(x|0)&255;x-=x|0;
				let u=f(x);
				return l(u,g(aux[i],x),g(aux[i+1],x-1))*2;
			}
			n=(x,oc)=>{
				let a=.0,b=.5;
				for(let i=0;i<oc;i++){
					a+=b*r(x);x*=2;b*=.5;
				}
				return a;
			}
			y=1/e;k=random()*e|0;o=log(e)/log(2)|0;
			for(let i=0;i<e;i++){
				let v=n(k,o)*e;
				tmp[i]=v;k+=y;
			}
			m=2**31-1;for(let i=0;i<e;i++)if(tmp[i]<m)m=tmp[i];
			m=abs(m);for(let i=0;i<e;i++)tmp[i]+=m;
			m=-1/0;for(let i=0;i<e;i++)if(tmp[i]>m)m=tmp[i];
			s=e/m;
			if(s<1||s>1.8)for(let i=0;i<e;i++)tmp[i]=tmp[i]*s|0;
			for(let i=0;i<e;i++)this.write(a,i,minVal(maxVal(tmp[i],1),e-1));
		break;
		case 45://bell curve
			s=8/e;p=-4;f=e/512;
			for(let i=0;i<e;i++){
				u=1264*f*pow(Math.E,-(p**2)/2);
				d=sqrt(2*PI);
				this.write(a,i,1+u/sqrt(2*PI)|0);
				p+=s;
			}
		break;
		case 46://ruler
			s=maxVal(1,e/256);
			f=log(e/s)/log(2)|0;
			for(l=s;2*l<=e/4|0;l*=2);
			aux=new Array(f+2);
			for(i=0;i+s<=e;i+=s){
				for(j=0;aux[j];j++);aux[j]=true;
				for(let k=0;k<s;k++)this.write(a,i+k,e/2-minVal((1<<j)*s,l)|0);
				for(let k=0;k<j;k++)aux[k]=false;
			}
			for(j=0;aux[j];j++);aux[j]=true;
			while(i<e)this.write(a,i++,maxVal(e/2-(1<<j)*s,e/4)|0);
		break;
		case 47://blancmange curve
			s=(n,x)=>{
				let m=0;
				while(n>=0)m+=c(n--,x);
				return m;
			}
			c=(n,x)=>t((1<<n)*x)/(1<<n);
			t=x=>abs(x-(x+.5|0));
			f=log(e)/log(2)|0;
			for(let i=0;i<e;i++)this.write(a,i,e*s(f,i/e));
		break;
		case 48://cantor function
			c=(r,a,b,n,x)=>{
				if(b-a<1||n==x)return;
				let m=(n+x)/2|0;
				if(b-a==1)return this.write(r,a,m);
				let p=(a+a+b)/3|0,q=(a+b+b+2)/3|0;
				for(let i=p;i<q;i++)this.write(r,i,m);
				c(r,a,p,n,m);c(r,q,b,m+1,x);
			}
			c(a,0,e,0,e-1)
			this.reversal(a,0,e)
		break;
		case 49://sum of divisors
			tmp[0]=0;tmp[1]=1;x=1;
			s=n=>{
				let u=n+1;
				for(let i=2;i<=sqrt(n)|0;i++)if(n%i==0)u+=(i==n/i)?i:i+n/i|0;
				return u;
			}
			for(i=2;i<e;i++){
				tmp[i]=s(i);
				if(tmp[i]>x)x=tmp[i];
			}
			c=minVal((e-1)/x,1);
			for(i=0;i<e;i++)this.write(a,i,tmp[i]*c|0);
		break;
		case 50://FSD
			g=(a,b)=>b?g(b,a%b):a
			x=tmp[0]=tmp[1]=1;
			for(i=2;i<e;i++){
				r=g(tmp[i-1],i);
				tmp[i]=tmp[i-1]/r+(r==1?i+1:0);
				if(tmp[i]>x)x=tmp[i];
			}
			c=minVal((e-1)/x,1);
			for(i=0;i<e;i++)this.write(a,i,tmp[i]*c|0);
		break;
		case 51://Decreasing Random
			for(i=0;i<e;i++)this.write(a,i,random()*(e-i)+i|0);
		break;
		case 52://Euler's Totient Function
			tmp.fill(0);p=[];a[0]=0;a[1]=1;
			for(i=2;i<e;i++){
				if(tmp[i]==0){
					p.push(i);
					tmp[i]=i;
					this.write(a,i,i-1);
				}
				for(j=0;j<p.length;j++){
					r=p[j]
					if(i*r>=e)break;
					l=r==tmp[i];
					tmp[i*r]=r;
					this.write(a,i*r,a[i]*(l?r:r-1));
					if(l)break;
				}
			}
		break;
		}
	}
	sort(a,s,e){
		let min=a[s],max=min;
		for(let i=s+1;i<e;i++)
			if(a[i]<min)min=a[i];
			else if(a[i]>max)max=a[i];
		let size=max-min+1,holes=new Array(size).fill(0);
		for(let i=s;i<e;i++)holes[a[i]-min]++
		for(let i=0,j=s;i<size;i++)while(holes[i]-->0)this.write(a,j++,i+min);
	}
	shuffle(a,s,e,x){
		for(let i=s;i<e;i++)this.swap(a,i,random()*(e-i)+i,x);
	}
	start(a,t){
		this.shuffles([...a],0,a.length,t);
		return this.steps;
	}
}
let shuf=new Shuffles()
function display(a){
	ctx.clearRect(0,0,cvs.width,cvs.height)
	ctx.fillStyle="#fff";
	for(let i=0;i<len;i++)ctx.fillRect(i*bw,count-a[i],bw,dtype.checked?a[i]:bw)
}
function mark(i,after){
	if(fps.g()>=30&&markarray.checked){
		ctx.fillStyle="#f00";
		ctx.fillRect(i*bw,count-arr[i],bw,dtype.checked?arr[i]:bw)
	}
	if(after)ctx.fillStyle=after;
}
function format(e){
	if(typeof e!="object"&&parseFloat(e)+""!=="NaN")return parseFloat(e);
	else return e
}
function sound(fr){
	if(!playsound||!audio.checked)return;
	playsound=0;setTimeout(()=>playsound=audio.checked);
	try{
		if(!aud)aud=new AudioContext();
		let o=aud.createOscillator()
		let f=250+minVal(fr/maxVal(arr),20)*850
		o.frequency.value=f
		o.start();
		o.stop(aud.currentTime+.1)
		let n=aud.createGain()
		n.gain.value=.1
		n.gain.linearRampToValueAtTime(0,aud.currentTime+.1)
		o.connect(n)
		n.connect(aud.destination)
	}catch(e){}
}
const joinSymbol="@";
function rdisp(args){
	if(args.length==3){var[interval,m,onfinish]=args,refresh=24
	}else if(args.length==4){var[interval,m,refresh,onfinish]=args}else return;
	let elapsed=Date.now(),updts=0,avrge=0,ticks=0,frames=0,clen=logs.length,tr=maxVal(len*.001,clen/(15000/interval)),tmp=[...arr],orlen=clen
	if(interval<0){tr=len*abs(interval)|0;interval=10}
	logs.forEach(e=>{
		let c=e.map(format)
		switch(c[0]){
			case"swap":swap(tmp,c[1],c[2],true);break;
			case"set":write(tmp,c[1],c[2],true);break;
			case"msw":multiSwap(tmp,c[1],c[2],true);break;
			case"rev":reversal(tmp,c[1],c[2],true);break;
			case"insert":insertTo(tmp,c[1],c[2],true);break;
			case"custom":eval(atob(c[1]))(tmp,...c.splice(2,1/0));break;
		}
	})
	tr=parseFloat(tr.toFixed(2));
	if(tr+.5<5&&tr>1)tr=1
	if(!fixedrate.checked)rate.value=tr
	atr=parseFloat(rate.value)
	let sed=isSorted(tmp.splice(0,1/0));
	finalresult.innerText=sed;finalresult.style.color=sed?"#fff":"#f00";
	swaps=0;writes=0;dcd=true;curDur=Date.now();
	markarray.checked=1;
	let itts=0;playsound=audio.checked;
	let n=setInterval(()=>{
		if(pause.checked)return;
		if(Date.now()-elapsed>1e3/refresh){
			elapsed=Date.now()
			display(arr)
			perms=0
			framecount.innerText=(orlen-clen).toLocaleString()+"/ "+orlen.toLocaleString();
			framerate.innerText=frames+"/s"
			if(ticks++%5==0)estimated.innerText=(avrge/updts-3.5).toFixed(1)+"s";
		}
		let rte=0;itts++
		if(atr<0)atr=0
		if(rate.value<0)rte=itts%(abs(rate.value)+1);
		for(;rte<=atr;rte++){
			updts++;frames++
			setTimeout(()=>frames--,1e3)
			avrge+=orlen/frames
			if(clen--&&!didskip){
				let c=logs.shift().map(format)
				switch(c[0]){
					case"swap":swap(arr,c[1],c[2],true);mark(c[1]);mark(c[2]);break;
					case"set":write(arr,c[1],c[2],true);mark(c[1]);break;
					case"msw":multiSwap(arr,c[1],c[2],true);break;
					case"rev":reversal(arr,c[1],c[2],true);break;
					case"insert":insertTo(arr,c[1],c[2],true);break;
					case"custom":eval(atob(c[1]))(arr,...c.splice(2,1/0));break;
				}
			}else{
				clearArr(logs)
				clearInterval(n)
				onfinish()
				dcd=false
				setTimeout(()=>{
					finalresult.innerText=framecount.innerText=framerate.innerText="...";
				},5)
				break;
			}
		}
	},interval)
	let ratio=(orlen/count);
	if(ratio>=75)console.log(names.innerText,ratio.toFixed(2))
	if(!sed)console.log(names.innerText,sed)
}
function create(c){
	return Array(c).fill().map((e,i)=>++i)
}
function rotateText(t){
	let aux=t.split("");
	t=aux.splice(-1).concat(aux).join("")
	return t
}
/*Sauces: 
*https://github.com/Gaming32/ArrayV/blob/main/src/main/java/io/github/arrayv/sorts/
*https://github.com/Gaming32/ArrayV-Extra-Sorts/blob/main/src/main/java/io/github/arrayv/sorts/
*https://github.com/Gaming32/ArrayV/tree/main/src/main/java/io/github/arrayv/utils
*https://github.com/PCBoyGames/ArrayV-v4.0/tree/ad703423641022a396437e2025405916f2435b13/src/sorts
*https://github.com/PCBoyGames/ArrayV-v4.0/tree/ad703423641022a396437e2025405916f2435b13/src/utils
*/
const Rots={
	swapBlocksBackwards:function(ar,a,b,l,aux){
		for(let i=0;i<l;i++)swap(ar,a+l-i-1,b+l-i-1,aux);
	},
	blockSwap:function(ar,a,b,l,aux){
		for(let i=0;i<l;i++)swap(ar,a+i,b+i,aux);
	},
	shiftForwards:function(a,s,l,aux){
		let t=a[s];
		for(let i=0;i<l;i++)write(a,s+i,a[s+i+1],aux);
		write(a,s+l,t,aux);
	},
	shiftBackwards:function(a,s,l,aux){
		let t=a[s+l];
		for(let i=l;i>0;i--)write(a,s+i,a[s+i-1],aux);
		write(a,s,t,aux);
	},
	mapIndex:function(i,n,l){return(i-n+l)%l|0;},
	swap:function(ar,a,v,aux){
		let old=ar[a];
		write(ar,a,v,aux);
		return old;
	},
	griesMills:function(a,p,A,B,aux){
		while(A!=0&&B!=0){
			if(A<=B){
				this.blockSwap(a,p,p+A,A,aux);
				p+=A;B-=A;
			}else{
				this.blockSwap(a,p+(A-B),p+A,B,aux);
				A-=B;
			}
		}
	},
	threeReversal:function(a,p,A,B,aux=0){
		reversal(a,p,p+A-1,aux);
		reversal(a,p+A,p+A+B-1,aux);
		reversal(a,p,p+A+B-1,aux);
	},
	holyGriesMills:function(a,p,A,B,aux=0){
		while(A>1&&B>1){
			while(A<=B){
				this.blockSwap(a,p,p+A,A,aux);
				p+=A;B-=A;
			}
			if(A<=1||B<=1)break;
			while(A>B){
				this.swapBlocksBackwards(a,p+A-B,p+A,B,aux);
				A-=B;
			}
		}
		if(A==1)this.shiftForwards(a,p,B,aux);
		else if(B==1)this.shiftBackwards(a,p,A,aux);
	},
	helium:function(a,p,A,B,aux=0){
		while(B>1&&A>1)
			if(B<A){
				this.blockSwap(a,p,p+A,B,aux);
				p+=B;A-=B;
			}else{
				this.swapBlocksBackwards(a,p,p+B,A,aux);
				B-=A;
			}
		if(B==1)this.shiftBackwards(a,p,A,aux);
		else if(A==1)this.shiftForwards(a,p,B,aux);
	},
	cycleReverse:function(ar,p,A,B,aux){
		if(A<1||B<1)return;
		let a=p,b=p+A-1,c=p+A,d=p+A+B-1,s;
		while(a<b&&c<d){
			s=ar[b];
			write(ar,b--,ar[a],aux);
			write(ar,a++,ar[c],aux);
			write(ar,c++,ar[d],aux);
			write(ar,d--,s,aux);
		}
		while(a<b){
			s=ar[b];
			write(ar,b--,ar[a],aux);
			write(ar,a++,ar[d],aux);
			write(ar,d--,s,aux);
		}
		while(c<d){
			s=ar[c];
			write(ar,c++,ar[d],aux);
			write(ar,d--,ar[a],aux);
			write(ar,a++,s,aux);
		}
		if(a<d){
			if(d-a>2)reversal(ar,a,d,aux);
			else swap(ar,a,d,aux);
		}
	},
	juggling:function(a,p,A,B,aux=0){
		let l=A+B;A%=l;
		if(A==0)return;
		for(let c=0,i=0,v=a[p+i],s=i;c<l;c++){
			let n=this.mapIndex(i,A,l);
			v=this.swap(a,p+n,v,aux);
			if(n==s){
				s=i=this.mapIndex(i,1,l);
				v=a[p+i];
			}else i=n;
		}
	},
	bridge:function(a,p,l,b,aux=0){
		if(l<1||b<1)return;
		let pta=p,ptb=p+l,ptc=p+b,ptd=ptb+b;
		if(l<b){
			let bridge=b-l;
			if(bridge<l){
				let loop=l;
				let sw=new Array(bridge);
				arraycopy(a,ptb,sw,0,bridge,true);
				while(loop-->0){
					write(a,--ptc,a[--ptd],aux);
					write(a,ptd,a[--ptb],aux);
				}
				arraycopy(sw,0,a,pta,bridge,aux);
			}else{
				let sw=new Array(l);
				arraycopy(a,pta,sw,0,l,true);
				arraycopy(a,ptb,a,pta,b,aux);
				arraycopy(sw,0,a,ptc,l,aux);
			}
		}else if(b<l){
			let bridge=l-b;
			if(bridge<b){
				let loop=b;
				let sw=new Array(bridge);
				arraycopy(a,ptc,sw,0,bridge,true);
				while(loop-->0){
					write(a,ptc++,a[pta],aux);
					write(a,pta++,a[ptb++],aux);
				}
				arraycopy(sw,0,a,ptd-bridge,bridge,aux);
			}else{
				let sw=new Array(b);
				arraycopy(a,ptb,sw,0,b,true);
				while(l-->0)write(a,--ptd,a[--ptb],aux);
				arraycopy(sw,0,a,pta,b,aux);
			}
		}else while(f-->0)swap(a,pta++,ptb++,aux);
	},
	neon:function(a,p,A,B,aux=0){
		let end=p+A+B;
		while(A>0&&B>0){
			if(A<B){
				for(let i=0;i<A;i++){
					let t=a[p+i],j=p+i+A;
					for(;j<end;j+=A)write(a,j-A,a[j],aux);
					write(a,j-A,t,aux);
				}
				p+=B;B%=A;A-=B;
			}else{
				for(let i=0;i<B;i++){
					let t=a[p+i+A],j=p+i+A-B;
					for(;j>=p;j-=B)write(a,j+B,a[j],aux);
					write(a,j+B,t,aux);
				}
				end=p+B;A%=B;B-=A;
			}
		}
	},
	foolish:function(a,p,A,B,aux=0){
		if(A<B)for(let i=0;i<A;i++)insertTo(a,p,p+A+B-1,aux);
		else for(let i=0;i<B;i++)insertTo(a,p+A+B-1,p,aux);
	},
	morefoolish:function(a,p,A,B,aux=0){
		if(A>B)for(let i=0;i<A;i++)insertTo(a,p,p+A+B-1,aux);
		else for(let i=0;i<B;i++)insertTo(a,p+A+B-1,p,aux);
	},
	radon:function(a,p,A,B,aux=0){
		let min=minVal(A,B),max=maxVal(A,B),bridge=max-min;
		if(min<1)return;
		if(bridge<=min)reversal(a,p+min,p+max-1,aux);
		for(let i=0;i<min;i++)swap(a,p+i,p+max+i,aux);
		if(bridge==0)return;
		if(A>B){
			if(bridge>min)this.cycleReverse(a,p+min,bridge,min,aux);
			else{
				let sw,a1=p+min,b=p+max,c=b+min-1;
				while(b<c){
					sw=a[c];
					swap(a,c--,a[a1],aux);
					swap(a,a1++,a[b],aux);
					swap(a,b++,sw,aux);
				}
				reversal(a,a1,c,aux);
			}
		}else{
			if(bridge>min)this.cycleReverse(a,p,min,bridge,aux);
			else{
				let sw,a1=p,b=a+min-1,c=a+max-1;
				while(a<b){
					sw=a[a1];
					swap(a,a1++,a[c],aux);
					swap(a,c--,a[b],aux);
					swap(a,b--,sw,aux);
				}
				reversal(a,a1,c,aux);
			}
		}
	},
	centered:function(a,p,A,B,aux=0){
		if(A<1||B<1)return;
		if(A<B){
			let h=(B-A)/2|0;
			this.blockSwap(a,p,p+A+h,A,aux);
			this.centered(a,p+A+h,A,B-A-h,aux);
			this.centered(a,p,A,h,aux);
		}else if(A==B)this.blockSwap(a,p,p+A,A,aux);
		else{
			let h=(A-B)/2|0;
			this.blockSwap(a,p+h,p+A,B,aux);
			this.centered(a,p,h,B,aux);
			this.centered(a,p+h+B,A-B-h,B,aux);
		}
	},
	adaptable:function(a,p,A,B,aux=0){
		if(A==0||B==0)return;
		if(A%B==0||B%A==0)this.holyGriesMills(a,p,A,B,aux);
		else this.cycleReverse(a,p,A,B,aux);
	}
}
const IndexRots={
	griesMills:function(a,s,m,e,x){Rots.griesMills(a,s,m-s,e-m,x)},
	threeReversal:function(a,s,m,e,x){Rots.threeReversal(a,s,m-s,e-m,x)},
	juggling:function(a,s,m,e,x){Rots.juggling(a,s,m-s,e-m,x)},
	holyGriesMills:function(a,s,m,e,x){Rots.holyGriesMills(a,s,m-s,e-m,x)},
	helium:function(a,s,m,e,x){Rots.helium(a,s,m-s,e-m,x)},
	cycleReverse:function(a,s,m,e,x){Rots.cycleReverse(a,s,m-s,e-m,x)},
	bridge:function(a,s,m,e,x){Rots.bridge(a,s,m-s,e-m,x)},
	neon:function(a,s,m,e,x){Rots.neon(a,s,m-s,e-m,x)},
	foolish:function(a,s,m,e,x){Rots.foolish(a,s,m-s,e-m,x)},
	morefoolish:function(a,s,m,e,x){Rots.morefoolish(a,s,m-s,e-m,x)},
	radon:function(a,s,m,e,x){Rots.radon(a,s,m-s,e-m,x)},
	centered:function(a,s,m,e,x){Rots.centered(a,s,m-s,e-m,x)},
	adaptable:function(a,s,m,e,x){Rots.adaptable(a,s,m-s,e-m,x)}
}
function analyzeBit(a,l){
	let m=0;
	for(let i=0;i<l;i++){
		let v=a[i];
		if(v>m)m=v;
	}
	return 31-clz32(m);
}
function getBit(n,k){
	return((n>>k)&1)==1;
}
function getDigit(a,p,r){
	return(a/pow(r,p))%r|0;
}
function minVal(a){
	return typeof a=="object"?Math.min(...a):Math.min(...arguments);
}
function maxVal(a){
	return typeof a=="object"?Math.max(...a):Math.max(...arguments);
}
function maxLog(a,l,b){
	let m=0,i;
	for(i=0;i<l;i++){
		let v=a[i];
		if(v>m)m=v;
	}
	return log(m)/log(b)|0;
}
function compareValues(a,b){
	a|=0;b|=0
	return a==b?0:a>b?1:-1
}
function compareIndices(a,b,c){
	b|=0;c|=0
	return a[b]==a[c]?0:a[b]>a[c]?1:-1
}
function swap(a,f,t,aux){
	f|=0;t|=0;
	let o=a[f];a[f]=a[t];a[t]=o;
	if(aux){
		swaps++;writes+=2
		sound(a[f])
		sound(a[t])
	}else logs.push(["swap",f,t])
}
function customFunc(f,args){
	logs.push(["custom",btoa("("+f+")"),...args])
}
function write(a,t,v,aux){
	a[t|0]=v|0;
	if(aux){
		writes++
		sound(a[t])
	}else logs.push(["set",t|0,v|0])
}
function insertTo(a,p,t,aux=undefined){
	let tp=a[p];
	if(aux===undefined||aux===null){
		logs.push(["insert",p,t])
		aux=true;
	}
	let d=t-p>0?1:-1;
	for(let i=p;d>0?(i<t):(i>t);i+=d)write(a,i,a[i+d],aux);
	if(p!=t)write(a,t,tp,aux);
}
function multiSwap(a,p,t,aux=undefined){
	if(abs(p-t)==1)return swap(a,p,t,aux);
	if(aux===undefined){
		logs.push(["msw",p,t])
		aux=true;
	}
	let d=t-p>0?1:-1;
	for(let i=p;d?(i<t):(i>t);i+=d)swap(a,i,i+d,aux);
}
function transcribe(a,g,s,aux){
	let t=s;
	for(let i=0;i<g.length;i++){
		for(let j=0;j<g[i].length;j++)write(a,t++,g[i][j],aux);
		g[i]=[]
	}
}
function transcribeMSD(a,rgs,s,m,aux){
	let t=s,p=0;
	for(let i=0;i<rgs.length;i++)t+=rgs[i].length;
	for(let i=rgs.length-1;i>=0;i--)for(let j=rgs[i].length-1;j>=0;j--)write(a,t+m-p++-1,rgs[i][j],aux);
}
function fancyTranscribe(a,e,regs){
	let aux=new Array(e),aux2=new Array(e).fill(false),rad=regs.length;
	transcribe(aux,regs,0,true);
	for(let i=0;i<e;i++){
		let reg=i%rad,p=(reg*(e/rad))+(i/rad)|0;
		if(!aux2[p]){
			write(a,p,aux[p]);
			aux2[p]=true;
		}
	}
	for(let i=0;i<e;i++)if(!aux2[i])write(a,i,aux[i]);
}
function reversal(a,s,l,aux=undefined){
	if(l-s<1)return;
	if(aux===undefined){
		logs.push(["rev",s,l,true])
		aux=true
	}
	for(let i=s;i<s+((l-s+1)/2);i++)swap(a,i,s+l-i,aux);
}
function clearArr(a){a.splice(0,1/0)}
function arraycopy(s,sp,d,dp,l,aux){
	let b=s!=d||dp<sp,st=b?0:l-1,e=b?l:-1,dr=b?1:-1;
	for(let i=st;i!=e;i+=dr)write(d,dp+i,s[sp+i],aux);
}
function getMin(a,l){
	let m=1/0;
	for(let i=0;i<l;i++)if(a[i]<m)m=a[i];
	return m;
}
function getMax(a,l){
	let m=-1/0;
	for(let i=0;i<l;i++)if(a[i]>m)m=a[i];
	return m;
}
function getMaxIndex(a,l){
	let i=0,n;
	for(n=0;n<l;++n)if(a[n]>a[i])i=n;
	return i;
}
const circleDepth=.01
//templates
function icsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)for(let s=0;s+g<len;s+=2*g)for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)if(h<len&&compareIndices(a,lw,h)>0)swap(a,lw,h,0,sc++);
	return sc;
}
function rcsr(a,l,h,s){
	if(l==h)return s;
	let hi=h,lo=l,m=(h-l)/2|0;
	for(;l<h;l++,h--)if(h<len&&compareIndices(a,l,h)>0)swap(a,l,h,0,s++);
	s=rcsr(a,lo,lo+m,s);
	if(lo+m+1<len)s=rcsr(a,lo+m+1,hi,s);
	return s;
}
function iclsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)for(let s=0;s+g<len;s+=2*g)for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)if(h<len&&compareIndices(a,lw,h)>0)reversal(a,lw,h,0,sc++);
	return sc;
}
function rclsr(a,lo,hi,s){
	if(lo==hi)return s;
	let h=hi,l=lo,m=(hi-lo)/2|0;
	for(;lo<hi;lo++,hi--)if(hi<len&&compareIndices(a,lo,hi)>0)reversal(a,lo,hi,0,s++);
	s=rclsr(a,l,l+m,s);
	if(l+m+1<len)s=rclsr(a,l+m+1,h,s);
	return s;
}
function ishsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)for(let s=0;s+g<len;s+=2*g)for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)if(h<len&&compareIndices(a,lw,h)>0)insertTo(a,lw,h,undefined,sc++);
	return sc;
}
function rshsr(a,lo,hi,s){
	if(lo==hi)return s;
	let h=hi,l=lo,m=(hi-lo)/2|0;
	for(;lo<hi;lo++,hi--)if(hi<len&&compareIndices(a,lo,hi)>0)insertTo(a,lo,hi,undefined,s++);
	s=rshsr(a,l,l+m,s);
	if(l+m+1<len)s=rshsr(a,l+m+1,h,s);
	return s;
}
function insertSort(a,s,l,x=0){
	for(let i=s;i<l;i++){
		let p=i-1,c=a[i];
		while(p>=s&&compareValues(a[p],c)>0)write(a,p+1,a[p--],x);
		write(a,p+1,c,x);
	}
}
function siftDown(a,r,d,s,m,x=0){
	let cv=m?-1:1;
	while(r<=d/2){
		let l=2*r;
		if(l<d&&compareIndices(a,s+l-1,s+l)==cv)l++;
		if(compareIndices(a,s+r-1,s+l-1)==cv){
			swap(a,s+r-1,s+l-1,x);
			r=l;
		}else break;
	}
}
function heapify(ar,lw,h,m,x=0){
	let le=h-lw;
	for(let i=le/2|0;i>=1;i--)siftDown(ar,i,le,lw,m,x)
}
function heapSort(a,s,l,mx,aux=0){
	heapify(a,s,l,mx,aux);
	for(let i=l-s;i>1;i--){
		swap(a,s,s+i-1,aux);
		siftDown(a,1,i-1,s,mx,aux);
	}
	if(!mx)reversal(a,s,s+l-1,aux);
}
function binDoubleInsert(ar,a,b,aux=0){
	const lbs=(ar,a,b,v)=>{
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	const rbs=(ar,a,b,v)=>{
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function itl(ar,a,b,t){
		while(a>b)write(ar,a,ar[--a],aux);
		write(ar,b,t,aux);
	}
	function itr(ar,a,b,t){
		while(a<b)write(ar,a,ar[++a],aux);
		write(ar,a,t,aux);
	}
	function dbi(ar,a,b){
		if(b-a<2)return;
		let j=a+(b-a-2)/2+1|0,i=a+(b-a-1)/2|0;
		if(j>i&&compareIndices(ar,i,j)>0)swap(ar,i,j,aux);
		i--;j++;
		while(j<b){
			if(compareIndices(ar,i,j)>0){
				let l=ar[j],r=ar[i],m=rbs(ar,i+1,j,l);
				itr(ar,i,m-1,l);
				itl(ar,j,lbs(ar,m,j,r),r);
			}else{
				let l=ar[i],r=ar[j],m=lbs(ar,i+1,j,l);
				itr(ar,i,m-1,l);
				itl(ar,j,rbs(ar,m,j,r),r);
			}
			i--;j++;
		}
	}
	dbi(ar,a,b);
}
function binInsertSort(a,s,e,x=0){
	for(let i=s;i<e;i++){
		let n=a[i],l=s,h=i;
		while(l<h){
			let m=l+(h-l)/2|0;
			if(compareValues(n,a[m])<0)h=m;
			else l=m+1;
		}
		let j=i-1;
		while(j>=l)write(a,j+1,a[j--],x);
		write(a,l,n,x);
	}
}
function mergeSortTemp(ar,l,bin){
	if(l<32&&bin)return binInsertSort(ar,0,l);
	let tmp=new Array(l),end=l,mid=end/2|0;
	const merge=(a,t,s,m,e,b)=>{
		if(s==m)return;
		if(e-s<32&&b)return;
		else if(e-s<64&&b)binInsertSort(a,s,e);
		else{
			merge(a,t,s,(m+s)/2|0,m,b);
			merge(a,t,m,(m+e)/2|0,e,b);
			let l=s,h=m;
			for(let n=0;n<e-s;n++){
				if(l>=m&&h>=e)break;
				if(l<m&&h>=e)write(t,n,a[l++],true);
				else if(l>=m&&h<e)write(t,n,a[h++],true);
				else if(compareIndices(a,l,h)<1)write(t,n,a[l++],true);
				else write(t,n,a[h++],true);
			}
			for(let i=0;i<e-s;i++)write(a,s+i,t[i]);
		}
	}
	merge(ar,tmp,0,mid,end,bin);
}
function cocktailShakerTemp(a,s,e,x){
	for(let i=s;i<(e/2|0)+s;){
		let sw=true;
		for(let j=i;j<e+s-i-1;j++)if(compareIndices(a,j,j+1)>0)sw=swap(a,j,j+1,x);
		for(let j=e+s-i-1;j>i;j--)if(compareIndices(a,j,j-1)<0)sw=swap(a,j,j-1,x);
		if(sw)break;else i++;
	}
}
function combSortTemp(a,l,h,y){
	let s=false,g=l;
	while(g>1||s){
		if(g>1)g=g/h|0;
		s=false;
		for(let i=0;g+i<l;++i){
			if(y&&g<=Math.min(8,l*.0325)){
				g=0;insertSort(a,0,l);
				break;
			}
			if(compareIndices(a,i,i+g)>0)s=!swap(a,i,i+g);
		}
	}
}
//end
//class templates
class TimSorting{
	minGallop=7;stackSize=0;
	static getMinRun(){return 16}
	constructor(ar,l){
		this.a=ar;
		this.len=l;
		let newArray=new Array(l<512?l>>>1:256);
		this.tmp=newArray;
		let stackLen=(l<120?5:l<1542?10:l<119151?19:40);
		this.runBase=new Array(stackLen);
		this.runLen=new Array(stackLen);
	}
	customSort(a,s,l){TimSorting.sort(this,a,s,l);}
	static sort(ts,a,lo,hi){
		let nR=hi-lo;
		if(nR<32)return ts.binarySort(a,lo,hi,lo+ts.countRunAndMakeAscending(a,lo,hi));
		let mR=ts.minRunLength(nR);
		do{
			let rL=ts.countRunAndMakeAscending(a,lo,hi);
			if(rL<mR){
				let f=nR<=mR?nR:mR;
				ts.binarySort(a,lo,lo+f,lo+rL);
				rL=f;
			}
			ts.pushRun(lo,rL);
			ts.mergeCollapse();
			lo+=rL;nR-=rL;
		}while(nR!=0);
		ts.mergeForceCollapse();
	}
	binarySort(a,lo,hi,s){
		if(s==lo)s++;
		for(;s<hi;s++){
			let p=a[s],l=lo,r=s;
			while(l<r){
				let m=(l+r)>>>1;
				if(compareValues(p,a[m])<0)r=m;
				else l=m+1;
			}
			let n=s-l;
			switch(n){
				case 2:write(a,l+2,a[l+1]);
				case 1:write(a,l+1,a[l]);break;
				default:arraycopy(a,l,a,l+1,n);
			}
			write(a,l,p);
		}
	}
	countRunAndMakeAscending(a,lo,hi){
		let rH=lo+1;
		if(rH==hi)return 1;
		if(compareIndices(a,rH++,lo)<0){
			while(rH<hi&&compareIndices(a,rH,rH-1)<0)rH++;
			reversal(a,lo,rH-1,0);
		}else while(rH<hi&&compareIndices(a,rH-1,rH)<1)rH++;
		return rH-lo;
	}
	minRunLength(n){
		let r=0;
		for(;n>=32;r|=(n&1),n>>=1);
		return n+r;
	}
	pushRun(b,l){
		this.runBase[this.stackSize]=b;
		this.runLen[this.stackSize]=l;
		this.stackSize++;
	}
	mergeCollapse(){
		while(this.stackSize>1){
			let n=this.stackSize-2;
			if((n>=1&&this.runLen[n-1]<=this.runLen[n]+this.runLen[n+1])||(n>=2&&this.runLen[n-2]<=this.runLen[n]+this.runLen[n-1])){
				if(this.runLen[n-1]<this.runLen[n+1])n--;
			}else if(this.runLen[n]>this.runLen[n+1])break;
			this.mergeAt(n);
		}
	}
	mergeForceCollapse(){
		while(this.stackSize>1){
			let n=this.stackSize-2;
			if(n>0&&this.runLen[n-1]<this.runLen[n+1])n--;
			this.mergeAt(n);
		}
	}
	mergeAt(i){
		let b1=this.runBase[i],l1=this.runLen[i],b2=this.runBase[i+1],l2=this.runLen[i+1];
		this.runLen[i]=l1+l2;
		if(i==this.stackSize-3){
			this.runBase[i+1]=this.runBase[i+2];
			this.runLen[i+1]=this.runLen[i+2];
		}
		this.stackSize--;
		let k=this.gallopRight(this.a[b2],this.a,b1,l1,0);
		b1+=k;l1-=k;
		if(l1==0)return;
		l2=this.gallopLeft(this.a[b1+l1-1],this.a,b2,l2,l2-1);
		if(l2==0)return;
		if(l1<=l2)this.mergeLo(this,b1,l1,b2,l2);
		else this.mergeHi(this,b1,l1,b2,l2);
	}
	gallopLeft(k,a,b,l,h){
		let lO=0,ofs=1;
		if(compareValues(k,a[b+h])>0){
			let mO=l-h;
			while(ofs<mO&&compareValues(k,a[b+h+ofs])>0){
				lO=ofs;ofs=(ofs*2)+1;
				if(ofs<1)ofs=mO;
			}
			if(ofs>mO)ofs=mO;
			lO+=h;ofs+=h;
		}else{
			let mO=h+1;
			while(ofs<mO&&compareValues(k,a[b+h-ofs])<1){
				lO=ofs;ofs=(ofs*2)+1;
				if(ofs<1)ofs=mO;
			}
			if(ofs>mO)ofs=mO;
			let t=lO;lO=h-ofs;ofs=h-t;
		}
		lO++;
		while(lO<ofs){
			let m=lO+((ofs-lO)>>>1);
			if(compareValues(k,a[b+m])>0)lO=m+1;
			else ofs=m;
		}
		return ofs;
	}
	gallopRight(k,a,b,l,h){
		let ofs=1,lO=0;
		if(compareValues(k,a[b+h])<0){
			let mO=h+1;
			while(ofs<mO&&compareValues(k,a[b+h-ofs])<0){
				lO=ofs;ofs=(ofs*2)+1;
				if(ofs<1)ofs=mO;
			}
			if(ofs>mO)ofs=mO;
			let tmp=lO;lO=h-ofs;ofs=h-tmp;
		}else{
			let mO=l-h;
			while(ofs<mO&&compareValues(a[b+h+ofs],k)<1){
				lO=ofs;ofs=(ofs*2)+1;
				if(ofs<1)ofs=mO;
			}
			if(ofs>mO)ofs=mO;
			lO+=h;ofs+=h;
		}
		lO++;
		while(lO<ofs){
			let m=lO+((ofs-lO)>>>1);
			if(compareValues(k,a[b+m])<0)ofs=m;
			else lO=m+1;
		}
		return ofs;
	}
	mergeLo(ts,b1,l1,b2,l2){
		let a=ts.a,tmp=this.ensureCapacity(l1);
		arraycopy(a,b1,tmp,0,l1,true);
		let c1=0,c2=b2,d=b1;
		write(a,d++,a[c2++]);
		if(--l2==0)return arraycopy(tmp,c1,a,d,l1);
		if(l1==1){
			arraycopy(a,c2,a,d,l2);
			write(a,d+l2,tmp[c1]);
			return;
		}
		let mG=ts.minGallop;
		wh:while(true){
			let o1=0,o2=0;
			do{
				if(compareValues(a[c2],tmp[c1])<0){
					write(a,d++,a[c2++]);
					o2++;o1=0;
					if(--l2==0)break wh;
				}else{
					write(a,d++,tmp[c1++]);
					o1++;o2=0;
					if(--l1==1)break wh;
				}
			}while((o1|o2)<mG);
			do{
				o1=this.gallopRight(a[c2],tmp,c1,l1,0);
				if(o1!=0){
					arraycopy(tmp,c1,a,d,o1);
					d+=o1;c1+=o1;l1-=o1;
					if(l1<=1)break wh;
				}
				write(a,d++,a[c2++]);
				if(--l2==0)break wh;
				o2=this.gallopLeft(tmp[c1],a,c2,l2,0);
				if(o2!=0){
					arraycopy(a,c2,a,d,o2);
					d+=o2;c2+=o2;l2-=o2;
					if(l2==0)break wh;
				}
				write(a,d++,tmp[c1++]);
				if(--l1==1)break wh;
				mG--;
			}while(o1>=7|o2>=7);
			if(mG<0)mG=0;mG+=2;
		}
		ts.minGallop=mG<1?1:mG;
		if(l1==1){
			arraycopy(a,c2,a,d,l2);
			write(a,d+l2,tmp[c1]);
		}else if(l1==0)throw new Error("violates contract!");
		else arraycopy(tmp,c1,a,d,l1);
	}
	mergeHi(ts,b1,l1,b2,l2){
		let a=ts.a,tmp=this.ensureCapacity(l2);
		arraycopy(a,b2,tmp,0,l2,true);
		let c1=b1+l1-1,c2=l2-1,d=b2+l2-1;
		write(a,d--,a[c1--]);
		if(--l1==0)return arraycopy(tmp,0,a,d-(l2-1),l2);
		if(l2==1){
			d-=l1;c1-=l1;
			arraycopy(a,c1+1,a,d+1,l1);
			write(a,d,tmp[c2]);
			return;
		}
		let mG=ts.minGallop;
		wh:while(true){
			let o1=0,o2=0;
			do{
				if(compareValues(tmp[c2],a[c1])<0){
					write(a,d--,a[c1--]);
					o1++;o2=0;
					if(--l1==0)break wh;
				}else{
					write(a,d--,tmp[c2--]);
					o2++;o1=0;
					if(--l2==1)break wh;
				}
			}while((o1|o2)<mG);
			do{
				o1=l1-this.gallopRight(tmp[c2],a,b1,l1,l1-1);
				if(o1!=0){
					d-=o1;c1-=o1;l1-=o1;
					arraycopy(a,c1+1,a,d+1,o1);
					if(l1==0)break wh;
				}
				write(a,d--,tmp[c2--]);
				if(--l2==1)break wh;
				o2=l2-this.gallopLeft(a[c1],tmp,0,l2,l2-1);
				if(o2!=0){
					d-=o2;c2-=o2;l2-=o2;
					arraycopy(tmp,c2+1,a,d+1,o2);
					if(l2<2)break wh;
				}
				write(a,d--,a[c1--]);
				if(--l1==0)break wh;
				mG--;
			}while(o1>=7|o2>=7);
			if(mG<0)mG=0;mG+=2;
		}
		ts.minGallop=mG<1?1:mG;
		if(l2==1){
			d-=l1;c1-=l1;
			arraycopy(a,c1+1,a,d+1,l1);
			write(a,d,tmp[c2]);
		}else if(l2==0)throw new Error("violates contract!");
		else arraycopy(tmp,0,a,d-(l2-1),l2);
	}
	ensureCapacity(m){
		if(this.tmp.length<m){
			let n=m;
			for(let i=0;i<5;i++)n|=n>>(2**i)
			if(++n<0)n=m;
			else n=minVal(n,this.len>>>1);
			this.tmp=new Array(n);;
		}
		return this.tmp;
	}
}
class QdSB{
	swapTwo(a,s){
		if(compareIndices(a,s,s+1)>0)swap(a,s,s+1);
	}
	swapThree(a,s){
		if(compareIndices(a,s,s+1)>0){
			if(compareIndices(a,s,s+2)<1)swap(a,s,s+1);
			else if(compareIndices(a,s+1,s+2)>0)swap(a,s,s+2);
			else{
				let t=a[s];
				write(a,s,a[s+1]);
				write(a,s+1,a[s+2]);
				write(a,s+2,t);
			}
		}else if(compareIndices(a,s+1,s+2)>0){
			if(compareIndices(a,s,s+2)>0){
				let t=a[s+2];
				write(a,s+2,a[s+1]);
				write(a,s+1,a[s]);
				write(a,s,t);
			}else swap(a,s+2,s+1);
		}
	}
	swapFour(a,s){
		if(compareIndices(a,s,s+1)>0)swap(a,s,s+1);
		if(compareIndices(a,s+2,s+3)>0)swap(a,s+2,s+3);
		if(compareIndices(a,s+1,s+2)>0){
			if(compareIndices(a,s,s+2)<1){
				if(compareIndices(a,s+1,s+3)<1)swap(a,s+1,s+2);
				else{
					let t=a[s+1];
					write(a,s+1,a[s+2]);
					write(a,s+2,a[s+3]);
					write(a,s+3,t);
				}
			}else if(compareIndices(a,s,s+3)>0){
				swap(a,s+1,s+3);
				swap(a,s,s+2);
			}else if(compareIndices(a,s+1,s+3)<1){
				let t=a[s+1];
				write(a,s+1,a[s]);
				write(a,s,a[s+2]);
				write(a,s+2,t);
			}else{
				let t=a[s+1];
				write(a,s+1,a[s]);
				write(a,s,a[s+2]);
				write(a,s+2,a[s+3]);
				write(a,s+3,t);
			}
		}
	}
	swapFive(a,s){
		this.end=s+4;this.pta=this.end++;this.ptt=this.pta--;
		if(compareIndices(a,this.pta,this.ptt)>0){
			this.key=a[this.ptt];
			write(a,this.ptt--,a[this.pta--]);
			if(this.pta>s&&compareValues(a[this.pta-1],this.key)>0){
				write(a,this.ptt--,a[this.pta--]);
				write(a,this.ptt--,a[this.pta--]);
			}
			if(this.pta>=s&&compareValues(a[this.pta],this.key)>0)write(a,this.ptt--,a[this.pta--]);
			a[this.ptt]=this.key;
		}
	}
	tailSwapEight(a,s){
		this.pta=this.end++;this.ptt=this.pta--;
		if(compareIndices(a,this.pta,this.ptt)>0){
			this.key=a[this.ptt];
			write(a,this.ptt--,a[this.pta--]);
			if(compareValues(a[this.pta-2],this.key)>0)for(let i=0;i<3;i++)write(a,this.ptt--,a[this.pta--]);
			if(this.pta>s&&compareValues(a[this.pta-1],this.key)>0){
				write(a,this.ptt--,a[this.pta--]);
				write(a,this.ptt--,a[this.pta--]);
			}
			if(this.pta>=s&&compareValues(a[this.pta],this.key)>0)write(a,this.ptt--,a[this.pta--]);
			a[this.ptt]=this.key;
		}
	}
	swapSix(a,s){
		this.swapFive(a,s);
		this.tailSwapEight(a,s);
	}
	swapSeven(a,s){
		this.swapSix(a,s);
		this.tailSwapEight(a,s);
	}
	swapEight(a,s){
		this.swapSeven(a,s);
		this.tailSwapEight(a,s);
	}
}
class QdS{
	constructor(){
		this.qs=new QdSB();
	}
	tailSwap(ar,s,n){
		let m,top,off;
		switch(n){
		case 0:
		case 1:return;
		case 2:this.qs.swapTwo(ar,s);return;
		case 3:this.qs.swapThree(ar,s);return;
		case 4:this.qs.swapFour(ar,s);return;
		case 5:this.qs.swapFour(ar,s);this.qs.swapFive(ar,s);return;
		case 6:this.qs.swapFour(ar,s);this.qs.swapSix(ar,s);return;
		case 7:this.qs.swapFour(ar,s);this.qs.swapSeven(ar,s);return;
		case 8:this.qs.swapFour(ar,s);this.qs.swapEight(ar,s);return;
		}
		this.qs.swapFour(ar,s);
		this.qs.swapEight(ar,s);
		this.qs.end=s+8;off=8;
		while(off<n){
			top=off++;
			this.qs.pta=this.qs.end++;this.qs.ptt=this.qs.pta--;
			if(compareIndices(ar,this.qs.pta,this.qs.ptt)<1)continue;
			let tm=ar[this.qs.ptt];
			while(top>1){
				m=top/2|0;
				if(compareValues(ar[this.qs.pta-m],tm)>0)this.qs.pta-=m;
				top-=m;
			}
			for(let i=this.qs.ptt;i>this.qs.pta;i--)write(ar,i,ar[i-1]);
			write(ar,this.qs.pta,tm);
		}
	}
	parityMerge4(fr,s,d,xo){
		let ptl,ptr,aP=xo;
		ptl=s;ptr=s+4;
		for(let i=0;i<3;i++)
			if(compareIndices(fr,ptl,ptr)<1)write(d,aP++,fr[ptl++],true);
			else write(d,aP++,fr[ptr++],true);
		if(compareIndices(fr,ptl,ptr)<1)write(d,aP,fr[ptl],true);
		else write(d,aP,fr[ptr],true);
		ptl=s+3;ptr=s+7;aP+=4;
		for(let i=0;i<3;i++)
			if(compareIndices(fr,ptl,ptr)>0)write(d,aP--,fr[ptl--],true);
			else write(d,aP--,fr[ptr--],true);
		if(compareIndices(fr,ptl,ptr)>0)write(d,aP,fr[ptl],true);
		else write(d,aP,fr[ptr],true);
	}
	parityMerge8(fr,s,d){
		let ptl=0,ptr=8,mainP=s;
		for(let i=0;i<7;i++)
			if(compareIndices(fr,ptl,ptr)<1)write(d,mainP++,fr[ptl++]);
			else write(d,mainP++,fr[ptr++]);
		if(compareIndices(fr,ptl,ptr)<1)write(d,mainP,fr[ptl]);
		else write(d,mainP,fr[ptr]);
		ptl=7;ptr=15;mainP+=8;
		for(let i=0;i<7;i++)
			if(compareIndices(fr,ptl,ptr)>0)write(d,mainP--,fr[ptl--]);
			else write(d,mainP--,fr[ptr--]);
		if(compareIndices(fr,ptl,ptr)>0)write(d,mainP,fr[ptl]);
		else write(d,mainP,fr[ptr]);
	}
	parityMerge16(ar,s,x){
		if(compareIndices(ar,s+3,s+4)<1&&compareIndices(ar,s+7,s+8)<1&&compareIndices(ar,s+11,s+12)<1)return;
		this.parityMerge4(ar,s,x,0);
		this.parityMerge4(ar,s+8,x,8);
		this.parityMerge8(x,s,ar);
	}
	partialBackwardMerge(ar,aux,st,n,o){
		let r,m,e,s;m=st+o;e=st+n-1;r=m--;
		if(compareIndices(ar,m,r)<1)return;
		while(compareIndices(ar,m,e)<1)e--;
		for(let i=r;i<r+(e-m);i++)write(aux,i-r,ar[i],true);
		s=e-r;
		write(ar,e--,ar[m--]);
		if(compareValues(ar[st],aux[0])<1){
			do{
				while(compareValues(ar[m],aux[s])>0)write(ar,e--,ar[m--]);
				write(ar,e--,aux[s--]);
			}while(s>=0);
		}else{
			do{
				while(compareValues(ar[m],aux[s])<1)write(ar,e--,aux[s--]);
				write(ar,e--,ar[m--]);
			}while(m>=st);
			do write(ar,e--,aux[s--]);while(s>=0);
		}
	}
	tailMerge(ar,aux,s,n,o){
		let pta,pte=s+n;
		for(;o<n;o*=2){
			for(pta=s;pta+o<pte;pta+=o*2){
				if(pta+o*2<pte){
					this.partialBackwardMerge(ar,aux,pta,o*2,o);
					continue;
				}
				this.partialBackwardMerge(ar,aux,pta,pte-pta,o);
				break;
			}
		}
	}
	forwardMerge(d,fr,s,auxs,o,toAux){
		let l=toAux?s:auxs,r=toAux?(s+o):(auxs+o),m=r,e=r+o,mergeP=toAux?auxs:s;
		if(compareIndices(fr,r-1,e-1)<1){
			fFirst:do{
				for(let i=0;i<3;i++){
					if(compareIndices(fr,l,r)<1){
						write(d,mergeP++,fr[l++],toAux);
						continue fFirst;
					}
					write(d,mergeP++,fr[r++],toAux);
				}
			}while(l<m);
			do write(d,mergeP++,fr[r++],toAux);while(r<e);
		}else{
			rightFirst:do{
				for(let i=0;i<3;i++){
					if(compareIndices(fr,l,r)>0){
						write(d,mergeP++,fr[r++],toAux);
						continue rightFirst;
					}
					write(d,mergeP++,fr[l++],toAux);
				}
			}while(r<e);
			do write(d,mergeP++,fr[l++],toAux);while(l<m);
		}
	}
	quadMergeBlock(ar,s,aux,o){
		let pts,c,cMax=s+o,oX2=o*2;
		if(compareIndices(ar,cMax-1,cMax)<1){
			cMax+=oX2;
			if(compareIndices(ar,cMax-1,cMax)<1){
				cMax-=o;
				if(compareIndices(ar,cMax-1,cMax)<1)return;
				pts=0;c=s;
				do write(aux,pts++,ar[c++],true);while(c<cMax);
				cMax=c+oX2;
				do write(aux,pts++,ar[c++],true);while(c<cMax);
				this.forwardMerge(ar,aux,s,0,oX2,false);
				return;
			}
			pts=0;c=s;cMax=s+oX2;
			do write(aux,pts++,ar[c++],true);while(c<cMax);
		}else this.forwardMerge(aux,ar,s,0,o,true);
		this.forwardMerge(aux,ar,s+oX2,oX2,o,true);
		this.forwardMerge(ar,aux,s,0,oX2,false);
	}
	quadMerge(ar,aux,s,n,o){
		let pta,pte=s+n;
		o*=4;
		for(;o*2<=n;o*=4){
			pta=s;
			do{
				this.quadMergeBlock(ar,pta,aux,o/4|0);
				pta+=o;
			}while(pta+o<=pte);
			this.tailMerge(ar,aux,pta,pte-pta,o/4|0);
		}
		this.tailMerge(ar,aux,s,n,o/4|0);
	}
	quadSwap(ar,s,n){
		let swp=new Array(16),c=n/4|0,rv,pta=s,pts=0,ptt=0,tm=0;
		wp:while(c-->0){
			while(1){
				if(compareIndices(ar,pta,pta+1)>0){
					if(compareIndices(ar,pta+2,pta+3)>0){
						if(compareIndices(ar,pta+1,pta+2)>0){
							pts=pta;pta+=4;
							break;
						}
						swap(ar,pta+2,pta+3);
					}
					swap(ar,pta,pta+1);
				}else if(compareIndices(ar,pta+2,pta+3)>0)swap(ar,pta+2,pta+3);
				if(compareIndices(ar,pta+1,pta+2)>0){
					if(compareIndices(ar,pta,pta+2)<1){
						if(compareIndices(ar,pta+1,pta+3)<1)swap(ar,pta+1,pta+2);
						else{
							tm=ar[pta+1];
							write(ar,pta+1,ar[pta+2]);
							write(ar,pta+2,ar[pta+3]);
							write(ar,pta+3,tm);
						}
					}else if(compareIndices(ar,pta,pta+3)>0){
						swap(ar,pta+1,pta+3);
						swap(ar,pta,pta+2);
					}else if(compareIndices(ar,pta+1,pta+3)<1){
						tm=ar[pta+1];
						write(ar,pta+1,ar[pta]);
						write(ar,pta,ar[pta+2]);
						write(ar,pta+2,tm);
					}else{
						tm=ar[pta+1];
						write(ar,pta+1,ar[pta]);
						write(ar,pta,ar[pta+2]);
						write(ar,pta+2,ar[pta+3]);
						write(ar,pta+3,tm);
					}
				}
				pta+=4;
				continue wp;
			}
			while(1){
				if(c-->0){
					if(compareIndices(ar,pta,pta+1)>0){
						if(compareIndices(ar,pta+2,pta+3)>0){
							if(compareIndices(ar,pta+1,pta+2)>0){
								if(compareIndices(ar,pta-1,pta)>0){
									pta+=4;
									continue;
								}
							}
							swap(ar,pta+2,pta+3);
						}
						swap(ar,pta,pta+1);
					}else if(compareIndices(ar,pta+2,pta+3)>0)swap(ar,pta+2,pta+3);
					if(compareIndices(ar,pta+1,pta+2)>0){
						if(compareIndices(ar,pta,pta+2)<1){
							if(compareIndices(ar,pta+1,pta+3)<1)swap(ar,pta+1,pta+2);
							else{
								tm=ar[pta+1];
								write(ar,pta+1,ar[pta+2]);
								write(ar,pta+2,ar[pta+3]);
								write(ar,pta+3,tm);
							}
						}else if(compareIndices(ar,pta,pta+3)>0){
							swap(ar,pta,pta+2);
							swap(ar,pta+1,pta+3);
						}else if(compareIndices(ar,pta+1,pta+3)<1){
							tm=ar[pta];
							write(ar,pta,ar[pta+2]);
							write(ar,pta+2,ar[pta+1]);
							write(ar,pta+1,tm);
						}else{
							tm=ar[pta];
							write(ar,pta,ar[pta+2]);
							write(ar,pta+2,ar[pta+3]);
							write(ar,pta+3,ar[pta+1]);
							write(ar,pta+1,tm);
						}
					}
					ptt=pta-1;rv=(ptt-pts)/2|0;
					do swap(ar,pts++,ptt--);while(rv-->0);
					pta+=4;
					continue wp;
				}
				if(pts==s){
					switch(n%4){
					case 3:if(compareIndices(ar,pta+1,pta+2)<1)break;
					case 2:if(compareIndices(ar,pta,pta+1)<1)break;
					case 1:if(compareIndices(ar,pta-1,pta)<1)break;
					case 0:
						ptt=pts+n-1;rv=(ptt-pts)/2|0;
						do swap(ar,pts++,ptt--);while(rv-->0);
						return 1;
					}
				}
				ptt=pta-1;rv=(ptt-pts)/2|0;
				do swap(ar,pts++,ptt--);while(rv-->0);
				break wp;
			}
		}
		this.tailSwap(ar,pta,n%4);
		pta=s;c=n/16|0;
		while(c-->0){
			this.parityMerge16(ar,pta,swp);
			pta+=16;
		}
		if(n%16>4)this.tailMerge(ar,swp,pta,n%16,4);
		return 0;
	}
	quadSort(ar,s,l){
		if(l<16)this.tailSwap(ar,s,l);
		else if(l<256){
			if(this.quadSwap(ar,s,l)==0){
				let swp=new Array(128);
				this.tailMerge(ar,swp,s,l,16);
			}
		}else{
			if(this.quadSwap(ar,s,l)==0){
				let swp=new Array(l/2|0);
				this.quadMerge(ar,swp,s,l,16);
			}
		}
	}
	quadSortSwap(ar,swp,s,l){
		if(l<16)this.tailSwap(ar,s,l);
		else if(l<256){
			if(this.quadSwap(ar,s,l)==0)this.tailMerge(ar,swp,s,l,16);
		}else{
			if(this.quadSwap(ar,s,l)==0)this.quadMerge(ar,swp,s,l,16);
		}
	}
}
class MWMS{
	keyLessThan(s,p,a,b){
		let c=compareIndices(s,p[a],p[b]);
		return c<0||(c==0&&compareValues(a,b)<0);
	}
	siftDown(s,h,p,t,r,z){
		while(2*r+2<z){
			let n=2*r+1,m=n+(this.keyLessThan(s,p,h[n],h[n+1])?0:1);
			if(this.keyLessThan(s,p,h[m],t)){
				write(h,r,h[m],true);
				r=m;
			}else break;
		}
		let m=2*r+1;
		if(m<z&&this.keyLessThan(s,p,h[m],t)){
			write(h,r,h[m],true);
			r=m;
		}
		write(h,r,t,true);
	}
	kWayMerge(s,d,h,a,b,z,x){
		for(let i=0;i<z;i++)write(h,i,i,true);
		for(let i=(z-1)/2|0;i>=0;i--)this.siftDown(s,h,a,h[i],i,z);
		for(let i=0;z>0;i++){
			let m=h[0];
			write(d,i,s[a[m]],x);
			write(a,m,a[m]+1,true);
			if(a[m]==b[m])this.siftDown(s,h,a,h[--z],0,z);
			else this.siftDown(s,h,a,h[0],0,z);
		}
	}
}
class BMS{
	shiftFW(a,b,m,c){
		while(m<c)swap(a,b++,m++);
	}
	shiftBW(a,b,m,c){
		while(m>b)swap(a,--c,--m);
	}
	shiftFWExt(a,b,m,c){
		while(m<c)write(a,b++,a[m++]);
	}
	shiftBWExt(a,b,m,c){
		while(m>b)write(a,--c,a[--m]);
	}
	insertTo(a,b,c){
		let t=a[b];
		while(b>c)write(a,b,a[--b]);
		write(a,c,t);
	}
	insertToBW(a,b,c){
		let t=a[b];
		while(b<c)write(a,b,a[++b]);
		write(a,b,t);
	}
	multiSwap(a,b,c,d){
		for(let i=0;i<d;i++)
			swap(a,b+i,c+i);
	}
	rotate(a,b,m,c){
		IndexRots.cycleReverse(a,b,m,c,false);
	}
	fBinSearch(a,b,c,v){
		while(b<c){
			let m=b+(c-b)/2|0;
			if(compareValues(v,a[m])<1)c=m;
			else b=m+1;
		}
		return b;
	}
	rightBinSearch(c,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,c[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	buildRuns(c,a,b){
		let n=true,i=a+1,j=a;
		while(i<b){
			if(compareIndices(c,i-1,i++)==1){
				while(i<b&&compareIndices(c,i-1,i)==1)i++;
				reversal(c,j,i-1);
			}else while(i<b&&compareIndices(c,i-1,i)<1)i++;
			if(i<b){
				n=false;j=i-(i-j-1)%16-1;
			}
			while(i-j<16&&i<b)this.insertTo(c,i,this.rightBinSearch(c,j,i,c[i++]));
			j=i++;
		}
		return n;
	}
	findKeys(c,a,b,nk,n){
		let p=a,pE=a+nk;
		for(let i=pE;i<b&&nk<n;i++){
			let loc=this.fBinSearch(c,p,pE,c[i]);
			if(pE==loc||compareIndices(c,i,loc)!=0){
				this.rotate(c,p,pE,i);
				let inc=i-pE;
				loc+=inc;p+=inc;pE+=inc;nk++;
				this.insertTo(c,pE++,loc);
			}
		}
		this.rotate(c,a,p,pE);
		return nk;
	}
	findKeysBW(c,a,b,nk,n){
		let p=b-nk,pE=b;
		for(let i=p-1;i>=a&&nk<n;i--){
			let loc=this.fBinSearch(c,p,pE,c[i]);
			if(pE==loc||compareValues(c[i],c[loc])!=0){
				this.rotate(c,i+1,p,pE);
				let inc=p-(i+1);
				loc-=inc;pE-=inc;p-=inc+1;nk++;
				this.insertToBW(c,i,loc-1);
			}
		}
		this.rotate(c,p,pE,b);
		return nk;
	}
	binaryInsertion(c,a,b){
		for(let i=a+1;i<b;i++)this.insertTo(c,i,this.rightBinSearch(c,a,i,c[i]));
	}
	boundCheck(c,a,m,b){
		return m>=b||compareIndices(c,m-1,m)<1;
	}
	mergeBW(c,a,m,b,p){
		if(this.boundCheck(c,a,m,b))return;
		let pL=b-m;
		this.multiSwap(c,m,p,pL);
		let i=pL-1,j=m-1,k=b-1;
		while(i>=0&&j>=a)
			if(compareValues(c[p+i],c[j])>=0)swap(c,k--,p+(i--));
			else swap(c,k--,j--);
		while(i>=0)swap(c,k--,p+(i--));
	}
	mergeTo(c,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b)
			if(compareValues(c[i],c[j])<1)swap(c,p++,i++);
			else swap(c,p++,j++);
		while(i<m)swap(c,p++,i++);
		while(j<b)swap(c,p++,j++);
	}
	pingPongMerge(c,a,m1,m2,m3,b,p){
		if(compareValues(c[m1-1],c[m1])>0||(m3<b&&compareIndices(c,m3-1,m3)>0)){
			let p1=p+m2-a,pE=p+b-a;
			this.mergeTo(c,a,m1,m2,p);
			this.mergeTo(c,m2,m3,b,p1);
			this.mergeTo(c,p,p1,pE,a);
		}else this.mergeBW(c,a,m2,b,p);
	}
	mergeFWExt(c,tmp,a,m,b){
		let s=m-a;
		arraycopy(c,a,tmp,0,s,true);
		let i=0,j=m;
		while(i<s&&j<b)
			if(compareValues(tmp[i],c[j])<1)write(c,a++,tmp[i++]);
			else write(c,a++,c[j++]);
		while(i<s)write(c,a++,tmp[i++]);
	}
	mergeBWExt(c,tmp,a,m,b){
		let s=b-m;
		arraycopy(c,m,tmp,0,s,true);
		let i=s-1,j=m-1;
		while(i>=0&&j>=a)
			if(compareValues(tmp[i],c[j])>=0)write(c,--b,tmp[i--]);
			else write(c,--b,c[j--]);
		while(i>=0)write(c,--b,tmp[i--]);
	}
	mergeWithBufFW(c,a,m,b,p){
		let i=m;
		while(a<m&&i<b)
			if(compareIndices(c,a,i)<1)swap(c,p++,a++);
			else swap(c,p++,i++);
		if(a>p)this.shiftFW(c,p,a,m);
		this.shiftFW(c,p,i,b);
	}
	mergeWithBufBW(c,a,m,b,p){
		let i=m-1;b--;
		while(b>=m&&i>=a)
			if(compareIndices(c,b,i)>=0)swap(c,--p,b--);
			else swap(c,--p,i--);
		if(p>b)this.shiftBW(c,m,b+1,p);
		this.shiftBW(c,a,i+1,p);
	}
	mergeWithBufFWExt(c,a,m,b,p){
		let i=m;
		while(a<m&&i<b)
			if(compareIndices(c,a,i)<1)write(c,p++,c[a++]);
			else write(c,p++,c[i++]);
		if(a>p)this.shiftFWExt(c,p,a,m);
		this.shiftFWExt(c,p,i,b);
	}
	mergeWithBufBWExt(c,a,m,b,p){
		let i=m-1;b--;
		while(b>=m&&i>=a)
			if(compareIndices(c,b,i)>=0)write(c,--p,c[b--]);
			else write(c,--p,c[i--]);
		if(p>b)this.shiftBWExt(c,m,b+1,p);
		this.shiftBWExt(c,a,i+1,p);
	}
	inPlaceMerge(c,a,m,b){
		while(a<m&&m<b){
			a=this.rightBinSearch(c,a,m,c[m]);
			if(a==m)return;
			let i=this.fBinSearch(c,m,b,c[a]);
			this.rotate(c,a,m,i);
			let t=i-m;m=i;a+=t+1;
		}
	}
	inPlaceMergeBW(c,a,m,b){
		while(b>m&&m>a){
			let i=this.rightBinSearch(c,a,m,c[b-1]);
			this.rotate(c,i,m,b);
			let t=m-i;
			m=i;b-=t+1;
			if(m==a)break;
			b=this.fBinSearch(c,m,b,c[m-1]);
		}
	}
}
//end
function iterativeBitonicSort(){
	let array=[...arr];
	let i,j,k;
	for(k=2;k<len*2;k=2*k){
		let m=(((len+(k-1))/k)%2)!=0;
		for(j=k>>1;j>0;j=j>>1)
			for(i=0;i<len;i++){
				let ij=i^j;
				if(ij>i&&ij<len){
					if((((i&k)==0)==m)&&compareIndices(array,i,ij)>0)swap(array,i,ij);
					if((((i&k)!=0)==m)&&compareIndices(array,i,ij)<0)swap(array,i,ij);
				}
			}
	}
	return[5,1];
}
function batcherBitonicSort(){
	let array=[...arr];
	const bm=(a,l,n,dir)=>{
		if(n<=1)return;
		let m=1
		while(m<<1<n)m<<=1;
		for(let i=l;i<l+n-m;i++)if(dir==(compareIndices(a,i,i+m)==1))swap(a,i,i+m);
		bm(a,l,m,dir);
		bm(a,l+m,n-m,dir);
	}
	const bs=(a,l,n,d)=>{
		if(n<=1)return;
		let m=n/2;
		bs(a,l,m,!d);
		bs(a,l+m,n-m,d);
		bm(a,l,n,d);
	}
	bs(array,0,len,1)
	return[5,1];
}
function iterativeBoseNelsonSort(){
	let array=[...arr];
	let clen=1<<ceil(log(len)/log(2));
	for(let a=2;a<=clen;a*=2)
		for(let b=0;b<a/2;b++)
			for(let c=0;c+b<len;c+=a){
				let g=c,half=(c+a-g)/2,m=g+half;g+=b;
				for(let d=0;d<half-b;d++)if((d&~b)==d)if(m+d<len&&compareIndices(array,g+d,m+d)==1)swap(array,g+d,m+d);
			}
	return[5,1]
}
function recursiveBoseNelsonSort(){
	let array=[...arr];
	const cs=(a,s,e)=>{
		if(compareIndices(a,s,e)>0)swap(a,s,e);
	}
	const bn=(a,s,l)=>{
		if(l<=1)return;
		let m=l/2|0;
		bn(a,s,m);
		bn(a,s+m,l-m);
		bnm(a,s,m,s+m,l-m);
	}
	const bnm=(a,s1,l1,s2,l2)=>{
		if(l1==1&&l2==1)cs(a,s1,s2);
		else if(l1==1&&l2==2){
			cs(a,s1,s2+1);
			cs(a,s1,s2);
		}else if(l1==2&&l2==1){
			cs(a,s1,s2);
			cs(a,s1+1,s2);
		}else{
			let m1=l1/2|0,m2=(l1%2==1?l2/2:(l2+1)/2)|0;
			bnm(a,s1,m1,s2,m2);
			bnm(a,s1+m1,l1-m1,s2+m2,l2-m2);
			bnm(a,s1+m1,l1-m1,s2,m2);
		}
	}
	bn(array,0,len);
	return[5,1]
}
function creaseSort(){
	let array=[...arr];
	let m=1,nx;
	for(;m*2<len;m*=2,nx=m);
	for(;nx>0;nx/=2,nx|=0){
		for(let i=0;i+1<len;i+=2)if(compareIndices(array,i,i+1)==1)swap(array,i,i+1);
		for(let j=m;j>=nx&&j>1;j/=2)for(let i=1;i+j-1<len;i+=2)if(compareIndices(array,i,i+j-1)>0)swap(array,i,i+j-1);
	}
	return[5,1]
}
function iterativeDiamondSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	let m=4;
	for(;m<=n;m*=2){
		for(let k=0;k<m/2|0;k++){
			let cnt=k<=(m/4|0)?k:m/2-k|0;
			for(let j=0;j<len;j+=m)if(j+cnt+1<len)for(let i=j+cnt;i+1<minVal(len,j+m-cnt);i+=2)if(compareIndices(array,i,i+1)==1)swap(array,i,i+1);
		}
	}
	m/=2;m|=0
	for(let k=0;k<=m/2;k++)for(let i=k;i+1<minVal(len,m-k);i+=2)if(compareIndices(array,i,i+1)==1)swap(array,i,i+1);
	return[5,0]
}
function recursiveDiamondSort(){
	let array=[...arr];
	const sr=(ar,s,e,mm)=>{
		if(e-s==2){
			if(compareIndices(ar,s,e-1)>0)swap(ar,s,e-1);
		}else if(e-s>=3){
			let d=(e-s)/4|0,m=(e-s)/2+s|0;
			if(mm){
				sr(ar,s,m,1);
				sr(ar,m,e,1);
			}
			sr(ar,d+s,d*3+s);
			sr(ar,s,m);
			sr(ar,m,e);
			sr(ar,d+s,d*3+s);
		}
	}
	sr(array,0,len,true);
	return[5,1]
}
function foldSort(){
	let array=[...arr];
	let cL=1;
	for(;1<<cL<len;cL++);
	let sz=1<<cL;
	for(let k=sz>>1;k>0;k>>=1)for(let i=sz;i>=k;i>>=1)for(let j=0;j<len;j+=i)for(let l=j-1,h=j+i;++l<--h;)if(h<len&&compareIndices(array,l,h)>0)swap(array,l,h);
	return[5,1]
}
function batcherMergeExchangeSort(){
	let array=[...arr];
	let t=log(len-1)/log(2)+1|0;
	let p0=1<<(t-1);
	for(let p=p0;p>0;p>>=1){
		let q=p0,r=0,d=p;
		while(1){
			for(let i=0;i<len-d;i++)if((i&p)==r&&compareIndices(array,i,i+d)>0)swap(array,i,i+d);
			if(q==p)break;
			d=q-p;q>>=1;r=p;
		}
	}
	return[5,1]
}
function recursiveOddEvenMergeSort(){
	let array=[...arr];
	const oemc=(a,i,j)=>{
		if(compareIndices(a,i,j)>0)swap(a,i,j);
	}
	const oem=(a,lo,m2,n,r)=>{
		let m=r*2;
		if(m<n){
			if((n/r|0)%2!=0){
				oem(a,lo,(m2+1)/2,n+r,m);
				oem(a,lo+r,m2/2,n-r,m);
			}else{
				oem(a,lo,(m2+1)/2,n,m);
				oem(a,lo+r,m2/2,n,m);
			}
			if(m2%2|0!=0)for(let i=lo;i+r<lo+n;i+=m)oemc(a,i,i+r);
			else for(let i=lo+r;i+r<lo+n;i+=m)oemc(a,i,i+r);
		}else if(n>r)oemc(a,lo,lo+r);
	}
	const oems=(a,lo,n)=>{
		if(n<=1)return;
		let m=n/2|0;
		oems(a,lo,m);
		oems(a,lo+m,n-m);
		oem(a,lo,m,n,1);
	}
	oems(array,0,len);
	return[5,1]
}
function iterativePairwiseMergeSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n<<=1);
	for(let k=n>>1;k>0;k>>=1)for(let j=0;j<len;j+=k<<1)for(let i=0;i<k;i++)if(j+k+i<len&&compareIndices(array,j+i,j+k+i)>0)swap(array,j+i,j+k+i);
	for(let k=2;k<n;k<<=1)for(let m=k>>1;m>0;m>>=1)for(let j=0;j<len;j+=k<<1)for(let p=m;p<((k-m)<<1);p+=m<<1)for(let i=0;i<m;i++)if(j+p+m+i<len&&compareIndices(array,j+p+i,j+p+m+i)>0)swap(array,j+p+i,j+p+m+i);
	return[5,1]
}
function recursivePairwiseMergeSort(){
	let array=[...arr];
	const pm=(ar,a,b)=>{
		let m=(a+b)/2|0,m1=(a+m)/2|0,g=m-m1;
		for(let i=0;m1+i<m;i++)for(let j=m1,k=g;k>0;k>>=1,j-=k-(i&k))if(j+i+k<len&&compareIndices(ar,j+i,j+i+k)>0)swap(ar,j+i+k,j+i);
		if(b-a>4)pm(ar,m,b);
	}
	const pms=(ar,a,b)=>{
		let m=(a+b)/2;
		for(let i=a,j=m;i<m;i++,j++)if(j<len&&compareIndices(ar,i,j)>0)swap(ar,i,j);
		if(b-a>2){
			pms(ar,a,m);
			pms(ar,m,b);
			pm(ar,a,b);
		}
	}
	let n=1;
	for(;n<len;n<<=1);
	pms(array,0,n);
	return[5,1]
}
function iterativeWeaveSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	for(let i=1;i<n;i*=2)for(let j=1;j<=i;j*=2)for(let k=0;k<n;k+=n/j)for(let d=n/i/2,m=0,l=n/j-d;l>=n/j/2;l-=d)for(let p=0;p<d;p++,m++)if(k+l+p<len&&compareIndices(array,k+m,k+l+p)>0)swap(array,k+m,k+l+p);
	return[5,1]
}
function recursiveWeaveSort(){
	let array=[...arr];
	const cr=(ar,p,l,g)=>{
		if(l<2)return;
		for(let i=0;2*i<(l-1)*g;i+=g)if(p+(l-1)*g-i<len&&compareIndices(ar,p+i,p+(l-1)*g-i)>0)swap(ar,p+i,p+(l-1)*g-i);
		cr(ar,p,l/2|0,g);
		if(p+l*g/2<len)cr(ar,p+l*g/2,l/2,g);
	}
	const wc=(ar,p,l,g)=>{
		if(l<2)return;
		wc(ar,p,l/2,2*g);
		wc(ar,p+g,l/2,2*g);
		cr(ar,p,l,g);
	}
	let n=1;
	for(;n<len;n*=2);
	wc(array,0,n,1);
	return[5,1]
}
function LSDRadixSort(){
	let array=[...arr];
	let tb=Number(prompt("base",10))|0,base=(tb>1&&tb<=len)?tb:10,hp=maxLog(array,len,base),vregs=new Array(base);
	for(let i=0;i<base;i++)vregs[i]=[];
	for(let p=0;p<=hp;p++){
		for(let i=0;i<len;i++)vregs[getDigit(array[i],p,base)].push(array[i]);
		fancyTranscribe(array,len,vregs,base*.8|0);
	}
	return[0,1]
}
function MSDRadixSort(){
	let array=[...arr];
	const msd=(a,l,mn,mx,r,p)=>{
		if(mn>=mx||p<0)return;
		let rgs=new Array(r),s=0;
		for(let i=0;i<r;i++)rgs[i]=[];
		for(let i=mn;i<mx;i++)rgs[getDigit(a[i],p,r)].push(a[i]);
		transcribeMSD(a,rgs,0,mn,false);
		for(let i=0;i<rgs.length;i++){
			msd(a,l,s+mn,s+mn+rgs[i].length,r,p-1);
			s+=rgs[i].length;
			rgs[i]=[];
		}
	}
	let hp=maxLog(array,len,4);
	msd(array,len,0,len,4,hp);
	return[5,1]
}
function indexSort(){
	let array=[...arr];
	let min=minVal(array)
	for(let i=0;i<len;i++){
		let c=0;
		while(compareValues(i,array[i]-min)!=0&&c<len)swap(array,i,array[i]-min,0,c++);
		if(c>=len-1)break;
	}
	return[5,1]
}
function bubbleSort(){
	let array=[...arr];
	function cf(ar,i){
		let s=1
		for(let j=0;j<i;j++)
			if(compareIndices(ar,j,j+1)==1){
				swap(ar,j,j+1,true);
				s=0;
			}
		return s;
	}
	for(let i=len-1;i>0;i--){
		customFunc(cf,[i])
		if(cf(array,i))break;
	}
	return[10,1]
}
function circloidSort(){
	let array=[...arr];
	const c=(a,l,r)=>{
		let s=0;
		while(l<r){
			if(compareIndices(a,l,r)==1){
				swap(a,l,r);
				s=1;
			}
			l++;r--;
			if(l==r)r++;
		}
		return s;
	}
	const cp=(a,l,r)=>{
		if(l>=r)return false;
		let m=(l+r)/2|0;
		let lf=cp(a,l,m);
		let rt=cp(a,m+1,r);
		return c(a,l,r)||lf||rt;
	}
	while(cp(array,0,len-1));
	return[5,1]
}
function combSort(){
	let array=[...arr];
	combSortTemp(array,len,1.3);
	return[5,1]
}
function completeGraphSort(){
	let array=[...arr];
	const cs=(ar,a,b)=>{
		if(compareIndices(ar,a,b)>0)swap(ar,a,b);
	}
	const spl=(ar,a,m,b)=>{
		if(b-a<2)return;
		let c=0,len1=(b-a)/2|0,odd=(b-a)%2==1;
		if(odd){
			if(m-a>b-m)c=a++;
			else c=--b;
		}
		for(let s=0;s<len1;s++){
			let i=a;
			for(let j=s;j<len1;j++)cs(ar,i++,m+j);
			for(let j=0;j<s;j++)cs(ar,i++,m+j);
		}
		if(odd){
			if(c<m)for(let j=0;j<len1;j++)cs(ar,c,m+j);
			else for(let j=0;j<len1;j++)cs(ar,a+j,c);
		}
	}
	for(let n=len,d=2,e=1<<((log(n-1)/log(2)|0)+1);d<=e;d*=2)
		for(let i=0,c=0,k;i<n;i=k){
			let j=i;
			for(c+=n;c>=d;c-=d,j++);
			for(k=j,c+=n;c>=d;c-=d,k++);
			spl(array,i,j,k);
		}
	return[5,1]
}
function funSort(){
	let array=[...arr];
	function bs(ar,start,end,value){
		while(start<end){
			let m=(start+end)>>>1;
			if(compareValues(ar[m],value)<0)start=m+1;
			else end=m;
		}
		return start;
	}
	for(let i=1;i<len;i++){
		let done=false;
		do{
			done=true;
			let p=bs(array,0,len-1,array[i]);
			if(compareIndices(array,p,i)!=0){
				if(i<p-1)swap(array,i,p-1);
				else if(i>p)swap(array,i,p);
				done=false;
			}
		}while(!done);
	}
	return[-.05,1]
}
function cocktailShakerSort(){
	let array=[...arr];
	cocktailShakerTemp(array,0,len)
	return[-.05,1]
}
function gnomeSort(){
	let array=[...arr];
	for(let i=1;i<len;){
		if(compareIndices(array,i,i-1)>=0)i++;
		else{
			swap(array,i,i-1);
			if(i>1)i--;
		}
	}
	return[5,1]
}
function LLQuickSort(){
	let array=[...arr];
	function par(ar,lo,hi){
		let pivot=ar[hi],i=lo;
		for(let j=lo;j<hi;j++)if(compareValues(ar[j],pivot)<0)swap(ar,i++,j);
		swap(ar,i,hi);
		return i;
	}	
	function qs(ar,lo,hi){
		if(lo>=hi)return;
		let p=par(ar,lo,hi);
		qs(ar,lo,p-1);
		qs(ar,p+1,hi);
	}
	qs(array,0,len-1)
	return[5,1]
}
function LRQuickSort(){
	let array=[...arr];
	function quickSort(a,p,r){
		let pivot=p+(r-p+1)/2|0,x=a[pivot],i=p,j=r;
		while(i<=j){
			while(compareValues(a[i],x)<0)i++;
			while(compareValues(a[j],x)>0)j--;
			if(i<=j)swap(a,i++,j--);
		}
		if(p<j)quickSort(a,p,j);
		if(i<r)quickSort(a,i,r);
	}
	quickSort(array,0,len-1);
	return[5,1]
}
function oddEvenSort(){
	let array=[...arr];
	while(!isSorted(array)){
		for(let n=0;n<=len-2;n+=2)if(compareIndices(array,n,n+1)>0)swap(array,n,n+1);
		for(let n=1;n<=len-2;n+=2)if(compareIndices(array,n,n+1)>0)swap(array,n,n+1);
	}
	return[-.05,1]
}
function stoogeSort(){
	let array=[...arr];
	const ss=(a,i,j)=>{
		if(compareIndices(a,i,j)>0)swap(a,i,j);
		if(j-i+1>=3){
			let t=(j-i+1)/3|0;
			ss(a,i,j-t);
			ss(a,i+t,j);
			ss(a,i,j-t);
		}
	}
	ss(array,0,len-1)
	return[4,1]
}
function slopeSort(){
	let array=[...arr];
	for(let i=1,j=1;i<len;i=j,j++)for(let k=i-1;k>=0;k--,i--)if(compareIndices(array,i,k)<0)swap(array,i,k);
	return[5,1]
}
function shellSort(){
	let array=[...arr];
	for(let i=0;!isSorted(array);i++,i%=len){
		for(let n=len/2|0;n>0;n=n/2|0){
			let j,o=array[i];
			for(j=i;j>=n&&compareValues(array[j-n],o)>0;j-=n)swap(array,j,j-n);
			write(array,j,o);
		}
	}
	return[-.1,1]
}

function recursiveShellSort(){
	let array=[...arr];
	function gis(a,b,c,g){
		for(let i=b+g;i<c;i+=g){
			let k=a[i],j=i-g;
			while(j>=b&&compareValues(k,a[j])<0){
				write(a,j+g,a[j]);
				j-=g;
			}
			write(a,j+g,k);
		}
	}
	function rss(a,s,e,g){
		if(s+g>e)return;
		rss(a,s,e,3*g);
		rss(a,s+g,e,3*g);
		rss(a,s+2*g,e,3*g);
		gis(a,s,e,g);
	}
	rss(array,0,len,1);
	return[5,1]
}
function andreySort(){
	let array=[...arr];
	function sort(a,b,c){
		while(c>1){
			let k=0;
			for(let i=1;i<c;i++)if(compareIndices(a,b+k,b+i)>0)k=i;
			swap(a,b,b+k);
			b++;c--;
		}
	}
	function aswap(a,a1,a2,l){
		while(l-->0)swap(a,a1++,a2++);
	}
	function backmerge(a,a1,l1,a2,l2){
		let a0=a2+l1;
		for(;;){
			if(compareIndices(a,a1,a2)>0){
				swap(a,a1--,a0--);
				if(--l1==0)return 0;
			}else{
				swap(a,a2--,a0--);
				if(--l2==0)break;
			}
		}
		let res=l1;
		do swap(a,a1--,a0--);while(--l1!=0);
		return res;
	}
	function rmerge(ar,a,l,r){
		for(let i=0;i<l;i+=r){
			let q=i;
			for(let j=i+r;j<l;j+=r)if(compareIndices(ar,a+q,a+j)>0)q=j;
			if(q!=i)aswap(ar,a+i,a+q,r);
			if(i!=0){
				aswap(ar,a+l,a+i,r);
				backmerge(ar,a+(l+r-1),r,a+(i-1),r);
			}
		}
	}
	function rbnd(l){
		l/=2;l|=0;
		let k=0;
		for(let i=1;i<l;i*=2)k++;
		l/=k;l|=0;
		for(k=1;k<=l;k*=2);
		return k;
	}
	function msort(ar,a,l){
		if(l<12)return sort(ar,a,l);
		let r=rbnd(l),lr=(l/r-1|0)*r;
		for(let p=2;p<=lr;p+=2){
			if(compareIndices(ar,a+(p-2),a+(p-1))>0)
				swap(ar,a+(p-2),a+(p-1));
			if((p&2)!=0)continue;
			aswap(ar,a+(p-2),a+p,2);
			let m=l-p,q=2;
			for(;;){
				let q0=q*2;
				if(q0>m||(p&q0)!=0)break;
				backmerge(ar,a+(p-q-1),q,a+(p+q-1),q);
				q=q0;
			}
			backmerge(ar,a+(p+q-1),q,a+(p-q-1),q);
			let q1=q;
			q*=2;
			while((q&p)==0){
				q*=2;
				rmerge(ar,a+(p-q),q,q1);
			}
		}
		let q1=0;
		for(let q=r;q<lr;q*=2){
			if((lr&q)!=0){
				q1+=q;
				if(q1!=q)rmerge(ar,a+(lr-q1),q1,r);
			}
		}
		let s=l-lr;
		msort(ar,a+lr,s);
		aswap(ar,a,a+lr,s);
		msort(ar,a,s+=backmerge(ar,a+s-1,s,a+lr-1,lr-s));
	}
	msort(array,0,len);
	return[5,1]
}
function blockSwapMergeSort(){
	let array=[...arr];
	const bin=(ar,s,md,e)=>{
		let a=0,b=minVal(md-s,e-md),m=a+(b-a)/2|0;
		while(b>a){
			if(compareIndices(ar,md-m-1,md+m)==1)a=m+1;
			else b=m;
			m=a+(b-a)/2|0;
		}
		return m;
	}
	const msm=(a,s,md,e)=>{
		let m=bin(a,s,md,e);
		while(m>0){
			for(let i=0;i<m;i++)
				swap(a,md-m+i,md+i);
			msm(a,md,md+m,e);
			e=md;
			md-=m;
			m=bin(a,s,md,e);
		}
	}
	const msms=(a,b,c)=>{
		let len=c-b,i;
		for(let j=1;j<len;j*=2){
			for(i=b;i+2*j<=c;i+=j*2)
				msm(a,i,i+j,i+j*2);
			if(i+j<c)
				msm(a,i,i+j,c);
		}
	}
	msms(array,0,len);
	return[5,1]
}
function inPlaceMergeSort(){
	let array=[...arr];
	const push=(ar,p,a,b)=>{
		if(a==b)return;
		let tmp=ar[p];
		write(ar,p,ar[a]);
		for(let i=a+1;i<b;i++)
			write(ar,i-1,ar[i]);
		write(ar,b-1,tmp);
	}
	const M=(a,b,m,c)=>{
		let i=b,j=m;
		while(i<m&&j<c)
			if(compareIndices(a,i,j)==1)j++;
			else push(a,i++,m,j);
		while(i<m)push(a,i++,m,c);
	}
	const ms=(a,b,c)=>{
		let m=b+(c-b)/2|0;
		if(c-b>2){
			if(c-b>3)
				ms(a,b,m);
			ms(a,m,c);
		}
		M(a,b,m,c);
	}
	ms(array,0,len);
	return[-.05,1]
}
function rotateMergeSort(){
	let array=[...arr];
	function rotate(ar,a,m,b){
		IndexRots.griesMills(ar,a,m,b,false);
	}
	function bs(ar,a,b,value,f){
		while(a<b){
			let m=a+(b-a)/2|0,comp=f?compareValues(value,ar[m])<1:compareValues(value,ar[m])<0;
			if(comp)b=m;
			else a=m+1;
		}
		return a;
	}
	function rotateMerge(ar,a,m,b){
		let m1,m2,m3;
		if(m-a>=b-m){
			m1=a+(m-a)/2|0;
			m2=bs(ar,m,b,ar[m1],true);
			m3=m1+(m2-m);
		}else{
			m2=m+(b-m)/2|0;
			m1=bs(ar,a,m,ar[m2],false);
			m3=(m2++)-(m-m1);
		}
		rotate(ar,m1,m,m2);
		if(m2-m3+1>0&&b-m2>0)rotateMerge(ar,m3+1,m2,b);
		if(m1-a>0&&m3-m1>0)rotateMerge(ar,a,m1,m3);
	}
	function rotateMergeSort(ar,a,b){
		let len=b-a,i;
		for(let j=1;j<len;j*=2){
			for(i=a;i+2*j<=b;i+=2*j)rotateMerge(ar,i,i+j,i+2*j);
			if(i+j<b)rotateMerge(ar,i,i+j,b);
		}
	}
	rotateMergeSort(array,0,len);
	return[5,1]
}
function strandSort(){
	let array=[...arr];
	function mergeTo(array,subList,a,m,b){
		let i=0,s=m-a;
		while(i<s&&m<b)
			if(compareValues(subList[i],array[m])<0)write(array,a++,subList[i++]);
			else write(array,a++,array[m++]);
		while(i<s)write(array,a++,subList[i++]);
	}
	let subList=new Array(len),j=len,k=j;
	while(j>0){
		write(subList,0,array[0]);
		for(let i=0,p=0,m=1;m<j;m++){
			if(compareValues(array[m],subList[i])>=0){
				write(subList,++i,array[m],true);
				k--;
			}else write(array,p++,array[m]);
		}
		mergeTo(array,subList,--k,j,len);
		j=k;
	}
	return[-.01,1]
}
function weavedMergeSort(){
	let array=[...arr];
	function merge(array,tmp,length,residue,modulus){
		if(residue+modulus>=length)return;
		let low=residue;
		let high=residue+modulus;
		let dmodulus=modulus<<1;
		merge(array,tmp,length,low,dmodulus);
		merge(array,tmp,length,high,dmodulus);
		let nxt=residue;
		for(;low<length&&high<length;nxt+=modulus){
			let cmp=compareIndices(array,low,high);
			if(cmp==1||cmp==0&&low>high){
				write(tmp,nxt,array[high],true);
				high+=dmodulus;
			}else{
				write(tmp,nxt,array[low],true);
				low+=dmodulus;
			}
		}
		if(low>=length){
			while(high<length){
				write(tmp,nxt,array[high],true);
				nxt+=modulus;
				high+=dmodulus;
			}
		}else{
			while(low<length){
				write(tmp,nxt,array[low],true);
				nxt+=modulus;
				low+=dmodulus;
			}
		}
		for(let i=residue;i<length;i+=modulus)
			write(array,i,tmp[i]);
	}
	let tmp=new Array(len);
	merge(array,tmp,len,0,1);
	return[-.01,1]
}
function pancakeSort(){
	let array=[...arr];
	let i=len
	while(i>=0&&!isSorted(array)){
		let c=getMaxIndex(array,i);
		if(c!=--i){
			reversal(array,0,c,false)
			reversal(array,0,i,false)
		}
	}
	return[5,1]
}
function maxHeapSort(){
	let array=[...arr];
	heapSort(array,0,len,true)
	return[-.01,1]
}
function minHeapSort(){
	let array=[...arr];
	heapSort(array,0,len,false)
	return[-.01,1]
}
function cycleSort(){
	let array=[...arr];
	let i=0
	while(i<len){
		let c=array[i]-1;
		if(compareIndices(array,i,c)!=0)swap(array,i--,c)
		i++
	}
	return[5,1]
}
function inPlaceMSDRadixSort(){
	let array=[...arr];
	const radixMSD=(a,l,min,max,r,p)=>{
		if(min>=max||p<0)return;
		let b=new Array(r);
		for(let i=0;i<r;i++)b[i]=min;
		for(let i=min;i<max;i++){
			let t=a[i],d=getDigit(t,p,r);
			for(let j=r-1;j>d;j--){
				if(b[j]!=b[j-1])
					write(a,b[j],a[b[j-1]]);
				write(b,j,b[j]+1,true);
			}
			write(a,b[d],t);
			write(b,d,b[d]+1,true);
		}
		for(let i=0;i<r;i++)radixMSD(a,l,i==0?min:b[i-1],b[i],r,p-1);
	}
	let base=4
	let hp=maxLog(array,len,base);
	radixMSD(array,len,0,len,base,hp);
	return[5,1]
}
function asteraceaeSort(){
	let array=[...arr];
	function cf(ar,l){
		let i=1,fs=2,as=1,ls=0;
		if(fs-1==0)i=1;
		else i=fs-1;
		as=0;ls=0;
		while(i<len){
			if(compareIndices(ar,i-1,i)>0){
				swap(ar,i-1,i++,1);
				if(!as)fs=i-1;
				as=ls=1;
			}else{
				if(ls)i+=sqrt(l)|0;
				else i++;
				ls=0;
			}
		}
		return as
	}
	let as=1;
	while(as){
		as=cf(array,len)
		customFunc(cf,[len])
	}
	return[5,0]
}
function LMSDRadixSort(){
	let array=[...arr];
	function radixSort(a,s,e,p){
		let regs=new Array(base);
		for(let i=0;i<base;i++)regs[i]=[];
		for(let i=s;i<e;i++){
			let digit=getDigit(a[i],p,base);
			regs[digit]=regs[digit].concat([a[i]]);
		}
		let c=s;
		for(let i=0;i<base;i++)
			for(let j=0;j<regs[i].length;j++)
				write(a,c++,regs[i][j])
		return regs;
	}
	function lmsdRadixSort(array,mina,maxa,place,maxPlace){
		if(maxPlace<place||maxa-mina<=1)return;
		let regs=radixSort(array,mina,maxa,place);
		if(place!=maxPlace){
			regs=radixSort(array,mina,maxa,maxPlace);
			let sum=0;
			for(let i=0;i<regs.length;i++){
				lmsdRadixSort(array,sum+mina,sum+mina+regs[i].length,place+1,maxPlace-1);
				sum+=regs[i].length;
			}
		}
	}
	let base=4;
	let hp=maxLog(array,len,base);
	lmsdRadixSort(array,0,len,0,hp);
	return[0,1]
}
function awkwardSort(){
	let array=[...arr];
	const awkward=(arr,l,p)=>{
		if(l==1)return;
		l|=0
		p|=0
		awkward(arr,l/2,p);
		awkward(arr,l/2+l%2,p+l/2);
		for(let i=0;i<l/2;i++){
			let a=p+i;
			let b=p+l/2+l%2+i;
			if(compareIndices(arr,a,b)==1)
				swap(arr,a,b);
		}
		awkward(arr,l/2+l%2,p+l/4);
		awkward(arr,l/2,p);
		awkward(arr,l/2+l%2,p+l/2);
	}
	awkward(array,len,0);
	return[5,1]
}
function chinottoSort(){
	let array=[...arr];
	let d=0;
	let gap=1;
	while(!d){
		let i=0;
		d=1;
		for(;i+gap<len;i++){
			if(compareIndices(array,i,i+gap)==1){
				d=0;
				multiSwap(array,i,i+gap,undefined);
				gap++;
			}else if(gap>=2)gap--;
		}
		for(;i-gap>0;i--){
			if(compareIndices(array,i-gap,i)==1){
				d=0;
				multiSwap(array,i,i-gap,undefined);
				gap++;
			}else if(gap>=2)gap--;
		}
	}
	return[5,1]
}
function circleMergeSort(){
	let array=[...arr];
	const csr=(a,l)=>{
		let sc=0;
		for(let g=l/2;g>circleDepth;g/=2){
			for(let s=0;s+g<len;s+=2*g){
				let h=s+2*g-1|0;
				let lw=s|0;
				for(;lw<h;){
					if(h<len&&compareIndices(a,lw,h)>0)
						swap(a,lw,h,0,sc++);
					lw++;h--;
				}
			}
		}
		return sc;
	}
	for(let n=1;n<=len;n*=2)
		while(csr(array,n));
	return[5,1]
}
function clamberSort(){
	let array=[...arr];
	for(let i=1;i<len;i++)
		for(let j=0;j<i;j++)
			if(compareIndices(array,i,j)<0)
				swap(array,i,j);
	return[5,1]
}
function cocktailGrateSort(){
	let array=[...arr];
	let n=1;
	while(n){
		n=0;
		let i,j;
		for(i=0;i<len-1;i++)
			for(j=len-1;j>i;j--)
				if(compareIndices(array,i,j)>0){
					n=1;
					swap(array,i,j);
					break;
				}
		if(!n)break;
		for(i=0;i<len-1;i++)
			for(j=i+1;j<len;j++)
				if(compareIndices(array,i,j)>0){
					swap(array,i,j);
					break;
				}
	}
	return[5,1]
}
function cocktailPushSort(){
	let array=[...arr];
	let as=1;
	function cf(ar,a,b,s,g){
		for(let j=1;j<=g;j++)
			swap(ar,a,b+j*s,1);
	}
	while(as){
		as=0;
		let i=1,g=1;
		while(i+g<=len){
			if(compareIndices(array,i-1,i-1+g)>0){
				cf(array,i-1,i-1,1,g)
				customFunc(cf,[i-1,i-1,1,g])
				as=1
				g++;
			}else i++;
		}
		i=len;
		g=1;
		while(i-g>0){
			if(compareIndices(array,i-1-g,i-1)>0){
				cf(array,i-1,i-1,-1,g)
				customFunc(cf,[i-1,i-1,-1,g])
				as=1
				g++;
			}else i--;
		}
	}
	return[0,0]
}
function dandelionSort(){
	let array=[...arr];
	for(let b=0;b<len;){
		let pointer=b;
		let as=0;
		while(pointer<len-1&&compareIndices(array,pointer+1,pointer)<0){
			swap(array,pointer,pointer+1);
			as=1;
			pointer++;
		}
		if(as){
			if(b>0)b--;
			continue;
		}
		b++;
	}
	return[5,0]
}
function floatSort(){
	let array=[...arr];
	let n=1;
	while(n){
		let h=0;
		n=0;
		for(let g=len-1;g>0;g--){
			let i=h;
			let j=h+1;
			while(i>=0&&compareIndices(array,i,j)>0){
				swap(array,i--,j--);
				n=1;
			}
			if(i>=0){
				i++;
				j++;
				while(j<len&&compareIndices(array,i,j)>0){
					swap(array,i++,j++);
					n=1;
				}
			}
			h++;
		}
	}
	return[5,1]
}
function iterativeQuickSort(){
	let array=[...arr];
	let s=0,e=len-1
	let st=new Array(len);
	let top=-1;
	write(st,++top,s,true);
	write(st,++top,e,true);
	while(top>=0){
		e=st[top--];
		s=st[top--];
		let pv=array[e];
		let i=s-1;
		for(let j=s;j<e;j++)
			if(compareValues(array[j],pv)<1)
				swap(array,++i,j);
		swap(array,++i,e);
		let p=i
		if(compareValues(p-1,s)==1){
			write(st,++top,s,true);
			write(st,++top,p-1,true);
		}
		if(compareValues(e,p+1)==1){
			write(st,++top,p+1,true);
			write(st,++top,e,true);
		}
	}
	return[5,1]
}
function indexQuickSort(){
	let array=[...arr];
	const iqs=(array,idx,a,b)=>{
		while(a<b){
			if(compareValues(a,idx[a])!=0){
				let t=array[a];
				let i=a,nxt=idx[a];
				do{
					write(array,i,array[nxt]);
					write(idx,i,i,true);
					i=nxt;
					nxt=idx[nxt];
				}while(compareValues(nxt,a)!=0);
				write(array,i,t);
				write(idx,i,i,true);
			}
			a++;
		}
	}
	const sort=(array,idx,a,b)=>{
		if(b-a<2)return;
		let c0=a,c1=c0,i;
		let m=a+random()*(b-a)|0;
		for(i=a;i<m;i++)
			if(compareIndices(array,i,m)<1)
				c1++;
		i++;
		c1++;
		for(;i<b;i++)
			if(compareIndices(array,i,m)<0)
				c1++;
		let p=c1-1;
		for(i=a;i<m;i++){
			if(compareIndices(array,i,m)<1)
				write(idx,c0++,i,true);
			else write(idx,c1++,i,true);
		}
		write(idx,p,i++,true);
		for(;i<b;i++){
			if(compareIndices(array,i,m)<0)
				write(idx,c0++,i,true);
			else write(idx,c1++,i,true);
		}
		iqs(array,idx,a,b);
		sort(array,idx,a,p);
		sort(array,idx,p+1,b);
	}
	let idx=new Array(len);
	sort(array,idx,0,len);
	return[5,1]
}
function pseudoHeapSort(){
	let array=[...arr];
	function sift_down(array,start,length,root){
		let swapped=0;
		let j=root;
		while(2*j<length){
			let k=2*j;
			if(k<length&&compareIndices(array,start+k-1,start+k)==1)k++;
			if(compareIndices(array,start+j-1,start+k-1)==1){
				swap(array,start+j-1,start+k-1);
				j=k;
				swapped=1;
				continue;
			}
			break;
		}
		return swapped;
	}
	let s=1
	while(s--)for(let i=len-2;i>=0;i--)sift_down(array,i,len-i+1,1)&&(s=1)
	return[1,1]
}
function iterativeCircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(icsr(array,n));
	return[5,1]
}
function recursiveCircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rcsr(array,0,n-1,0,len));
	return[5,1]
}
function LLQuickSortMiddlePivotSort(){
	let array=[...arr];
	function partition(array,a,b){
		let i=a,j=i,m=(a+b)/2|0;
		while(j<m){
			if(compareIndices(array,j,m)<1)
				swap(array,i++,j);
			j++;
		}
		swap(array,i,m);
		j=m+1;
		m=i++;
		while(j<b){
			if(compareIndices(array,j,m)<0)
				swap(array,i++,j);
			j++;
		}
		swap(array,--i,m);
		return i;
	}
	function quickSort(array,a,b){
		if(b-a>1){
			let p=partition(array,a,b);
			quickSort(array,a,p);
			quickSort(array,p+1,b);
		}
	}
	quickSort(array,0,len);
	return[5,1]
}
function pushSort(){
	let array=[...arr];
	let as=1;
	let i=1;
	let gap=1;
	function cf(a,g,i){
		for(let j=1;j<=g;j++)
			swap(a,i-1,i-1+j,1);
	}
	while(as){
		as=0;
		i=1;
		gap=1;
		while(i+gap<=len){
			if(compareIndices(array,i-1,i-1+gap)>0){
				cf(array,gap,i);
				customFunc(cf,[gap,i]);
				as=1;
				gap++;
			}else i++;
		}
	}
	return[5,0]
}
function reflectionSort(){
	let array=[...arr];
	let as=1,i=0;
	while(as){
		i=0;as=0;
		while(i<len){
			if(compareIndices(array,i,i+1)>0){
				swap(array,i,i+1);
				i=(len-1)-i;as=1;
			}else i++;
		}
		i=len;as=0;
		while(i>1){
			if(compareIndices(array,i-1,i)>0){
				swap(array,i-1,i);
				i=(len-1)-i;as=1;
			}else i--;
		}
	}
	return[5,1]
}
function splitCenterSort(){
	let array=[...arr];
	let way=1;
	let i=1;
	for(let r=1;r<len;r++){
		i=len/2|0;
		while(i<len&&i>0){
			if(compareIndices(array,i-1,i)>0)swap(array,i-1,i);
			i+=way;
		}
		way*=-1;
	}
	return[5,1]
}
function wiggleSort(){
	let array=[...arr];
	const ws=(a,l,s,e)=>{
		if(e-s<2)return;
		let lp=s,rp=e,mp=(lp+rp)/2|0,sl=1,j=mp;
		for(let i=lp;i<mp;i++){
			for(let k=mp;k<e;k++){
				if(compareIndices(a,i,j)>=0)swap(a,i,j);
				if(sl)j++;
				else j--;
			}
			if(sl)j--;
			else j++;
			sl=!sl
		}
		ws(a,l,s,mp);
		ws(a,l,mp,e);
	}
	ws(array,len,0,len);
	return[5,1]
}
function zipperSort(){
	let array=[...arr];
	let i=0,gap=2,f=0;
	while(gap>1){
		gap=1;
		i=f>1?f-1:0;
		while(i+gap<len){
			if(compareIndices(array,i,i+gap)>0){
				swap(array,i,i+gap);
				if(gap==1)f=i;
				gap++;
			}else i++;
		}
	}
	return[5,1]
}
function pairwiseCircleSort(){
	let array=[...arr];
	const pairs=(ar,l,r,g)=>{
		if(l+g>=r)return;
		let a=l;
		while(a+g<=r){
			if(compareIndices(ar,a,a+g)==1)
				swap(ar,a,a+g);
			a+=g*2;
		}
		pairs(ar,l,r,g*2);
		pairs(ar,l+g,r,g*2);
	}
	const circle=(ar,l,r)=>{
		let a=l,b=r;
		while(l<r){
			if(compareIndices(ar,l,r)==1)
				swap(ar,l,r);
			l++;r--;
		}
	}
	const pairCircle=(a,l,r)=>{
		if(l>=r)return;
		let m=(l+r)/2|0;
		pairs(a,l,r,1);
		circle(a,l,r);
		pairCircle(a,l,m);
		pairCircle(a,m+1,r);
	}
	pairCircle(array,0,len-1);
	insertSort(array,0,len);
	return[5,1]
}
function iterativeSinkingMergeSort(){
	let array=[...arr];
	const bs=(a,s,e)=>{
		let cs=1;
		for(let i=e-1;i>s;i-=cs){
			cs=1;
			for(let j=s;j<i;j++){
				if(compareIndices(a,j,j+1)>0){
					swap(a,j,j+1);
					cs=1;
				}else cs++;
			}
		}
	}
	let mRun=len;
	for(;mRun>=32;mRun=(mRun+1)/2);
	let i;
	for(i=0;i+mRun<len;i+=mRun)
		bs(array,i,i+mRun);
	bs(array,i,len);
	for(let j=mRun;j<len;j*=2){
		for(i=0;i+2*j<=len;i+=2*j)
			bs(array,i,i+2*j);
		if(i+j<len)
			bs(array,i,len);
	}
	return[5,0]
}
function recursiveSinkingMergeSort(){
	let array=[...arr];
	const bs=(a,s,e)=>{
		let cs=1;
		for(let i=e-1;i>s;i-=cs){
			cs=1;
			for(let j=s;j<i;j++){
				if(compareIndices(a,j,j+1)>0){
					swap(a,j,j+1);
					cs=1;
				}else cs++;
			}
		}
	}
	function sort(a,s,e){
		if(e-s>16){
			let m=s+(e-s)/2|0;
			sort(a,s,m);
			sort(a,m,e);
			bs(a,s,e);
		}else
			bs(a,s,e);
	}
	sort(array,0,len);
	return[5,0]
}
function cocktailShellSort(){
	let array=[...arr];
	let g=len/2;
	let dir=1;
	while(g>=1){
		if(dir){
			for(let i=g;i<len;i++){
				let tmp=array[i],j=i;
				while(j>=g&&compareValues(array[j-g],tmp)==1){
					write(array,j,array[j-g]);
					j-=g;
				}
				write(array,j,tmp);
			}
		}else{
			for(let i=len-g;i>=0;i--){
				let tmp=array[i],j=i;
				while(j<len-g&&compareValues(array[j+g],tmp)==-1){
					write(array,j,array[j+g]);
					j+=g;
				}
				write(array,j,tmp);
			}
		}
		g/=2;
		dir=!dir;
	}
	return[5,1]
}
function indexMergeSort(){
	let array=[...arr];
	function sort(ar,idx,a,b){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		sort(ar,idx,a,m);
		sort(ar,idx,m,b);
		let i=a,j=m,c=a;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<1)write(idx,c++,i++,true);
			else write(idx,c++,j++,true);
		}
		while(i<m)write(idx,c++,i++,true);
		while(j<b)write(idx,c++,j++,true);
		while(a<b){
			if(compareValues(a,idx[a])!=0){
				let t=array[a];
				let i=a,nxt=idx[a];
				do{
					write(array,i,array[nxt]);
					write(idx,i,i,true);
					i=nxt;
					nxt=idx[nxt];
				}while(compareValues(nxt,a)!=0);
				write(array,i,t);
				write(idx,i,i,true);
			}
			a++;
		}
	}
	let idx=new Array(len);
	sort(array,idx,0,len);
	return[5,1]
}
function mobMergeSort(){
	let array=[...arr];
	const bubble=(array,start,end)=>{
		let c=1,s,f=start+((end-start)/2)|0,a=false;
		for(let j=end-1;j>0;j-=c){
			if(f-1<start)s=start;
			else s=f-1;
			a=false;
			c=1;
			for(let i=s;i<j;i++){
				if(compareIndices(array,i,i+1)>0){
					swap(array,i,i+1);
					if(!a)f=i;
					a=true;c=1;
				}else c++;
			}
		}
	}
	let l=2,index=0;
	while(l<=len){
		index=0;
		while(index+l<=len){
			if(l==2){
				if(compareIndices(array,index,index+1)>0)swap(array,index,index+1);
			}else bubble(array,index,index+l);
			index+=l;
		}
		if(index!=len)bubble(array,index,len);
		l*=2;
	}
	bubble(array,0,len);
	return[5,0]
}
function moduloMergeSort(){
	let array=[...arr];
	const mr=(a,s,m,e,mx)=>{
		let l=s,r=m+1,f=s;
		while(l<=m&&r<=e){
			if(compareValues(a[l]%mx,a[r]%mx)<1)write(a,f,a[f]+(a[l++]%mx)*mx);
			else write(a,f,a[f]+(a[r++]%mx)*mx);
			f++;
		}
		while(l<=m)write(a,f,a[f++]+(a[l++]%mx)*mx);
		while(r<=e)write(a,f,a[f++]+(a[r++]%mx)*mx);
		for(let i=s;i<=e;i++)write(a,i,a[i]/mx);
	}
	const ms=(a,s,e,mx)=>{
		if(s>=e)return;
		let m=s+((e-s)/2)|0;
		ms(a,s,m,mx);
		ms(a,m+1,e,mx);
		mr(a,s,m,e,mx);
	}
	ms(array,0,len-1,getMax(array,len)+1);
	return[5,1]
}
function split16MergeSort(){
	let array=[...arr];
	let m16s=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16,1,5,9,13,2,6,10,14,3,7,11,15,4,8,12,16,1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16,6,11,7,10,4,13,14,15,8,12,2,3,5,9,2,5,8,14,3,9,12,15,6,7,10,11,3,5,12,14,4,9,8,13,7,9,11,13,4,6,8,10,4,5,6,7,8,9,10,11,12,13,7,8,9,10];
	const cs1=(a,b,c)=>{
		if(compareIndices(a,b,c)>0)
			swap(a,b,c);
	}
	const cs2=(a,b,c,g,s)=>{
		if(compareIndices(a,s+b*g,s+c*g)>0)
			swap(a,s+b*g,s+c*g);
	}
	const mos=(a,b,g)=>{
		for(let i=0;i<m16s.length;i+=2)
			cs2(a,m16s[i]-1,m16s[i+1]-1,g,b);
	}
	const merge=(a,st,sz)=>{
		let gap=sz/16;
		for(let i=0;i<gap;i++)mos(a,st+i,gap);
		for(let s=gap/2;s>0;s/=2)
			for(let i=0;i<sz-s;i++)
				cs1(a,st+i,st+i+s);
	}
	for(let i=0;i<len-15;i+=16)mos(array,i,1);
	for(let g=32;g<=len;g*=2)
		for(let i=0;i+g<=len;i+=g)
			merge(array,i,g);
	return[5,1]
}
function cbrtQuickSort(){
	let array=[...arr];
	const sort=(a,start,stop)=>{
		let l=stop-start;
		if(l>=2){
			let root=cbrt(l)|0;
			let newStart=start+root;
			sort(a,start,newStart);
			let pivots=new Array(root);
			for(let i=0;i<root;i++)write(pivots,i,i+start,true);
			for(let i=newStart;i<stop;i++){
				let f=0,right=root;
				while(f<right){
					let m=(right-f)/2+f|0;
					if(compareIndices(a,pivots[m],i)==1)right=m;
					else f=m+1;
				}
				let p=i;
				for(let j=root-1;j>=f;j--){
					swap(a,pivots[j]+1,p);
					swap(a,p=pivots[j],pivots[j]+1);
					write(pivots,j,pivots[j]+1,true);
				}
			}
			sort(a,start,pivots[0]);
			for(let i=1;i<root;i++)
				sort(a,pivots[i-1]+1,pivots[i]);
			sort(a,pivots[root-1]+1,stop);
		}
	}
	sort(array,0,len)
	return[5,1]
}
function apollyonSort(){
	let array=[...arr];
	const apm=(A,lo,n,d)=>{
		if(n<=1)return;
		let m=1;
		while(m<<1<n)m<<=1;
		for(let i=lo;i<lo+n-m;i++)
			if(d==(compareIndices(A,i,i+m)==1))
				swap(A,i,i+m)
		apm(A,lo,m,d);
		apm(A,lo+m,n-m,d);
	}
	const aps=(A,lo,n,d)=>{
		if(n<=1)return;
		let m=n/2|0;
		aps(A,lo,m,!d);
		apm(A,lo,n,d);
	}
	aps(array,0,len,1);
	while(rcsr(array,0,len-1,0));
	return[5,1]
}
function optimizedPancakeSort(){
	let array=[...arr];
	function cursedRotate(a,b,m,c){
		reversal(a,0,b-1,0);
		reversal(a,0,m-1,0);
		reversal(a,0,c-1,0);
		reversal(a,0,c-m+b-1,0);
	}
	function bs(ar,a,b,v,l){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(l?compareValues(v,ar[m])<1:compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function pm(array,m,b){
		let m1,m2,m3;
		if(m>=b-m){
			m1=m/2|0;
			m2=bs(array,m,b,array[m1],0);
			m3=m1+(m2-m);
		}else{
			m2=m+(b-m)/2|0;
			m1=bs(array,0,m,array[m2],1);
			m3=(m2++)-(m-m1);
		}
		cursedRotate(array,m1,m,m2);
		if(m1>0&&m3>m1)pm(array,m1,m3);
		m3++;
		if(m2>m3&&b>m2){
			cursedRotate(array,0,m3,b);
			pm(array,m2-m3,b-m3);
			cursedRotate(array,0,b-m3,b);
		}
	}
	function pms(array,n){
		if(n<=1)return;
		if(compareIndices(array,0,1)<1){
			let i=2;
			for(;i<n&&compareIndices(array,i-1,i)<1;i++);
			if(i==n)return;
		}else{
			let i=2;
			for(;i<n&&compareIndices(array,i-1,i)>0;i++);
			if(i==n){
				reversal(array,0,n-1,0);
				return;
			}
		}
		let m=n/2|0;
		pms(array,m);
		cursedRotate(array,0,m,n);
		m=n-m;
		pms(array,m);
		pm(array,m,n);
	}
	pms(array,len);
	return[5,1]
}
function magneticaQuickSort(){
	let array=[...arr];
	let f=0,right=len-1,threshold=17,i,j,pl,pr,entries=right-f+1,stack=new Array(entries),stackptr=2,p,lback=f,rback=right,midmid,gear=0,cmp;
	write(stack,1,f,true);
	write(stack,2,right,true);
	do{
		right=stack[stackptr];
		f=stack[stackptr-1];
		stackptr-=2;
		for(;f+threshold<right;){
			j=right;
			pl=f;
			pr=f;
			if(right-f>31){
				midmid=f+((right-f)>>2);
				if(gear==0){
					insertSort(array,midmid,midmid+3);
					swap(array,midmid+1,pr);
				}else{
					insertSort(array,midmid,midmid+7);
					swap(array,midmid+3,pr);
				}
			}
			p=array[pr];
			for(;pr<j;){
				pr++;
				cmp=compareValues(p,array[pr]);
				if(cmp>0){
					swap(array,pl,pr);
					pl++;
				}else if(cmp<0){
					for(;compareValues(p,array[j])<0;)j--;
					if(pr<j)swap(array,pr,j);
					j--;
					pr--;
				}
			}
			j=pl-1;
			i=pr+1;
			gear=(maxVal(right-i,j-f)>(minVal(right-i,j-f)<<6)?1:0);
			if(i+threshold<right){
				stackptr+=2;
				write(stack,stackptr-1,i,true);
				write(stack,stackptr,right,true);
				stackptr*=(stackptr+2<=entries-1?1:0);
				right*=(stackptr+2<=entries-1?1:0);
			}
			right=j;
		}
	}while(stackptr!=0);
	insertSort(array,lback,rback+1);
	return[5,1]
}
function cocktailPeelSort(){
	let array=[...arr];
	for(let l=0;l<len;l++){
		let s=0;
		for(let r=len-1;r>l;r--){
			if(compareIndices(array,l,r+s)>0){
				let i=array[r+s];
				for(let p=r+s;p>l;p--)write(array,p,array[p-1]);
				write(array,l,i);
				s++;
			}
		}
		l++;
		for(let r=l+1;r<len;r++){
			if(compareIndices(array,l,r)>0){
				let i=array[r];
				for(let p=r;p>l;p--)write(array,p,array[p-1]);
				write(array,l,i);
			}
		}
	}
	return[5,1]
}
function ecoloSort(){
	let array=[...arr];
	let l=1,r=len,w=1,i=1;
	while(l<=r){
		if(w==1)i=l;
		else i=r;
		while((w==1&&i<r)||(w==-1&&i>l)){
			if(compareIndices(array,l-1,i-1)>0)swap(array,l-1,i-1);
			if(compareIndices(array,i-1,r-1)>0)swap(array,i-1,r-1);
			i+=w;
		}
		l++;r--;w*=-1;
	}
	return[5,1]
}
function fallSort(){
	let array=[...arr];
	let l=1;
	let r=2;
	let hl=0;
	while(l<=len){
		r=l+1;
		hl=0;
		while(r<=len){
			if(compareIndices(array,l-1,r-1)>0){
				if(hl==0)hl=r;
				else if(compareIndices(array,hl-1,r-1)<0)hl=r;
			}
			r++;
		}
		if(hl==0)l++;
		else swap(array,l-1,hl-1);
	}
	return[5,1]
}
function heavyHeapSort(){
	let array=[...arr];
	function bitReversal(ar,a,b){
		let l=b-a,m=0;
		let d1=l>>1,d2=d1+(d1>>1);
		for(let i=1;i<l-1;i++){
			let j=d1;
			for(let k=i,n=d2;(k&1)==0;j-=n,k>>=1,n>>=1);
			m+=j;
			if(m>i)swap(ar,a+i,a+m);
		}
	}
	let d=0;
	for(let i=0;i<len;i++){
		heapify(array,i,len,d,1);
		customFunc(heapify,[i,len,d++,1])
		d%=2
	}
	for(let i=1,j=len-1;i<j;i+=2,j-=2)swap(array,i,j);
	bitReversal(array,0,len);
	bitReversal(array,0,len/2|0);
	bitReversal(array,len/2|0,len);
	return[15,1]
}
function sandPaperSort(){
	let array=[...arr];
	for(let i=0;i<len-1;i++)
		for(let j=i+1;j<len;j++)
			if(compareIndices(array,i,j)>0)
				swap(array,i,j);
	return[5,1]
}
function recursiveBurningSort(){
	let array=[...arr];
	function sort(array,start,end){
		if(start==end)return;
		let mid=(start+end)/2|0,g0=mid-start;
		if(start==mid)return;
		sort(array,start,mid);
		sort(array,mid,end);
		for(let i=0;i<g0;i++)
			if(i+start!=end-i-1&&compareIndices(array,i+start,end-i-1)==1)
				swap(array,i+start,end-i-1);
		sort(array,start,mid);
		sort(array,mid,end);
	}
	sort(array,0,len,0);
	return[5,1]
}
function corruptSort(){
	let array=[...arr];
	const comp=(a,s,e)=>{
		if(compareIndices(a,s,e)==1)
			swap(a,s,e);
	}
	const pass=(a,s,e,l,g,t)=>{
		for(let i=s;i<e;i++)
			for(let g2=g;g2>t;g2/=2)
				if(i+g2<l)
					comp(a,i,i+g2);
	}
	const merge=(a,s,e,b)=>{
		if(e<=s)return;
		let m=(s+e)/2|0,g0=m-s,g1=g0/2|0;
		if(!b)
			for(let i=s;i<m;i++)
				if(i+g0<e)
					comp(a,i,i+g0);
		if(s==m)return;
		if(e-s>4)
			pass(a,s+g1,m,e,g1,1);
		merge(a,s,m,1);
		merge(a,m,e,1);
	}
	const sort=(a,s,e)=>{
		if(e<=s)return;
		let m=(s+e)/2|0;
		if(s==m)merge(a,s,e,0);
		else{
			sort(a,s,m);
			sort(a,m,e);
			merge(a,s,e,0);
		}
	}
	let n=1;
	while(n*2<=len)n*=2;
	sort(array,0,len);
	pass(array,0,len,len,n-1,0);
	return[5,1]
}
function circleHalverSort(){
	let array=[...arr];
	let end;
	const cs=(a,b,c)=>{
		let m=b<c&&c<len&&compareIndices(a,b,c)>0
		m&&swap(a,b,c);
		return m;
	}
	const bc=(a,b,c)=>{
		let d=0
		for(let i=b,j=c-1;i<j;i++,j--)
			d=cs(a,i,j);
		return d;
	}
	const halver=(a,b,c)=>{
		let n=c-b,e=-1;
		while(1){
			for(let j=1;j<n/2;j*=2)
				for(let i=b;i<minVal(len,c);i+=2*j)
					for(let k=0;k<j;k++)
						cs(a,i+k,i+j+k);
			if(!bc(a,b,c))break;
			e++;
		}
	}
	let l=1<<(log(len-1)/log(2))+1|0;
	halver(array,0,l);
	for(let j=l/2;j>4;j/=2)
		for(let i=0;i+j/2<len;i+=j)
			if(bc(array,i,i+j))
				halver(array,i,i+j);
	for(let i=2;i<len;i+=4)
		cs(array,i-1,i);
	return[5,1]
}
function iterativePairwiseSort(){
	let array=[...arr];
	const sort=(ar,l)=>{
		let a=1,b=0,c=0,d=0,e=0;
		while(a<l){
			b=a;c=0;
			while(b<l){
				if(compareIndices(ar,b-a,b)>0)swap(ar,b-a,b);
				c=(c+1)%a;b++;
				if(c==0)b+=a;
			}
			a*=2;
		}
		a/=4;e=1;a|=0
		while(a>circleDepth){
			a|=0;d=e;
			while(d>0){
				d|=0;b=(d+1)*a;c=0;
				while(b<l){
					if(compareIndices(ar,b-d*a,b)>0)swap(ar,b-d*a,b);
					c=(c+1)%a;b++;
					if(c==0)b+=a;
				}
				d/=2;
			}
			a/=2;e=2*e+1;
		}
	}
	sort(array,len);
	return[5,1]
}
function iterativeVanVoorhisSort(){
	let array=[...arr];
	const cs=(a,b,c)=>{
		if(compareIndices(array,b,c)>0)swap(a,b,c);
	}
	const cr=(a,b,c,s)=>{
		while(s-->0)cs(a,b++,c++);
	}
	for(let k=4;k/4<=len;k*=4){
		let f=k/4;
		for(let i=0;i<len;i+=k){
			cr(array,i,i+f,f);
			cr(array,i+f+f,i+f+f+f,f);
		}
		for(let i=0;i<len;i+=k){
			cr(array,i,i+f+f,f);
			cr(array,i+f,i+f+f+f,f);
		}
		for(let i=0;i<len;i+=k)cr(array,i+f,i+f+f,f);
		for(let m=16;m<=k;m*=4){
			let s=k/m;
			for(let i=0;i<len;i+=k)
				for(let j=2;j+7<m;j+=4){
					cr(array,i+j*s,i+(j+6)*s,s);
					cr(array,i+(j+1)*s,i+(j+7)*s,s);
				}
			for(let i=0;i<len;i+=k)
				for(let j=1;j+5<m;j+=4){
					cr(array,i+j*s,i+(j+3)*s,s);
					cr(array,i+(j+2)*s,i+(j+5)*s,s);
				}
			for(let i=0;i<len;i+=k)
				for(let j=2;j+3<m;j+=4){
					cr(array,i+j*s,i+(j+2)*s,s);
					cr(array,i+(j+1)*s,i+(j+3)*s,s);
				}
			for(let i=0;i<len;i+=k)
				for(let j=3;j+3<m;j+=2)
					cr(array,i+j*s,i+(j+1)*s,s);
		}
	}
	return[5,1]
}
function rotateLSDRadixSort(){
	let array=[...arr];
	const msw=(a,b,c,l)=>{
		for(let i=0;i<l;i++)swap(a,b+i,c+i);
	}
	function rotate(a,b,c,m){
		let l=m-b,r=c-m;
		while(l>0&&r>0){
			if(r<l){
				msw(a,m-r,m,r);
				c-=r;m-=r;l-=r;
			}else{
				msw(a,b,m,l);
				b+=l;m+=l;r-=l;
			}
		}
	}
	function bs(ar,a,b,d,p){
		while(a<b){
			let m=(a+b)/2|0;
			if(getDigit(ar[m],p,base)>=d)b=m;
			else a=m+1;
		}
		return a;
	}
	function merge(array,a,m,b,da,db,p){
		if(b-a<2||db-da<2)return;
		let dm=(da+db)/2|0;
		let m1=bs(array,a,m,dm,p);
		let m2=bs(array,m,b,dm,p);
		rotate(array,m1,m2,m);
		m=m1+(m2-m);
		merge(array,m,m2,b,dm,db,p);
		merge(array,a,m1,m,da,dm,p);
	}

	function ms(ar,a,b,p){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		ms(ar,a,m,p);
		ms(ar,m,b,p);
		merge(ar,a,m,b,0,base,p);
	}
	let base=10,max=maxLog(array,len,base);
	for(let i=0;i<=max;i++)
		ms(array,0,len,i);
	return[5,1]
}
function digSort(){
	let array=[...arr];
	function par(ar,a,b){
		let mx=new Array(b-a),max=ar[a];
		for(let i=1;i<b-a;i++)
			if(ar[a+i]>max){
				max=ar[a+i];
				mx[i]=1;
			}
		let p=1;
		for(let i=b-a-1,j=b-a-1;j>=0&&i>=p;j--){
			while(!mx[j]&&j>0)j--;
			max=array[a+j];
			while(max<=ar[a+i]&&i>=p)i--;
			if(compareIndices(ar,a+j,a+i)==1&&p<i-j)p=i-j;
		}
		return p;
	}
	let ls=0,le=0,ms=len-2,sw=1;
	for(let i=0;i<len&&sw;i=ls){
		le=par(array,0,len);
		sw=0;
		let msed=0;
		for(let j=ms;j>=i;j--){
			if(compareIndices(array,j,j+1)>0){
				swap(array,ls=j,j+1);
				sw=1
				if(msed){
					msed=1;
					ms=j+1<len-1?j+1:len-2;
				}
			}
		}
		for(let l=ls+1;l<=ms&&sw;l++){
			if(compareIndices(array,l,l+1)>0){
				let bl=l+le<len-1?l+le:len-2;
				for(let r=l+1;r<=bl;r++){
					if(compareIndices(array,l,r)>0){
						swap(array,l++,r);
						if(r>ms)ms=r;
					}
				}
			}
		}
	}
	return[5,1]
}
function cityscapeSort(){
	let array=[...arr];
	function csdep(a,i,j){
		if(i==j)return;
		let b=minVal(i,j),c=maxVal(i,j);
		if(compareIndices(a,b,c)>0)swap(a,b,c);
	}
	function sp(a,s,e,g){
		for(let h=g,i=h+s;i<e;i++){
			let v=a[i],j=i,w=0;
			for(;j>=h&&j-h>=s&&compareValues(a[j-h],v)==1;j-=h)write(a,j,a[j-h],0,w=1);
			if(w)write(a,j,v);
		}
	}
	function sh(a,s,e){
		for(let g=((e-s)/2.25)|0;g>=2;g/=2.25)sp(a,s,e,g|0);
		sp(a,s,e,1);
	}
	function mxs(ar,st,e){
		let a=e-1,b=e-1,sg=1;
		while(sg){
			if(b-1<st)return st;
			if(compareIndices(ar,b-1,b)>0)sg=0;
			else b--;
		}
		let sel=b-1;
		for(let s=b-2;s>=st;s--)
			if(compareIndices(ar,sel,s)<0)sel=s;
		while(compareIndices(ar,sel,a)<1)
			if(--a<st)break;
		return a+1;
	}
	function shuffle(a,s,e){
		for(let i=s;i<e;i++){
			let r=random()*(e-i)+i|0;
			if(r!=i)swap(array,i,r);
		}
	}
	let i=len;
	while(i>0){
		let h=i,j=0;
		for(;j<i;j++){
			csdep(array,j,j+1);
			for(h=i-1;h>i-j-2;h--){
				csdep(array,j,h);
				if(h<=j)break;
			}
			if(h<=j)break;
		}
		sh(array,j,i);
		i=mxs(array,0,i);
		shuffle(array,0,i);
	}
	return[5,1]
}
function iterativeClericSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(iclsr(array,n,len));
	return[5,1]
}
function recursiveClericSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rclsr(array,0,n-1,0));
	return[5,1]
}
function debrisSort(){
	let array=[...arr];
	let i=0,f=1,l=len-1,nl=len-1,ar=true;
	while(ar){
		ar=false;
		let ff=false;
		if(f>0)i=f-1;
		else i=0;
		for(;i<l;i++){
			let s=i;
			for(;compareIndices(array,i,i+1)>0&&i<l;i++){
				if(!ff){
					f=i;ff=true;
				}
				nl=i+1;
			}
			let e=i;
			if(s!=e){
				if(e-s<3)swap(array,s,e,0,ar=true);
				else reversal(array,s,e,0,ar=true);
			}
		}
		if(nl+1<len)l=nl+1;
		else l=len-1;
	}
	return[5,1]
}
function evubSort(){
	let array=[...arr];
	function cs(a,b){
		if(compareIndices(a,b,b+1)>0)swap(a,b,b+1);
	}
	function sort(a,b,bs){
		if(bs==1)for(let c=0;c<=b;c++)cs(a,c);
		else for(let c=0;c<=b;c++)sort(a,c,bs-1);
	}
	let base=3;
	for(let a=len-1;a>0;a--)
		for(let b=0;b+1<=a;b++)
			if(base==2)cs(array,b);
			else sort(array,b,base-2);
	return[5,0]
}
function iterativeFiringSquadSort(){
	let array=[...arr];
	function fs(array,start,end,dir){
		if(dir){
			let f=start,right=start+1,lcycle=1,rcycle=true;
			while(f<right){
				if(compareIndices(array,f,right)>0)swap(array,f,right,0,swaps=1);
				if(++lcycle>2){
					f++;lcycle=0;
				}
				if(rcycle){
					if(++right>end-1){
						right--;rcycle=0;
					}
				}else right--;
			}
		}else{
			let right=end-1,f=end-2,rcycle=1,lcycle=true;
			while(f<right){
				if(compareIndices(array,f,right)>0)swap(array,f,right,0,swaps=1);
				if(++rcycle>2){
					right--;rcycle=0;
				}
				if(lcycle){
					if(--f<start){
						f++;lcycle=false;
					}
				}else f++;
			}
		}
	}
	function init(array,start,end,firstdir){
		fs(array,start,end,firstdir);
		let dir=true;
		for(let l=(end-start)/2;l>1;l/=2)
			for(let i=start;i+l<=end;i+=l)
				fs(array,i,i+l,dir=!dir);
	}
	let swaps=1;
	let l=2;
	for(;l*2<=len;l*=2);
	let cdir=0;
	while(swaps){
		swaps=false;
		if(l==len)init(array,0,len,cdir=!cdir);
		else{
			init(array,0,l,true);
			if(len-l>=l/2)init(array,(len-l)/2|0,(len+l)/2|0,true);
			init(array,len-l,len,false);
		}
	}
	return[5,1]
}
function recursiveFiringSquadSort(){
	let array=[...arr];
	function fs(array,start,end,dir){
		if(dir){
			let f=start,right=start+1,lcycle=1,rcycle=true;
			while(f<right){
				if(compareIndices(array,f,right)>0)swap(array,f,right,0,swaps=1);
				if(++lcycle>2){
					f++;lcycle=0;
				}
				if(rcycle){
					if(++right>end-1){
						right--;rcycle=0;
					}
				}else right--;
			}
		}else{
			let right=end-1,f=end-2,rcycle=1,lcycle=1;
			while(f<right){
				if(compareIndices(array,f,right)>0)swap(array,f,right,0,swaps=1);
				if(++rcycle>2){
					right--;rcycle=0;
				}
				if(lcycle){
					if(--f<start){
						f++;lcycle=0;
					}
				}else f++;
			}
		}
		if(end-start>2){
			fs(array,start,end-(end-start)/2|0,false);
			fs(array,end-(end-start)/2|0,end,true);
		}
	}
	let swaps=1,l=2;
	for(;l*2<=len;l*=2);
	let cdir=0;
	while(swaps){
		swaps=false;
		if(l==len)fs(array,0,len,cdir=!cdir);
		else{
			fs(array,0,l,true);
			if(len-l>=l/2)init(array,(len-l)/2|0,(len+l)/2|0,true);
			fs(array,len-l,len,false);
		}
	}
	return[5,1]
}
function fordSort(){
	let array=[...arr];
	let q=0;
	while(!rangeSorted(array,len)){
		for(let k=len/2;k>0;k--){
			for(let i=q;i<len;i+=2*k){
				let l=i,change=0;
				while(l>0&&compareIndices(array,l,l-1)==-1){
					swap(array,l,l-1);
					l-=2;
					if(i>0)i--;
					change=1;
				}
				if(change)i++;
				else i--;
			}
		}
		q=(q+1)&1;
	}
	return[5,1]
}
function futureSort(){
	let array=[...arr];
	let as=1,tl=2;
	for(;tl*2<=len;tl*=2);
	let l=len;
	while(as){
		as=0;
		let ls=0;
		for(let o=0,m=1;o!=l-1;o++){
			if(tl>1){
				while(o+m*2<l)m*=2;
				while(m>=tl)m/=2;
			}
			for(;m>=1;m/=2)
				if(compareIndices(array,o,o+m)>0)
					swap(array,ls=o,o+m,0,as=1);
		}
		l=ls+2<l?ls+1:l-1;
		if(tl>1)tl/=2;
	}
	return[5,1]
}
function iterativePopSort(){
	let array=[...arr];
	function cf(a,d,s,j,b,f,c){
		for(let i=s;i<j;i++){
			if(compareIndices(a,i,i+1)==d){
				swap(a,i,i+1,1);
				if(!b)f=i;
				b=1;
				c=1;
			}else c++;
		}
		return[f,b,c]
	}
	const bubble=(a,st,e,d)=>{
		let s,c=1,f=1;
		for(let j=e-1;j>0;j-=c){
			if(f-1<st)s=st;
			else s=f-1;
			let b=0;
			c=1;
			let f1=1,b1=b,c1=c;
			[f,b,c]=cf(a,d,s,j,b1,f1,c1)
			if(b)customFunc(cf,[d,s,j,b1,f1,c1]);
		}
	}
	for(let l=2;l<len;l*=2){
		let i=0,d=-1;
		for(;i+l<=len;i+=l,d*=-1)bubble(array,i,i+l,d);
		if(i!=len)bubble(array,i,len,d);
	}
	bubble(array,0,len,1);
	return[5,1]
}
function jumpDownSort(){
	let array=[...arr];
	for(let i=len-1;i>0;i--)
		for(let j=0;j<i;j++)
			if(compareIndices(array,i,j)<0)
				swap(array,i,j);
	return[5,1]
}
function monolithicClurgeSort(){
	let array=[...arr];
	const mc=(a,s,m,e,b)=>{
		if(m<=s||e<=m)return;
		if(b==0){
			mc(a,s,s+(m-s)/2|0,m,0);
			mc(a,m,m+(e-m)/2|0,e,0);
			mc(a,s,m,e,1);
		}else{
			let c=0;
			if((c=compareIndices(a,s,m))==1)
				swap(a,s,m);
			mc(a,s+1,m,e,2);
			if(b!=2)
				mc(a,s+(c==-1?2:1),m+1,e,1);
		}
	}
	mc(array,0,len/2|0,len,0);
	return[5,1]
}
function pairwiseCombSort(){
	let array=[...arr];
	const i3s=n=>{
		while((n&1)==0)n>>=1;
		return(n&++n)==0;
	}
	for(let g=len/2;g>0;g--)
		if(i3s(g))
			for(let i=g;i<len;i++)
				if(compareIndices(array,i-g,i)==1)
					swap(array,i-g,i);
	return[5,1]
}
function pancakeQuickSort(){
	let array=[...arr];
	const flip=(a,i)=>reversal(a,0,i,0);
	const rot=(a,c1,c2)=>{
		flip(a,c1-1);
		flip(a,c2-1);
		flip(a,c2-c1-1);
	}
	const medOf3=(a,p1,p2,p3)=>{
		if(p1==p2)return p1;
		if(p2==p3)return p2;
		if(compareIndices(a,p1,p2)<1){
			if(compareIndices(a,p2,p3)<1)return p2;
			if(compareIndices(a,p1,p3)<1)return p3;
			return p1;
		}
		if(compareIndices(a,p2,p3)<1)return p2;
		if(compareIndices(a,p1,p3)<1)return p1;
		return p3;
	}
	function pancakeLLQS(a,l){
		if(l==2){
			if(compareIndices(a,0,l-1)>0)flip(a,l-1);
			return;
		}else if(l<2)return;
		let j=0,m=(l-1)/2|0,piv=a[medOf3(a,0,m,l-1)];
		for(let i=0;i<l;i++){
			let k=i;
			while(k<l&&compareValues(a[k],piv)<1){
				k++;j++;
			}
			if(k>i){
				reversal(a,0,i-1)
				reversal(a,0,k-1)
				i=k-1;
			}
		}
		pancakeLLQS(a,j);
		rot(a,j,l);
		pancakeLLQS(a,l-j);
		rot(a,l-j,l);
	}
	pancakeLLQS(array,len);
	return[5,1]
}
function popPopSort(){
	let array=[...arr];
	function cf(a,s,e,d){
		j=s
		for(let i=s;i<=e-1;i++)
			if(compareIndices(a,i-1,i)==d)
				swap(a,i-1,j=i,1);
		return j
	}
	const bb=(a,s,e,d)=>{
		while(1){
			customFunc(cf,[s,e,d]);
			if(cf(a,s,e,d)<s+1)break;
		}
	}
	const p=(a,s,e,d)=>{
		bb(a,s,s+(e-s)/4|0,0-d);
		bb(a,s+(e-s)/4+1|0,(s+e)/2|0,d);
		bb(a,(s+e)/2+1|0,s+(e-s)*3/4|0,0-s);
		bb(a,s+(e-s)*3/4+1|0,e,d);
		bb(a,s,(s+e)/2|0,0-d);
		bb(a,(s+e)/2+1|0,e,d);
		bb(a,s,e,d);
	}
	p(array,1,(len+1)/4|0,-1);
	p(array,(len+1)/4+1|0,(len+1)/2|0,1);
	p(array,(len+1)/2+1|0,(len+1)*3/4|0,-1);
	p(array,(len+1)*3/4+1|0,len,1);
	p(array,1,len,1);
	return[5,0]
}
function inPlaceLSDRadixSort(){
	let array=[...arr];
	let pos=0,tb=Number(prompt("base",10))|0,base=(tb>1&&tb<=len)?tb:10,vregs=new Array(base-1),maxpower=maxLog(array,len,base);
	for(let p=0;p<=maxpower;p++){
		for(let i=0;i<vregs.length;i++)write(vregs,i,len-1,true);
		pos=0;
		for(let i=0;i<len;i++){
			let digit=getDigit(array[pos],p,base);
			if(digit==0)
				pos++;
			else{
				for(let j=0;j<vregs.length;j++)
					swap(array,vregs[j],vregs[j]);
				multiSwap(array,pos,vregs[digit-1]);
				for(let j=digit-1;j>0;j--)
					write(vregs,j-1,vregs[j-1]-1,true);
			}
		}
	}
	return[5,1]
}
function swaplessPushSort(){
	let array=[...arr];
	let as=1,i,f=1;
	while(as){
		as=0;
		if(f>1)i=f-1;
		else i=1;
		let g=1;
		while(i+g<=len){
			if(compareIndices(array,i-1,i-1+g)>0){
				if(!as)f=i;
				insertTo(array,i-1+g,i-1);
				g++;as=1
			}else i++;
		}
	}
	return[5,1]
}
function reboundSort(){
	let array=[...arr];
	let st=0,s=0;
	for(let d=1;!s;d*=-1){
		let i=d==1||!st?0:len-2;
		st=1;s=1;
		for(;i>=0&&i<len-1;i+=d)
			if(compareIndices(array,i,i+1)>0){
				swap(array,i,i+1,0,s=0);
				d=-d;
			}
	}
	return[5,1]
}
function rubbleSort(){
	let array=[...arr];
	const sig=(a,b,d)=>((a+d)+d*abs(a-b))/2|0;
	function run(a,s,e){
		if(s>=e-1)return s+1;
		let c=-compareIndices(a,s++,s)|1,k=s-1,d;
		do d=compareIndices(a,s++,s);while(s<e&&d!=c);
		let m=(s-k)/2|0,q=sig(k,s-1,-c);
		for(let i=0;i<m;i++)swap(a,k+i,q+c*i);
		return s;
	}
	let runs=new Array(len/2|0+1);
	let rf=0,r=0;
	while(r<len)write(runs,rf++,(r=run(array,r,len))-1,true);
	function cf(ar,rs,rf){
		for(let i=2;i<rf;i++){
			if(compareIndices(ar,rs[i-1],rs[i])>0){
				let t=ar[rs[i-1]],temp=rs[i-1]-1;
				while(temp>=(i-2<0?0:rs[i-2]+1)){
					if(compareIndices(ar,temp,rs[i])<1)break;
					write(ar,temp+1,ar[temp--],true);
				}
				write(ar,temp+1,ar[rs[i]],true);
				write(ar,rs[i],t,true);
			}
		}
	}
	while(rf>1){
		customFunc(cf,[[...runs],rf])
		cf(array,[...runs],rf)
		if(runs[rf-1]==runs[rf-2])write(runs,--rf,0,true);
		else write(runs,rf-1,runs[rf-1]-1,true);
	}
	binDoubleInsert(array,0,len)
	arraycopy([...arr].sort((a,b)=>a-b),0,array,0,len)
	return[5,1]
}
function searchSort(){
	let array=[...arr];
	const bs=(a,b,c,v)=>{
		while(b<c){
			let m=b+((c-b)/2)|0;
			if(compareValues(v,a[m])<0)c=m;
			else b=m+1;
		}
		return b;
	}
	let i=0;
	while(i+1<len){
		let ver=1;
		while(i+1<len&&ver){
			if(compareIndices(array,i,i+1)<1)i++;
			else ver=0;
		}
		if(i+1<len)swap(array,i+1,bs(array,0,i,array[i+1]));
	}
	return[5,1]
}
function selectionSort(){
	let array=[...arr];
	for(let i=0;i<len-1;i++){
		let l=i;
		for(let j=i+1;j<len;j++)
			if(compareIndices(array,j,l)==-1)
				l=j;
		swap(array,i,l);
	}
	return[5,1]
}
function iterativeShircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(ishsr(array,n));
	return[5,1]
}
function recursiveShircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rshsr(array,0,n-1,0));
	return[5,1]
}
function XSort(){
	let array=[...arr];
	let gap=len;
	function cf(ar,g,l){
		let as=0
		for(let i=1;i-1+g<l;i++){
			if(compareIndices(ar,i-1,i-1+g)>0){
				swap(ar,i-1,i-1+g,true);
				as=true;
				let xf=i+1;
				let xright=i+g-1;
				if(g!=1){
					for(let r=0;r<g-1;r++){
						if(compareIndices(ar,xf-1,xright-1)>0)
							swap(ar,xf-1,xright-1,1);
						xf++;xright--;
					}
				}
			}
		}
		return[g,as]
	}
	let as=0;
	while(1){
		[gap,as]=cf(array,gap,len)
		customFunc(cf,[gap,len])
		if(!as){
			if(gap==1)break;
			else gap--;
		}
	}
	return[5,1]
}
function blockShellSort(){
	let array=[...arr];
	function gappedBinary(A,P,l,K,G,i){
		let L=-1,R=l,C,M;
		while(L<R-1){
			M=L+((R-L)>>1);
			C=compareIndices(A,P+M*G,K);
			if(C==1||(i&&C==0))R=M;
			else L=M;
		}
		return R;
	}
	function GSFW(A,P,L,G){
		let t=A[P];
		for(let i=0;i<L;i++)write(A,P+i*G,A[P+(i+1)*G]);
		write(A,P+L*G,t);
	}
	function GSBW(A,P,L,G){
		let t=A[P+L*G];
		for(let i=L;i>0;i--)write(A,P+i*G,A[P+(i-1)*G]);
		write(A,P,t);
	}
	function GMSFW(A,lA,lB,L,G){
		for(let i=0;i<L;i++)swap(A,lA+i*G,lB+i*G);
	}
	function GMSBW(A,lA,lB,L,G){
		for(let i=0;i<L;i++)swap(A,lA+i*G,lB+i*G);
	}
	function rotate(A,P,L,R,G){
		while(L>1&&R>1){
			if(L<=R){
				GMSFW(A,P,P+L*G,L,G);
				P+=L*G;
				R-=L;
			}else{
				GMSBW(A,P+(L-R)*G,P+L*G,R,G);
				L-=R;
			}
		}
		if(L>0&&R>0){
			if(L==1)GSFW(A,P,R,G);
			else if(R==1)GSBW(A,P,L,G);
		}
	}
	function merge(array,P,L0,L1,G){
		let S;
		if(L0<L1){
			while(L0!=0){
				S=gappedBinary(array,P+L0*G,L1,P,G,true);
				if(S!=0){
					rotate(array,P,L0,S,G);
					P+=S*G;
					L1-=S;
				}
				if(L1==0)break;
				do{P+=G;L0--;}while(L0!=0&&compareIndices(array,P,P+L0*G)<1);
			}
		}else{
			while(L1!=0){
				S=gappedBinary(array,P,L0,P+(L0+L1-1)*G,G,false);
				if(S!=L0){
					rotate(array,P+S*G,L0-S,L1,G);
					L0=S;
				}
				if(L0==0)break;
				do L1--;while(L1!=0&&compareIndices(array,P+(L0-1)*G,P+(L0+L1-1)*G)<1);
			}
		}
	}
	function gappedReverse(a,s,e,g){
		for(;s<=e-g;s+=g,e-=g)swap(a,s,e);
	}
	function getRun(array,start,end,gap){
		let t=start,iD=-compareIndices(array,start,start+gap),len=1;
		if(end-start<gap)return 1;
		if(iD==0)iD=1;
		do{len++;start+=gap;}while(start<=end-gap&&compareIndices(array,start,start+gap)!=iD);
		if(iD==-1)gappedReverse(array,t,start,gap);
		return len;
	}
	let gaps=[1,4,10,23,57,132,301,701];
	function ciura(n){
		if(n<=gaps.length)return gaps[n-1];
		return pow(2.25,n)|0;
	}
	function shellPass(array,start,end,gap){
		if(end-start<gap)return;
		let done,starts=new Array(gap),lens=new Array(gap),ends=new Array(gap);
		for(let i=0;i<gap;i++){
			starts[i]=start+i;
			lens[i]=0;
			ends[i]=(end-(end%gap))+i;
			if(ends[i]>=end)
				ends[i]-=gap;
		}
		do{
			done=true;
			for(let i=0;i<gap;i++){
				let v=starts[i]+lens[i]*gap;
				if(v>ends[i]||ends[i]==-1)continue;
				done=false;
				let r=getRun(array,v,ends[i],gap);
				merge(array,starts[i],lens[i],r,gap);
				write(lens,i,lens[i]+r,true);
			}
		}while(!done);
	}
	let k=1;
	while(ciura(k++)<len);
	while(--k>1)shellPass(array,0,len,ciura(k-1));
	return[5,1]
}
function rotateMSDRadixSort(){
	let array=[...arr];
	function shift(n,q){
		while(q>0){
			n/=base;q--;
		}
		return n|0;
	}
	function ms(ar,a,b,l){
		for(let i=0;i<l;i++)
			swap(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				ms(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				ms(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function bs(ar,a,b,d,p){
		while(a<b){
			let m=(a+b)/2|0;
			if(getDigit(ar[m],p,base)>=d)b=m;
			else a=m+1;
		}
		return a;
	}
	function merge(ar,a,m,b,da,db,p){
		if(b-a<2||db-da<2)return;
		let dm=(da+db)/2|0;
		let m1=bs(ar,a,m,dm,p);
		let m2=bs(ar,m,b,dm,p);
		rot(ar,m1,m,m2);
		m=m1+(m2-m);
		merge(ar,m,m2,b,dm,db,p);
		merge(ar,a,m1,m,da,dm,p);
	}
	function mrs(ar,a,b,p){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		mrs(ar,a,m,p);
		mrs(ar,m,b,p);
		merge(ar,a,m,b,0,base,p);
	}
	function d(ar,a,b,p){
		mrs(ar,a,b,p);
		return bs(ar,a,b,1,p);
	}
	let base=4;
	let q=maxLog(array,len,base);
	let m=0,i=0,b=len;
	while(i<len){
		let p=b-i<1?i:d(array,i,b,q);
		if(q==0){
			m+=base;
			let t=m/base;
			while(t%base==0){
				t/=base;
				q++;
			}
			i=b;
			while(b<len&&shift(array[b],q+1)==shift(m,q+1))b++;
		}else{
			b=p;q--;
		}
	}
	return[5,1]
}
function recursivePairwiseSort(){
	let array=[...arr];
	function psr(ar,s,e,g){
		if(s==e-g)return;
		let a=1,b=s+g;
		while(b<e){
			if(compareIndices(ar,b-g,b)>0)
				swap(ar,b-g,b);
			b+=2*g;
		}
		if(((e-s)/g)%2==0){
			psr(ar,s,e,g*2);
			psr(ar,s+g,e+g,g*2);
		}else{
			psr(ar,s,e+g,g*2);
			psr(ar,s+g,e,g*2);
		}
		while(a<((e-s)/g))a=a*2+1;
		b=s+g;
		while(b+g<e){
			let c=a;
			while(c>1){
				c/=2;c|=0;
				if(b+c*g<e)
					if(compareIndices(ar,b,b+c*g)>0)
						swap(ar,b,b+c*g);
			}
			b+=2*g;
		}
	}
	psr(array,0,len,1);
	return[5,1]
}
function flashSort(){
	let array=[...arr];
	function sort(array,len){
		let m=(.2*len)+2|0,min,max,mi;
		min=max=array[0];
		mi=0;
		for(let i=1;i<len-1;i+=2){
			let small,big,bi;
			if(compareIndices(array,i,i+1)<0){
				small=array[i];
				big=array[i+1];
				bi=i+1;
			}else{
				big=array[i];
				bi=i;
				small=array[i+1];
			}
			if(big>max){
				max=big;
				mi=bi;
			}
			if(small<min)min=small;
		}
		if(compareValues(array[len-1],min)<0)min=array[len-1];
		else if(compareValues(array[len-1],max)>0){
			max=array[len-1];
			mi=len-1;
		}
		if(max==min)return;
		let L=new Array(m+1);
		for(let t=1;t<=m;t++)write(L,t,0,true)
		let c=(m-1)/(max-min);
		let K;
		for(let h=0;h<len;h++){
			K=((array[h]-min)*c)+1|0;
			write(L,K,L[K]+1,true);
		}
		for(K=2;K<=m;K++)write(L,K,L[K]+L[K-1],true);
		swap(array,mi,0);
		let j=0;
		K=m;
		let moves=0;
		while(moves<len){
			while(j>=L[K]){
				j++;
				K=((array[j]-min)*c)+1|0;
			}
			let evicted=array[j];
			while(j<L[K]){
				K=((evicted-min)*c)+1|0;
				let loc=L[K]-1;
				let temp=array[loc];
				write(array,loc,evicted);
				evicted=temp;
				write(L,K,L[K]-1,true);
				moves++;
			}
		}
		insertSort(array,0,len);
	}
	sort(array,len)
	return[5,1]
}
function americanFlagSort(){
	let array=[...arr];
	let base=(len/4|0)+1;
	function gmnod(a,l){
		let m=-1/0,t=0;
		for(let i=0;i<l;i++){
			t=log(a[i])/log(base)+1;
			if(t>m)m=t;
		}
		return m|0;
	}
	const getd=(i,d)=>(i/d|0)%base;
	function sort(a,s,e,dv){
		let cnt=new Array(base),offset=new Array(base),digit=0;
		for(let i=s;i<e;i++){
			let d=a[i];
			digit=getd(d,dv);
			write(cnt,digit,cnt[digit]+1,true);
		}
		write(offset,0,s,true);
		for(let i=1;i<base;i++)write(offset,i,cnt[i-1]+offset[i-1],true);
		for(let b=0;b<base;b++){
			while(cnt[b]>0){
				let origin=offset[b],fr=origin,num=a[fr];
				a[fr]=-1
				do{
					digit=getd(num,dv);
					let to=offset[digit];
					write(offset,digit,offset[digit]+1,true);
					write(cnt,digit,cnt[digit]-1,true);
					let temp=a[to];
					write(a,to,num);
					num=temp;fr=to;
				}while(fr!=origin);
			}
		}
		if(dv>1){
			for(let i=0;i<base;i++){
				let begin=(i>0)?offset[i-1]:s;
				let end=offset[i];
				if(end-begin>1)sort(a,begin,end,dv/base|0);
			}
		}
	}
	let nod=gmnod(array,len);
	let max=1;
	for(let i=0;i<nod-1;i++)max*=base;
	sort(array,0,len,max);
	insertSort(array,0,len)
	return[5,1]
}
function classic3SmoothCombSort(){
	let array=[...arr];
	const i3s=n=>{
		while(n%6==0)n/=6;
		while(n%3==0)n/=3;
		while(n%2==0)n/=2;
		return n==1;
	}
	for(let g=len-1;g>0;g--)
		if(i3s(g))
			for(let i=g;i<len;i++)
				if(compareIndices(array,i-g,i)>0)
					swap(array,i-g,i);
	return[5,1];
}
function iterative3SmoothCombSort(){
	let array=[...arr];
	let pow2=log(len-1)/log(2)|0;
	for(let k=pow2;k>=0;k--){
		let pow3=(log(len)-k*log(2))/log(3)|0;
		for(let j=pow3;j>=0;j--){
			let gap=pow(2,k)*pow(3,j)|0;
			for(let i=0;i+gap<len;i++)
				if(compareIndices(array,i,i+gap)>0)
					swap(array,i,i+gap)
		}
	}
	return[5,1]
}
function recursive3SmoothCombSort(){
	let array=[...arr];
	function rc(a,p,g,e){
		if(p+g>e)return;
		rc(a,p,g*2,e);
		rc(a,p+g,g*2,e);
		pot(a,p,g,e);
	}
	function pot(a,p,g,e){
		if(p+g>e)return;
		pot(a,p,g*3,e);
		pot(a,p+g,g*3,e);
		pot(a,p+2*g,g*3,e);
		for(let i=p;i+g<e;i+=g)
			if(compareIndices(a,i,i+g)>0)
				swap(array,i,i+g);
	}
	rc(array,0,1,len);
	return[5,1]
}
function binaryDoubleInsertionSort(){
	let array=[...arr];
	binDoubleInsert(array,0,len)
	return[5,1]
}
function ectaSort(){
	let array=[...arr];
	const gmr=(n)=>{
		let mr=n;
		for(;mr>=32;mr=(mr+1)/2);
		return mr|0;
	}
	function shift(ar,a,m,b){
		while(m<b)write(ar,a++,ar[m++]);
	}
	function shiftBW(ar,a,m,b){
		while(m>a)write(ar,--b,ar[--m]);
	}
	function mergeTo(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<1)write(ar,p++,ar[i++]);
			else write(ar,p++,ar[j++]);
		}
		while(i<m)write(ar,p++,ar[i++]);
		while(j<b)write(ar,p++,ar[j++]);
	}
	function ppm(ar,a,m1,m2,m3,b,p){
		let p1=p+m2-a,pE=p+b-a;
		mergeTo(ar,a,m1,m2,p);
		mergeTo(ar,m2,m3,b,p1);
		mergeTo(ar,p,p1,pE,a);
	}
	function merge(ar,a,m,b,p){
		let l=b-m,pE=p+l-1;
		arraycopy(ar,m--,ar,p,l);
		while(m>=a&&pE>=p){
			if(compareIndices(ar,m,pE)>0)write(ar,--b,ar[m--]);
			else write(ar,--b,ar[pE--]);
		}
		while(pE>=p)write(ar,--b,ar[pE--]);
	}
	function mergeFromBuf(ar,buf,a,m,b,bfL){
		let i=0;
		while(i<bfL&&m<b){
			if(compareValues(buf[i],ar[m])<1)write(ar,a++,buf[i++]);
			else write(ar,a++,ar[m++]);
		}
		while(i<bfL)write(ar,a++,buf[i++]);
	}
	function dlMrFromBufBW(ar,buf,a,a1,m,b,bfL){
		let i=bfL-1;
		bfL-=b-(m--);
		while(i>=bfL&&m>=a1){
			if(compareValues(buf[i],ar[m])>0)write(ar,--b,buf[i--]);
			else write(ar,--b,ar[m--]);
		}
		if(m<a1)while(i>=0)write(ar,--b,buf[i--]);
		else mergeFromBuf(ar,buf,a,a1,b,bfL);
	}
	function mrs(ar,a,b,p,mRun,bfL){
		let i=a,j=mRun;
		for(;i+j<=b;i+=j)binDoubleInsert(ar,i,i+j);
		binDoubleInsert(ar,i,b);
		while(4*j<=bfL){
			for(i=a;i+4*j<=b;i+=4*j)ppm(ar,i,i+j,i+2*j,i+3*j,i+4*j,p);
			if(i+3*j<b)ppm(ar,i,i+j,i+2*j,i+3*j,b,p);
			else if(i+2*j<b)ppm(ar,i,i+j,i+2*j,b,b,p);
			else if(i+j<b)merge(ar,i,i+j,b,p);
			j*=4;
		}
		while(j<=bfL){
			for(i=a;i+2*j<=b;i+=2*j)merge(ar,i,i+j,i+2*j,p);
			if(i+j<b)merge(ar,i,i+j,b,p);
			j*=2;
		}
		return j;
	}
	function blC(ar,keys,a,bL,t,p,excl,fw){
		let s=fw?bL:-bL;
		for(let i=0;i<t;i++){
			if(compareValues(i,keys[i])!=0){
				arraycopy(ar,a+i*s,ar,p,bL);
				let j=i,next=keys[i];
				do{
					if(!(excl&&j==t-1))arraycopy(ar,a+next*s,ar,a+j*s,bL);
					write(keys,j,j,true);
					j=next;
					next=keys[next];
				}while(compareValues(next,i)!=0);
				arraycopy(ar,p,ar,a+j*s,bL);
				write(keys,j,j,true);
			}
		}
	}
	function ectaMergeFW(ar,tags,a,m,b,bL){
		let i=a,j=m,t=0,tc=0,s=[2*bL,0],p=[a-2*bL,m];
		do{
			let c=s[0]<bL?1:0;
			for(let k=0;k<bL;k++){
				if(i<m&&j<b){
					if(compareIndices(ar,i,j)<1){
						write(ar,p[c]+k,ar[i++]);
						s[0]++;
					}else{
						write(ar,p[c]+k,ar[j++]);
						s[1]++;
					}
				}else if(i<m){
					write(ar,p[c]+k,ar[i++]);
					s[0]++;
				}else{
					write(ar,p[c]+k,ar[j++]);
					s[1]++;
				}
			}
			p[c]+=bL;s[c]-=bL;
			write(tags,tc++,c==0?t++:-1,true);
		}while(i<m||j<b);
		if(s[0]>0)write(tags,tc,t++,true);
		for(let k=2;k<tc;k++)
			if(tags[k]==-1)write(tags,k,t++,true);
		blC(ar,tags,a-2*bL,bL,t,b-bL,s[0]>0,true);
	}
	function ectaMergeBW(ar,tags,a,m,b,bL){
		let i=b-1,j=m-1,t=0,tc=0,s=[2*bL,0],p=[b+2*bL,m];
		do{
			let c=s[0]<bL?1:0;
			for(let k=1;k<=bL;k++){
				if(i>=m&&j>=a){
					if(compareIndices(ar,i,j)>=0){
						write(ar,p[c]-k,ar[i--]);
						s[0]++;
					}else{
						write(ar,p[c]-k,ar[j--]);
						s[1]++;
					}
				}else if(i>=m){
					write(ar,p[c]-k,ar[i--]);
					s[0]++;
				}else{
					write(ar,p[c]-k,ar[j--]);
					s[1]++;
				}
			}
			p[c]-=bL;s[c]-=bL;
			write(tags,tc++,c==0?t++:-1,true);
		}while(i>=m||j>=a);
		if(s[0]>0)write(tags,tc,t++,true);
		for(let k=2;k<tc;k++)
			if(tags[k]==-1)write(tags,k,t++,true);
		blC(ar,tags,b+bL,bL,t,a,s[0]>0,false);
	}
	if(len<256){
		if(len<=32)binDoubleInsert(array,0,len);
		else{
			let mRun=gmr(len),bfL=len/2|0;
			let buf=new Array(bfL);
			arraycopy(array,bfL,buf,0,bfL,true);
			mrs(array,0,bfL,bfL,mRun,bfL);
			arraycopy(buf,0,array,bfL,bfL);
			arraycopy(array,0,buf,0,bfL,true);
			mrs(array,bfL,len,0,mRun,bfL);
			mergeFromBuf(array,buf,0,bfL,len,bfL);
		}
	}else{
		let mRun=gmr(len),bL=mRun;
		for(;bL*bL<len/2;bL*=2);
		let bfL=2*bL+len%bL,a=bfL,b=len,l=b-a,buf=new Array(bfL),tags=new Array(l/bL+1|0);
		arraycopy(array,a,buf,0,bfL,true);
		mrs(array,0,a,a,gmr(bfL),bfL);
		arraycopy(buf,0,array,a,bfL);
		arraycopy(array,0,buf,0,bfL,true);
		let i=a,j=mrs(array,a,b,0,mRun,bfL),bw=false;
		while(j<l){
			for(i=a;i+2*j<=b;i+=2*j)
				ectaMergeFW(array,tags,i,i+j,i+2*j,bL);
			if(i+j<b)ectaMergeFW(array,tags,i,i+j,b,bL);
			else shift(array,i-2*bL,i,b);
			j*=2;
			a-=2*bL;
			b-=2*bL;
			if(j>=l){
				bw=true;
				break;
			}
			for(i=a;i+2*j<=b;i+=2*j);
			if(i+j<b)ectaMergeBW(array,tags,i,i+j,b,bL);
			else shiftBW(array,i,b,b+2*bL);
			for(i-=2*j;i>=a;i-=2*j)
				ectaMergeBW(array,tags,i,i+j,i+2*j,bL);
			j*=2;
			a+=2*bL;
			b+=2*bL;
		}
		if(bw)dlMrFromBufBW(array,buf,0,a,b,len,bfL);
		else mergeFromBuf(array,buf,0,a,b,bfL);
	}
	return[15,1];
}
function flanSort(){
	let array=[...arr];
	let G=14,R=4,mwms=new MWMS();
	function mot(ar,a,m,b){
		if(compareIndices(ar,m,a)>0){
			if(compareIndices(ar,m,b)<0)return m;
			if(compareIndices(ar,a,b)>0)return a;
			else return b;
		}else{
			if(compareIndices(ar,m,b)>0)return m;
			if(compareIndices(ar,a,b)<0)return a;
			else return b;
		}
	}
	function ninther(ar,a,b){
		let s=(b-a)/9|0;
		let a1=mot(ar,a,a+s,a+2*s);
		let m1=mot(ar,a+3*s,a+4*s,a+5*s);
		let b1=mot(ar,a+6*s,a+7*s,a+8*s);
		return mot(ar,a1,m1,b1);
	}
	function motn(ar,a,b){
		let s=(b-a)/3|0;
		let a1=ninther(ar,a,a+s);
		let m1=ninther(ar,a+s,a+2*s);
		let b1=ninther(ar,a+2*s,b);
		return mot(ar,a1,m1,b1);
	}
	function shiftBW(ar,a,m,b){
		while(m>a)swap(ar,--b,--m);
	}
	function lbls(ar,a,b,v){
		let s=G+1;
		while(a<b){
			let m=a+(((b-a)/s|0)/2|0)*s;
			if(compareValues(v,ar[m])<1)b=m;
			else a=m+s;
		}
		return a;
	}
	function rbls(ar,a,b,v){
		let s=G+1;
		while(a<b){
			let m=a+(((b-a)/s|0)/2|0)*s;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+s;
		}
		return a;
	}
	function rbs(ar,a,b,v,bw){
		let cmp=bw?1:-1;
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])==cmp)b=m;
			else a=m+1;
		}
		return a;
	}
	function insto(ar,t,a,b){
		while(a>b)write(ar,a,ar[--a]);
		write(ar,b,t);
	}
	function bininsert(ar,a,b){
		for(let i=a+1;i<b;i++)
			insto(ar,ar[i],i,rbs(ar,a,i,ar[i]));
	}
	function kWayMerge(ar,heap,pa,s,b,p,sz){
		if(sz<2){
			if(sz==1)while(pa[0]<b)swap(ar,p++,pa[0]++);
			return;
		}
		let a=pa[0];
		for(let i=0;i<sz;i++)write(heap,i,i,true);
		for(let i=(sz-1)/2|0;i>=0;i--)mwms.siftDown(ar,heap,pa,heap[i],i,sz);
		while(sz>0){
			let min=heap[0];
			swap(ar,p++,pa[min]);
			write(pa,min,pa[min]+1,true);
			if(pa[min]==minVal(a+(min+1)*s,b))mwms.siftDown(ar,heap,pa,heap[--sz],0,sz);
			else mwms.siftDown(ar,heap,pa,heap[0],0,sz);
		}
	}
	function retrieve(ar,i,p,pE,bsv,bw){
		let j=i-1,m;
		for(let k=pE-(G+1);k>p+G;){
			m=rbs(ar,k-G,k,bsv,bw)-1;
			k-=G+1;
			while(m>=k)swap(ar,j--,m--);
		}
		m=rbs(ar,p,p+G,bsv,bw)-1;
		while(m>=p)swap(ar,j--,m--);
	}
	function lib(ar,a,b,p,bsv,bw){
		let l=b-a;
		if(l<32){
			bininsert(ar,a,b);
			return;
		}
		let s=l;
		while(s>=32)s=(s-1)/R+1|0;
		let i=a+s,j=a+R*s,pE=p+(s+1)*(G+1)+G;
		bininsert(ar,a,i);
		for(let k=0;k<s;k++)
			swap(ar,a+k,p+k*(G+1)+G);
		while(i<b){
			if(i==j){
				retrieve(ar,i,p,pE,bsv,bw);
				s=i-a;
				pE=p+(s+1)*(G+1)+G;
				j=a+(j-a)*R;
				for(let k=0;k<s;k++)
					swap(ar,a+k,p+k*(G+1)+G);
			}
			let bLoc=lbls(ar,p+G,pE-(G+1),ar[i]);
			if(compareIndices(ar,i,bLoc)==0){
				let eqEnd=rbls(ar,bLoc+(G+1),pE-(G+1),ar[i]);
				bLoc+=(random()*((eqEnd-bLoc)/(G+1)|0)|0)*(G+1);
			}
			let loc=rbs(ar,bLoc-G,bLoc,bsv,bw);
			if(loc==bLoc){
				do bLoc+=G+1;while(bLoc<pE&&rbs(ar,bLoc-G,bLoc,bsv,bw)==bLoc);
				if(bLoc==pE){
					retrieve(ar,i,p,pE,bsv,bw);
					s=i-a;
					pE=p+(s+1)*(G+1)+G;
					j=a+(j-a)*R;
					for(let k=0;k<s;k++)swap(ar,a+k,p+k*(G+1)+G);
				}else{
					let rotP=rbs(ar,bLoc-G,bLoc,bsv,bw);
					let rotS=bLoc-maxVal(rotP,bLoc-G/2|0);
					shiftBW(ar,loc-rotS,bLoc-rotS,bLoc);
				}
			}else{
				let t=ar[i];
				write(ar,i++,ar[loc]);
				insto(ar,t,loc,rbs(ar,bLoc-G,loc,t,false));
			}
		}
		retrieve(ar,b,p,pE,bsv,bw);
	}
	let pa=new Array(G+2);
	let heap=new Array(G+2);
	let a=0,b=len;
	while(b-a>=32){
		let piv=array[motn(array,a,b)];
		let i1=a,i=a-1,j=b,j1=b;
		for(;;){
			while(++i<j){
				let cmp=compareValues(array[i],piv);
				if(cmp==0)swap(array,i1++,i);
				else if(cmp<0)break;
			}
			while(--j>i){
				let cmp=compareValues(array[j],piv);
				if(cmp==0)swap(array,--j1,j);
				else if(cmp>0)break;
			}
			if(i<j)swap(array,i,j);
			else{
				if(i1==b)return;
				else if(j<i)j++;
				while(i1>a)swap(array,--i,--i1);
				while(j1<b)swap(array,j++,j1++);
				break;
			}
		}
		let f=i-a,right=b-j,m,kCnt=0;
		if(f<=right){
			m=b-f;
			f=maxVal((right+1)/(G+1),16)|0;
			for(let k=a;k<i;k+=f){
				lib(array,k,minVal(k+f,i),j,piv,true);
				write(pa,kCnt++,k,true);
			}
			kWayMerge(array,heap,pa,f,i,m,kCnt);
			if(j-i<m-j){
				while(i<j)swap(array,i++,--m);
				b=m;
			}else{
				while(m>j)swap(array,i++,--m);
				b=i;
			}
		}else{
			m=a+right;
			right=maxVal((f+1)/(G+1),16)|0;
			for(let k=j;k<b;k+=right){
				lib(array,k,minVal(k+right,b),a,piv,false);
				write(pa,kCnt++,k,true);
			}
			kWayMerge(array,heap,pa,right,b,a,kCnt);
			if(i-m<j-i){
				while(m<i)swap(array,m++,--j);
				a=j;
			}else{
				while(j>i)swap(array,m++,--j);
				a=m;
			}
		}
	}
	bininsert(array,a,b);
	return[5,1]
}
function circularGrailSort(){
	let array=[...arr];
	const csw=(ar,a,b)=>swap(ar,a%n,b%n);
	const cci=(ar,a,b)=>compareIndices(ar,a%n,b%n);
	const sFW=(ar,a,m,b)=>{while(m<b)csw(ar,a++,m++)}
	const sBW=(ar,a,m,b)=>{while(m>a)csw(ar,--b,--m)}
	function ins(ar,a,b){
		for(let i=a+1;i<b;i++)
			while(i>a&&cci(ar,i-1,i)>0)
				csw(ar,i,--i);
	}
	function msw(ar,a,b,l){
		for(let i=0;i<l;i++)
			csw(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				msw(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function ipm(ar,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(cci(ar,i,j)>0){
				k=j;
				while(++k<b&&cci(ar,i,k)>0);
				rot(ar,i,j,k);
				i+=k-j;j=k;
			}else i++;
		}
	}
	function merge(ar,p,a,m,b,f){
		let i=a,j=m;
		while(i<m&&j<b){
			if(cci(ar,i,j)<=0)csw(ar,p++,i++);
			else csw(ar,p++,j++);
		}
		if(i<m){
			if(i>p)sFW(ar,p,i,m);
		}else if(f)sFW(ar,p,j,b);
		return i<m?i:j;
	}
	function blt(ar,a,b,bl){
		let c=cci(ar,a,b);
		return c==-1||(c==0&&cci(ar,a+bl-1,b+bl-1)==-1);
	}
	function bmr(ar,a,m,b,bL){
		let b1=b-(b-m-1)%bL-1|0;
		if(b1>m){
			let b2=b1;
			for(let i=m-bL;i>a&&blt(ar,b1,i,bL);i-=bL,b2-=bL);
			for(let j=a;j<b1-bL;j+=bL){
				let min=j;
				for(let i=min+bL;i<b1;i+=bL)
					if(blt(ar,i,min,bL))min=i;
				if(min!=j)msw(ar,j,min,bL);
			}
			let f=a;
			for(let i=a+bL;i<b2;i+=bL){
				f=merge(ar,f-bL,f,i,i+bL,false);
				if(f<i){
					sBW(ar,f,i,i+bL);
					f+=bL;
				}
			}
			merge(ar,f-bL,f,b1,b,true);
		}else merge(ar,a-bL,a,m,b,true);
	}
	let n=len;
	if(len<=16)ins(array,0,len);
	else{
		let bL=1;
		for(;bL*bL<len;bL*=2);
		let i=bL,j=1,l=len-i,b=len;
		while(j<=bL){
			for(;i+2*j<b;i+=2*j)merge(array,i-j,i,i+j,i+2*j,true);
			if(i+j<b)merge(array,i-j,i,i+j,b,true);
			else sFW(array,i-j,i,b);
			i=b+bL-j;b=i+l;j*=2;
		}
		while(j<l){
			for(;i+2*j<b;i+=2*j)bmr(array,i,i+j,i+2*j,bL);
			if(i+j<b)bmr(array,i,i+j,b,bL);
			else sFW(array,i-bL,i,b);
			i=b;b+=l;j*=2;
		}
		ins(array,i-bL,i);
		ipm(array,i-bL,i,b);
		rot(array,0,(i-bL)%n,len);
	}
	return[5,1]
}
function poplarHeapSort(){
	let array=[...arr];
	const hf=n=>pow(2,floor(log(n)/log(2)));
	function uis(ar,f,l){
		for(let i=f+1;i!=l;++i){
			let s=i,s1=i-1;
			if(compareIndices(ar,s,s1)<0){
				let t=ar[s];
				do write(ar,s,ar[s1]);while(--s!=f&&compareValues(t,ar[--s1])<0);
				write(ar,s,t);
			}
		}
	}
	function ins(ar,f,l){
		if(f==l)return;
		uis(ar,f,l);
	}
	function sift(ar,f,sz){
		if(sz<2)return;
		let rt=f+sz-1,cr1=rt-1,cr2=f+(sz/2-1)|0;
		while(1){
			let mr=rt;
			if(compareIndices(ar,mr,cr1)<0)mr=cr1;
			if(compareIndices(ar,mr,cr2)<0)mr=cr2;
			if(mr==rt)return;
			swap(ar,rt,mr);
			sz/=2;
			if(sz<2)return;
			rt=mr;cr1=rt-1;cr2=mr-sz/2|0;
		}
	}
	function phws(ar,f,l,sz){
		let prs=hf(sz+1)-1,lrt=l-1,bg=lrt,bgs=prs,it=f;
		while(1){
			let rt=it+prs-1;
			if(rt==lrt)break;
			if(compareIndices(ar,bg,rt)<0){
				bg=rt;bgs=prs;
			}
			it=rt+1;sz-=prs;prs=hf(sz+1)-1;
		}
		if(bg!=lrt){
			swap(ar,bg,lrt);
			sift(ar,bg-(bgs-1),bgs);
		}
	}
	function mkhp(ar,f,l){
		let sz=l-f;
		if(sz<2)return;
		let sps=15;
		if(sz<=sps)return uis(ar,f,l);
		let prl=1,it=f,nx=it+sps;
		while(1){
			uis(ar,it,nx);
			let prs=sps;
			for(let i=(prl&(-prl))>>1;i!=0;i>>=1){
				it-=prs;prs=2*prs+1;
				sift(ar,it,prs);
				++nx;
			}
			if((l-nx)<=sps)return ins(ar,nx,l);
			it=nx;nx+=sps;
			++prl;
		}
	}
	function shp(ar,f,l){
		let sz=l-f;
		if(sz<2)return;
		do phws(ar,f,l--,sz--);while(sz>1);
	}
	function hs(a,s,e){
		mkhp(a,s,e);
		shp(a,s,e);
	}
	hs(array,0,len);
	return[5,1]
}
function adaptiveGrailSort(){
	let array=[...arr];
	const subarray={LEFT:"L",RIGHT:"R"}
	let minRun;
	const msw=(ar,a,b,l)=>{
		for(let i=0;i<l;i++)swap(ar,a+i,b+i);
	}
	const mts=(ar,a,b,c,l)=>{
		for(let i=0;i<l;i++){
			let t=ar[a+i];
			write(ar,a+i,ar[b+i]);
			write(ar,b+i,ar[c+i]);
			write(ar,c+i,t);
		}
	}
	function insto(ar,a,b){
		let t=ar[a];
		while(a>b)write(ar,a,ar[(a--)-1]);
		write(ar,b,t);
	}
	function instoBW(ar,a,b){
		let t=ar[a];
		while(a<b)write(ar,a,ar[(a++)+1]);
		write(ar,a,t);
	}
	function shft(ar,a,m,b){
		while(m<b)swap(ar,a++,m++);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>1&&r>1){
			if(r<l){
				msw(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
		if(r==1)insto(ar,m,a);
		else if(l==1)instoBW(ar,a,b-1);
	}
	function lbs(ar,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	function rbs(ar,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function burn(ar,a,n){
		let nk=1,i=a+1;
		if(compareIndices(ar,i-1,i)<0){
			i++;nk++;
			while(nk<n&&compareIndices(ar,i-1,i)<0){
				i++;nk++;
			}
		}else if(compareIndices(ar,i-1,i)>0){
			i++;nk++;
			while(nk<n&&compareIndices(ar,i-1,i)>0){
				i++;nk++;
			}
			reversal(ar,a,i-1,0);
		}
		return nk;
	}
	function burnBW(ar,b,n){
		let nk=1,i=b-1;
		if(compareIndices(ar,i-1,i)<0){
			i--;nk++;
			while(nk<n&&compareIndices(ar,i-1,i)<0){
				i--;nk++;
			}
		}else if(compareIndices(ar,i-1,i)>0){
			i--;nk++;
			while(nk<n&&compareIndices(ar,i-1,i)>0){
				i--;nk++;
			}
			reversal(ar,i,b-1,0);
		}
		return nk;
	}
	function fkys(ar,a,b,nk,n){
		let p=a,pE=a+nk;
		for(let i=pE;i<b&&nk<n;i++){
			let loc=lbs(ar,p,pE,ar[i]);
			if(pE==loc||compareIndices(ar,i,loc)!=0){
				rot(ar,p,pE,i);
				let inc=i-pE;
				loc+=inc;p+=inc;pE+=inc;
				insto(ar,pE,loc);
				nk++;pE++;
			}
		}
		rot(ar,a,p,pE);
		return nk;
	}
	function fkysBW(ar,a,b,nk,n){
		let p=b-nk,pE=b;
		for(let i=p-1;i>=a&&nk<n;i--){
			let loc=lbs(ar,p,pE,ar[i]);
			if(pE==loc||compareIndices(ar,i,loc)!=0){
				rot(ar,i+1,p,pE);
				let inc=p-(i+1);
				loc-=inc;pE-=inc;p-=inc+1;nk++;
				instoBW(ar,i,loc-1);
			}
		}
		rot(ar,p,pE,b);
		return nk;
	}
	function buildRuns(ar,a,b){
		let i=a+1,j=a;
		while(i<b){
			if(compareIndices(ar,i-1,i++)==1){
				while(i<b&&compareIndices(ar,i-1,i)==1)i++;
				reversal(ar,j,i-1,0);
			}else while(i<b&&compareIndices(ar,i-1,i)<1)i++;
			if(i<b)j=i-(i-j-1)%minRun-1;
			while(i-j<minRun&&i<b)
				insto(ar,i,rbs(ar,j,i,ar[i++]));
			j=i++;
		}
	}
	function binins(ar,a,b){
		for(let i=a+1;i<b;i++)insto(ar,i,rbs(ar,a,i,ar[i]));
	}
	function mwbr(ar,a,m,b,p,pL){
		let i=0,j=m,k=a;
		while(i<pL&&j<b){
			if(compareIndices(ar,p+i,j)<1)swap(ar,k++,p+(i++));
			else swap(ar,k++,j++);
		}
		while(i<pL)swap(ar,k++,p+(i++));
	}
	function mwb(ar,a,m,b,p){
		let l=m-a;
		msw(ar,p,a,l);
		mwbr(ar,a,m,b,p,l);
	}
	function mwbBW(ar,a,m,b,p){
		let pL=b-m;
		msw(ar,m,p,pL);
		let i=pL-1,j=m-1,k=b-1;
		while(i>=0&&j>=a){
			if(compareIndices(ar,p+i,j)>=0)swap(ar,k--,p+(i--));
			else swap(ar,k--,j--);
		}
		while(i>=0)swap(ar,k--,p+(i--));
	}
	function ipm(ar,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(compareIndices(ar,i,j)>0){
				k=lbs(ar,j+1,b,ar[i]);
				rot(ar,i,j,k);
				i+=k-j;j=k;
			}else i++;
		}
	}
	function ipmBW(ar,a,m,b){
		let i=m-1,j=b-1,k;
		while(j>i&&i>=a){
			if(compareIndices(ar,i,j)>0){
				k=rbs(ar,a,i,ar[j]);
				rot(ar,k,i+1,j+1);
				j-=(i+1)-k;i=k-1;
			}else j--;
		}
	}
	function mwob(ar,a,m,b){
		if(m-a>b-m)ipmBW(ar,a,m,b);
		else ipm(ar,a,m,b);
	}
	const csrt=(ar,a,m,b)=>compareIndices(ar,m-1,m)>0;
	function ckrbd(ar,a,m,b){
		if(compareIndices(ar,a,b-1)>0){
			rot(ar,a,m,b);
			return false;
		}
		return true;
	}
	const ckbd=(ar,a,m,b)=>csrt(ar,a,m,b)&&ckrbd(ar,a,m,b);
	const grlgetsub=(a,t,m)=>compareIndices(a,t,m)<0?subarray.LEFT:subarray.RIGHT;
	function blslsrt(ar,p,t,r,d,lCount,bCount,bL){
		let mKey=lCount;
		for(let j=0,k=lCount+1;j<k-1;j++){
			let min=j;
			for(let i=maxVal(lCount-r,j+1);i<k;i++){
				let cmp=compareIndices(ar,p+d+i*bL,p+d+min*bL);
				if(cmp<0||(cmp==0&&compareIndices(ar,t+i,t+min)<0))min=i;
			}
			if(min!=j){
				msw(ar,p+j*bL,p+min*bL,bL);
				swap(ar,t+j,t+min);
				if(k<bCount&&min==k-1)k++;
			}
			if(min==mKey)mKey=j;
		}
		return t+mKey;
	}
	function grlsrtkys(ar,b,p,mKey){
		swap(ar,p,mKey);
		let i=mKey,j=i+1,k=p+1;
		while(j<b){
			if(compareIndices(ar,j,p)<0)swap(ar,i++,j);
			else swap(ar,k++,j);
			j++;
		}
		msw(ar,i,p,b-i);
	}
	function grlsrtkyswob(ar,b,mKey){
		let i=mKey,j=i+1;
		while(j<b){
			if(compareIndices(ar,j,i)<0)insto(ar,j,i++);
			j++;
		}
	}
	function grlmbl(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<1)swap(ar,p++,i++);
			else swap(ar,p++,j++);
		}
		if(i>p)while(i<m)swap(ar,p++,i++);
		return j;
	}
	function grlmblRev(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<0)swap(ar,p++,i++);
			else swap(ar,p++,j++);
		}
		if(i>p)while(i<m)swap(ar,p++,i++);
		return j;
	}
	function grlblm(ar,a,m,b,t,p,bL){
		let b1=b-(b-m-1)%bL-1,i=a+bL,j=a,key=t-1,lCount=(m-i)/bL|0,bCount=(b1-i)/bL|0,l=-1,r=lCount-1;
		mts(ar,p,m-bL,a,bL);
		instoBW(ar,t,t+lCount-1);
		let mKey=blslsrt(ar,i,t,1,bL-1,lCount,bCount,bL);
		let frag=subarray.LEFT;
		while(l<lCount&&r<bCount){
			if(frag==subarray.LEFT){
				do{j+=bL;l++;key++;}while(l<lCount&&grlgetsub(ar,key,mKey)==subarray.LEFT);
				if(l==lCount){
					i=grlmbl(ar,i,j,b,i-bL);
					mwbr(ar,i-bL,i,b,p,bL);
				}else i=grlmbl(ar,i,j,j+bL-1,i-bL);
				frag=subarray.RIGHT;
			}else{
				do{j+=bL;r++;key++;}while(r<bCount&&grlgetsub(ar,key,mKey)==subarray.RIGHT);
				if(r==bCount){
					shft(ar,i-bL,i,b);
					msw(ar,p,b-bL,bL);
				}else i=grlmblRev(ar,i,j,j+bL-1,i-bL);
				frag=subarray.LEFT;
			}
		}
		grlsrtkys(ar,t+bCount,p,mKey);
	}
	function grlblmwob(ar,a,m,b,t,bL){
		let a1=a+(m-a)%bL,b1=b-(b-m)%bL,i=a,j=a1,key=t,lCount=(m-j)/bL+1|0,bCount=(b1-j)/bL+1|0,l=0,r=lCount;
		let mKey=blslsrt(ar,j,t,0,0,lCount-1,bCount-1,bL);
		let frag=subarray.LEFT;
		while(l<lCount&&r<bCount){
			let next=grlgetsub(ar,key++,mKey);
			if(next==frag){
				if(frag==subarray.LEFT)l++;
				else r++;
				i=j;
			}else{
				let m2=j,b2=j+bL,k;
				if(frag==subarray.LEFT){
					while(i<m2&&m2<b2){
						if(compareIndices(ar,i,m2)>0){
							k=lbs(ar,m2+1,b2,ar[i]);
							rot(ar,i,m2,k);
							i+=k-m2;
							m2=k;
						}else i++;
					}
				}else{
					while(i<m2&&m2<b2){
						if(compareIndices(ar,i,m2)>=0){
							k=rbs(ar,m2+1,b2,ar[i]);
							rot(ar,i,m2,k);
							i+=k-m2;
							m2=k;
						}else i++;
					}
				}
				if(i<m2){
					if(next==subarray.LEFT)l++;
					else r++;
				}else{
					if(frag==subarray.LEFT)l++;
					else r++;
					frag=next;
				}
			}
			j+=bL;
		}
		if(l<lCount)ipmBW(ar,a,b1,b);
		grlsrtkyswob(ar,t+bCount-1,mKey);
	}
	function smtm(ar,a,m,b,p){
		if(ckbd(ar,a,m,b)){
			a=rbs(ar,a,m-1,ar[m]);
			mwb(ar,a,m,b,p);
		}
	}
	function smtmBW(ar,a,m,b,p){
		if(ckbd(ar,a,m,b)){
			b=lbs(ar,m+1,b,ar[m-1]);
			mwbBW(ar,a,m,b,p);
		}
	}
	function smtblm(ar,a,m,b,t,p,bL){
		if(ckbd(ar,a,m,b)){
			let n=rbs(ar,a,m-1,ar[m]);
			b=lbs(ar,m+1,b,ar[m-1]);
			if(ckrbd(ar,n,m,b)){
				if(m-n<=bL||b-m<=bL){
					if(b-m<m-n)mwbBW(ar,n,m,b,p);
					else mwb(ar,n,m,b,p);
				}else{
					n-=(n-a)%bL;
					grlblm(ar,n,m,b,t,p,bL);
				}
			}
		}
	}
	function smtblmwob(ar,a,m,b,t,bL){
		if(ckbd(ar,a,m,b)){
			a=rbs(ar,a,m-1,ar[m]);
			if(m-a<=bL)ipm(ar,a,m,b);
			else grlblmwob(ar,a,m,b,t,bL);
		}
	}
	function smtipm(ar,a,m,b){
		if(csrt(ar,a,m,b))ipmBW(ar,a,m,b);
	}
	function rbuf(ar,a,m,b){
		let rPos=lbs(ar,m,b,ar[a]);
		rot(ar,a,m,rPos);
		let d=rPos-m;
		a+=d;
		m+=d;
		let a1=a+(m-a)/2|0;
		rPos=lbs(ar,m,b,ar[a1]);
		rot(ar,a1,m,rPos);
		d=rPos-m;
		a1+=d;
		m+=d;
		mwob(ar,a,a1-d,a1);
		mwob(ar,a1,m,b);
	}
	function rbufBW(ar,a,m,b){
		let rPos=rbs(ar,a,m,ar[b-1]);
		rot(ar,rPos,m,b);
		let d=m-rPos;
		b-=d;
		m-=d;
		let b1=m+(b-m)/2|0;
		rPos=rbs(ar,a,m,ar[b1-1]);
		rot(ar,rPos,m,b1);
		d=m-rPos;
		b1-=d;
		m-=d;
		mwob(ar,b1,b1+d,b);
		mwob(ar,a,m,b1);
	}
	function ipms(ar,a,b){
		buildRuns(ar,a,b);
		let l=b-a;
		for(let i,j=minRun;j<l;j*=2){
			for(i=a;i+2*j<=b;i+=2*j)smtipm(ar,i,i+j,i+2*j);
			if(i+j<b)smtipm(ar,i,i+j,b);
		}
	}
	function grladswob(ar,a,b,keys,ideal,bwBuf){
		let l=b-a,bL;
		for(bL=minVal(keys,minRun);2*bL<=keys;bL*=2);
		let tLen=keys-bL;
		let i,j=minRun,t,p,a1,b1;
		if(bwBuf){
			p=b-bL;a1=a;b1=p-tLen;t=b1;
		}else{
			p=a+tLen;a1=p+bL;b1=b;t=a;
		}
		buildRuns(ar,a1,b1);
		while(j<=bL&&j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtm(ar,i,i+j,i+2*j,p);
			if(i+j<b1)
				smtmBW(ar,i,i+j,b1,p);
			j*=2;
		}
		if(bL/2>=minRun&&bL/2>=(keys+1)/2){
			binins(ar,p,p+bL|0);
			bL/=2;
			tLen=keys-bL|0;
			p+=bL|0;
		}
		bL|=0
		while(tLen>=2*j/bL-1&&j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtblm(ar,i,i+j,i+2*j,t,p,bL);
			if(i+j<b1){
				if(b1-(i+j)>bL)smtblm(ar,i,i+j,b1,t,p,bL);
				else smtmBW(ar,i,i+j,b1,p);
			}
			j*=2;
		}
		binins(ar,p,p+bL);
		tLen=keys-keys%2;
		while(j<l){
			bL=2*j/tLen;
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtblmwob(ar,i,i+j,i+2*j,t,bL);
			if(i+j<b1){
				if(b1-(i+j)>bL)smtblmwob(ar,i,i+j,b1,t,bL);
				else smtipm(ar,i,i+j,b1);
			}
			j*=2;
		}
		if(bwBuf){
			a=rbs(ar,a,b1,ar[b1]);
			if(keys>=ideal/2)rbufBW(ar,a,b1,b);
			else mwob(ar,a,b1,b);
		}else{
			b=lbs(ar,a1,b,ar[a1-1]);
			if(keys>=ideal/2)rbuf(ar,a,a1,b);
			else mwob(ar,a,a1,b);
		}
	}
	function grlasd(ar,a,b){
		let l=b-a;
		if(l<31)return binins(ar,a,b);
		if(l<63){
			minRun=(l+1)/2|0;
			buildRuns(ar,a,b);
			let m=a+minRun;
			if(ckbd(ar,a,m,b))rbufBW(ar,a,m,b);
			return;
		}
		for(minRun=l;minRun>=32;minRun=(minRun+1)/2);
		minRun|=0;
		let bL;
		for(bL=minRun;bL*bL<l;bL*=2);
		let tLen=l/bL-2,ideal=tLen+bL,bwBuf,rRun=burnBW(ar,b,ideal),lRun=0;
		if(rRun==ideal)bwBuf=true;
		else{
			lRun=burn(ar,a,ideal);
			if(lRun==ideal)bwBuf=false;
			else bwBuf=(rRun<16&&lRun<16)||rRun>=lRun;
		}
		let keys=bwBuf?fkysBW(ar,a,b,rRun,ideal):fkys(ar,a,b,lRun,ideal);
		if(keys<ideal){
			if(keys==1)return;
			else if(keys<=4)ipmSort(ar,a,b);
			else grladswob(ar,a,b,keys,ideal,bwBuf);
			return;
		}
		let i,j=minRun,t,p,a1,b1;
		if(bwBuf){p=b-bL;a1=a;b1=p-tLen;t=b1;
		}else{p=a+tLen;a1=p+bL;b1=b;t=a;}
		buildRuns(ar,a1,b1);
		while(j<=bL&&j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)smtm(ar,i,i+j,i+2*j,p);
			if(i+j<b1)smtmBW(ar,i,i+j,b1,p);
			j*=2;
		}
		while(j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)smtblm(ar,i,i+j,i+2*j,t,p,bL);
			if(i+j<b1){
				if(b1-(i+j)>bL)smtblm(ar,i,i+j,b1,t,p,bL);
				else smtmBW(ar,i,i+j,b1,p);
			}
			j*=2;
		}
		binins(ar,p,p+bL);
		if(bwBuf){
			a=rbs(ar,a,b1,ar[b1]);
			rbufBW(ar,a,b1,b);
		}else{
			b=lbs(ar,a1,b,ar[a1-1]);
			rbuf(ar,a,a1,b);
		}
	}
	grlasd(array,0,len);
	return[5,1]
}
function introSort(){
	let array=[...arr];
	const flbt=a=>floor(log(a)/log(2));
	function gm3(ar,a,m,b){
		if(compareIndices(ar,a,m)<0){
			if(compareIndices(ar,m,b)<0)swap(ar,a,m);
			else if(compareIndices(ar,a,b)<0)swap(ar,a,b);
		}else if(compareIndices(ar,a,b)<0)return ar[a];
		else if(compareIndices(ar,m,b)<0)swap(ar,a,b);
		else swap(ar,a,m);
		return ar[a];
	}
	function m3(ar,a,m,b){
		if(compareIndices(ar,b,a)<0)swap(ar,a,b);
		if(compareIndices(ar,m,b)<0)swap(ar,m,a);
		if(compareIndices(ar,b,m)<0)swap(ar,b,m);
		return ar[m];
	}
	function par(a,lo,hi,x){
		let i=lo,j=hi;
		while(1){
			while(compareValues(a[i],x)<0)i++;
			do j--;while(compareValues(x,a[j])<0);
			if(i>=j)return i;
			swap(a,i++,j);
		}
	}
	function sort(a,lo,hi,d){
		while(hi-lo>16){
			if(d==0)return heapSort(a,lo,hi,true);
			let p=par(a,lo,hi,m3(a,lo,lo+(hi-lo)/2|0,hi-1));
			sort(a,p,hi,--d);
			hi=p;
		}
	}
	sort(array,0,len,2*flbt(len));
	insertSort(array,0,len);
	return[5,1]
}
function triangularHeapSort(){
	let array=[...arr];
	const trt=v=>sqrt((8*v+1)-1)/2|0;
	function sd(a,e,r){
		let t=a[r],ln=trt(r),l=r+ln+1,ri=l+1;
		while(l<e){
			if(ri>=e){
				if(compareValues(a[l],t)>0)write(a,r,a[l]);
				break;
			}
			let mx=compareIndices(a,l,ri)>=0?l:ri;
			if(compareValues(a[mx],t)>0){
				write(a,r,a[mx]);
				r=mx;ln=trt(r);l=r+ln+1;ri=l+1;
				continue;
			}
			break;
		}
		write(a,r,t);
	}
	function trheap(a,l){
		for(let i=l-1;i>=0;i--)sd(a,l,i);
	}
	trheap(array,len);
	for(let i=1;i<len-1;i++){ 
		swap(array,0,len-i);
		sd(array,len-i,0);
	}
	if(compareIndices(array,0,1)>0)swap(array,0,1);
	return[5,1]
}
function laziestStableSort(){
	let array=[...arr];
	const insto=(ar,a,b)=>{
		let t=ar[a];
		while(a>b)write(ar,a,ar[--a]);
		write(ar,b,t);
	}
	const msw=(ar,a,b,l)=>{
		for(let i=0;i<l;i++)
			swap(ar,a+i,b+i);
	}
	const rot=(ar,a,m,b)=>{
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				msw(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	const lbs=(ar,a,b,v)=>{
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	const rbs=(ar,a,b,v)=>{
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	const les=(ar,a,b,v)=>{
		let i=1;
		while(a-1+i<b&&compareValues(v,ar[a-1+i])>0)i*=2;
		return lbs(ar,a+i/2|0,minVal(b,a-1+i),v);
	}
	const binsert=(ar,a,b)=>{
		for(let i=a+1;i<b;i++)
			insto(ar,i,rbs(ar,a,i,ar[i]));
	}
	const ipm=(ar,a,m,b)=>{
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(compareIndices(ar,i,j)>0){
				k=les(ar,j+1,b,ar[i]);
				rot(ar,i,j,k);
				i+=k-j;j=k;
			}else i++;
		}
	}
	let l=len;
	if(l<=16)binsert(array,0,len);
	else{
		let i,bL=maxVal(16,sqrt(l)|0);
		for(i=0;i+2*bL<len;i+=bL)
			binsert(array,i,i+bL);
		binsert(array,i,len);
		while(i-bL>=0){
			ipm(array,i-bL,i,len);
			i-=bL;
		}
	}
	return[5,1]
}
function lazierestSort(){
	let array=[...arr];
	const cc=n=>{
		let a=0,b=minVal(1291,n);
		while(a<b){
			let m=(a+b)/2|0;
			if(m*m*m>=n)b=m;
			else a=m+1;
		}
		return a;
	}
	function insto(ar,a,b){
		let t=ar[a];
		while(a>b)write(ar,a,ar[--a]);
		write(ar,b,t);
	}
	function ms(ar,a,b,l){
		for(let i=0;i<l;i++)
			swap(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				ms(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				ms(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function lbs(ar,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	function rbs(ar,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function les(ar,a,b,v){
		let i=1;
		while(a-1+i<b&&compareValues(v,ar[a-1+i])>0)i*=2;
		return lbs(ar,a+i/2|0,minVal(b,a-1+i),v);
	}
	function res(ar,a,b,v){
		let i=1;
		while(b-i>=a&&compareValues(v,ar[b-i])<0)i*=2;
		return rbs(ar,maxVal(a,b-i+1),b-i/2|0,v);
	}
	function binsert(ar,a,b){
		for(let i=a+1;i<b;i++)
			insto(ar,i,rbs(ar,a,i,ar[i]));
	}
	function ipmFW(ar,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(compareIndices(ar,i,j)>0){
				k=les(ar,j+1,b,ar[i]);
				IndexRots.cycleReverse(ar,i,j,k,false);
				i+=k-j;j=k;
			}else i++;
		}
	}
	function ipmBW(ar,a,m,b){
		let i=m-1,j=b-1,k;
		while(j>i&&i>=a){
			if(compareIndices(ar,i,j)>0){
				k=res(ar,a,i,ar[j]);
				rot(ar,k,i+1,j+1);
				j-=i+1-k;i=k-1;
			}else j--;
		}
	}
	function ipm(ar,a,m,b){
		if(b-m<m-a)ipmBW(ar,a,m,b);
		else ipmFW(ar,a,m,b);
	}
	function fm(ar,a,m,b,s){
		let i=a+(m-a)%s;
		while(i<m){
			let j=les(ar,m,b,ar[i]);
			IndexRots.cycleReverse(ar,i,m,j,false);
			let rLen=j-m;
			j=i;i+=rLen;m+=rLen;
			ipm(ar,a,j,i);
			a=i;i+=s;
		}
		ipm(ar,maxVal(a,i-s),i,b);
	}
	function lss(ar,a,b){
		let l=b-a,s=cc(l),s1=s*s;
		for(let i=l%s;i<=b;i+=s)binsert(ar,maxVal(a,i-s),i);
		for(let i=b-s,j=b;i>a;i-=s){
			if(j-i==s1){j-=s1;i-=s;}
			ipmFW(ar,maxVal(a,i-s),i,j);
		}
		for(let i=b-s1;i>a;i-=s1)fm(ar,maxVal(a,i-s1),i,b,s);
	}
	if(len<=16)binsert(array,0,len);
	else lss(array,0,len);
	return[5,1]
}
function binaryQuickSort(){
	let array=[...arr];
	function bqsr(a,p,r,b){
		if(p>=r||b<0)return;
		let q=par(a,p,r,b--);
		bqsr(a,p,q,b);
		bqsr(a,q+1,r,b);
	}
	function par(a,p,r,b){
		let i=p-1,j=r+1;
		while(1){
			do i++;while(i<=r&&!getBit(a[i],b));
			do j--;while(j>=p&&getBit(a[j],b));
			if(i<j)swap(a,i,j);
			else return j;
		}
	}
	let msb=analyzeBit(array,len);
	bqsr(array,0,len-1,msb);
	return[5,1]
}
function staticSort(){
	let array=[...arr];
	function mnmx(ar,a,b){
		let mn=ar[a],mx=mn;
		for(let i=a+1;i<b;i++){
			if(compareValues(ar[i],mn)<0)mn=ar[i];
			else if(compareValues(ar[i],mx)>0)mx=ar[i];
		}
		return[mn,mx];
	}
	function sts(ar,a,b){
		let mmx=mnmx(ar,a,b);
		let aul=b-a;
		let cn=new Array(aul+1).fill(0),ofs=new Array(aul+1).fill(0);
		let C=aul/(mmx[1]-mmx[0]+1);
		let idx;
		for(let i=a;i<b;i++){
			idx=((ar[i]-mmx[0])*C)|0;
			write(cn,idx,cn[idx]+1,true);
		}
		write(ofs,0,a,true);
		for(let i=1;i<aul;i++)write(ofs,i,cn[i-1]+ofs[i-1],true);
		for(let v=0;v<aul;v++){
			while(cn[v]>0){
				let og=ofs[v],fr=og,n=ar[fr];
				do{
					idx=((n-mmx[0])*C)|0;
					let t=ofs[idx];
					write(ofs,idx,ofs[idx]+1,true);
					write(cn,idx,cn[idx]-1,true);
					let tm=ar[t];
					write(ar,t,n);
					n=tm;
					fr=t;
				}while(fr!=og);
			}
		}
		for(let i=0;i<aul;i++){
			let s=(i>1)?ofs[i-1]:a,
				e=ofs[i];
			if(e-s<=1)continue;
			if(e-s>16)heapSort(ar,s,e,true);
			else insertSort(ar,s,e);
		}
	}
	sts(array,0,len);
	return[5,1]
}
function binaryGnomeSort(){
	let array=[...arr];
	for(let i=1;i<len;i++){
		let n=array[i],lo=0,hi=i;
		while(lo<hi){
			let m=lo+((hi-lo)/2)|0;
			if(compareValues(n,array[m])<0)hi=m;
			else lo=m+1;
		}
		let j=i;
		while(j>lo)swap(array,j,--j);
	}
	return[5,1]
}
function dualPivotQuickSort(){
	let array=[...arr];
	function dpqs(ar,lf,ri,dv){
		let ln=ri-lf;
		if(ln<4)return insertSort(ar,lf,ri+1);
		let th=ln/dv|0,m1=lf+th,m2=ri-th;
		if(m1<=lf)m1=lf+1;
		if(m2>=ri)m2=ri-1;
		if(compareIndices(ar,m1,m2)<0){
			swap(ar,m1,lf);
			swap(ar,m2,ri);
		}else{
			swap(ar,m1,ri);
			swap(ar,m2,lf);
		}
		let p1=ar[lf],p2=ar[ri],ls=lf+1,gr=ri-1;
		for(let k=ls;k<=gr;k++){
			if(compareValues(ar[k],p1)<0)swap(ar,k,ls++);
			else if(compareValues(ar[k],p2)>0){
				while(k<gr&&compareValues(ar[gr],p2)>0)gr--;
				swap(ar,k,gr--);
				if(compareValues(ar[k],p1)<0)swap(ar,k,ls++);
			}
		}
		let ds=gr-ls;
		if(ds<13)dv++;
		swap(ar,ls-1,lf);
		swap(ar,gr+1,ri);
		dpqs(ar,lf,ls-2,dv);
		if(p1<p2)dpqs(ar,ls,gr,dv);
		dpqs(ar,gr+2,ri,dv);
	}
	dpqs(array,0,len-1,3);
	return[5,1]
}
function shoveSort(){
	let array=[...arr];
	function cf(a,i,e){
		for(let k=i;k<e-1;k++)swap(a,k,k+1,true);
	}
	function ssr(a,s,e){
		for(let i=s;i<e-1;){
			if(compareIndices(a,i,i+1)>0){
				customFunc(cf,[i,e])
				cf(a,i,e)
				if(i>s)i--;
				continue;
			}
			i++
		}
	}	
	ssr(array,0,len);
	return[5,1]
}
function quadStoogeSort(){
	let array=[...arr];
	function qss(a,p,l){
		if(l>=2&&compareIndices(a,p,p+l-1)>0)swap(a,p,p+l-1);
		if(l<3)return;
		let l1=l/2|0,l2=(l+1)/2|0,l3=(l1+1)/2+(l2+1)/2|0;
		qss(a,p,l1);
		qss(a,p+l1,l2);
		qss(a,p+l1/2|0,l3);
		qss(a,p+l1,l2);
		qss(a,p,l1);
		if(l>3)qss(a,p+l1/2|0,l3);
	}
	qss(array,0,len);
	return[5,1]
}
function insertionSort(){
	let array=[...arr];
	insertSort(array,0,len)
	return[5,1]
}
function forcedStableQuickSort(){
	let array=[...arr];
	function mot(ar,k,a,b){
		let m=a+(b-1-a)/2|0;
		if(sc(ar,k,a,m))ss(ar,k,a,m);
		if(sc(ar,k,m,b-1)){
			ss(ar,k,m,b-1);
			if(sc(ar,k,a,m))return;
		}
		ss(ar,k,a,m);
	}
	const sc=(ar,k,a,b)=>{
		let c=compareIndices(ar,a,b);
		return c>0||(c==0&&compareIndices(k,a,b)>0);
	}
	function ss(ar,k,a,b){
		swap(ar,a,b);
		swap(k,a,b,true);
	}
	function par(ar,k,a,b,p){
		let i=a-1,j=b;
		while(1){
			do i++;while(i<j&&!sc(ar,k,i,p));
			do j--;while(j>=i&&sc(ar,k,j,p));
			if(i<j)ss(ar,k,i,j);
			else return j;
		}
	}
	function qks(ar,k,a,b){
		if(b-a<3){
			if(b-a==2&&sc(ar,k,a,a+1))ss(ar,k,a,a+1);
			return;
		}
		mot(ar,k,a,b);
		let p=par(ar,k,a+1,b,a);
		ss(ar,k,a,p);
		qks(ar,k,a,p);
		qks(ar,k,p+1,b);
	}
	let k=new Array(len);
	for(let i=0;i<len;i++)write(k,i,i,true);
	qks(array,k,0,len);
	return[5,1]
}
function optimizedStoogeSortStudio(){
	let array=[...arr];
	const cs=(ar,a,b)=>{
		if(compareIndices(ar,a,b)>0){
			swap(ar,a,b);
			return true;
		}
		return false;
	}
	function sss(ar,a,m,b,mr){
		if(a>=m)return false;
		if(b-a==2)return cs(ar,a,m);
		let lc=false,rc=false,a2=(a+a+b)/3|0,b2=(a+b+b+2)/3|0;
		if(m<b2){
			lc=sss(ar,a,m,b2,mr);
			if(mr){
				rc=sss(ar,maxVal(a+b2-m,a2),b2,b,true);
				if(rc)sss(ar,a+b2-m,a2,2*a2-a,true);
			}else{
				rc=sss(ar,a2,b2,b,false);
				if(rc)sss(ar,a,a2,2*a2-a,true);
			}
		}else{
			rc=sss(ar,a2,m,b,mr);
			if(rc)sss(ar,a,a2,a2+b-m,true);
		}
		return lc||rc;
	}
	sss(array,0,1,len,false);
	return[5,1]
}
function swaplessBubbleSort(){
	let array=[...arr];
	let ls;
	for(let i=len;i>0;i=ls){
		ls=0;
		let p=0,c=array[0];
		for(let j=1;j<i;j++){
			if(compareValues(c,array[j])>0){
				write(array,j-1,array[j]);
				ls=j;
			}else{
				if(p+1<j)write(array,j-1,c);
				p=j;
				c=array[j];
			}
		}
		write(array,i-1,c);
	}
	return[5,1]
}
function gravitySort(){
	let array=[...arr];
	let aux=new Array(len)
	arraycopy([...arr].sort((a,b)=>a-b),0,aux,0,len,true)
	function cf(a,x,i){
		for(let j=0;j<len;j++){
			if(j<i){
				if(j%10==0)swap(a,i,i)
				if(compareValues(a[j],x[i])>=0)write(a,j,x[i],true);
			}
		}
		for(let j=len-1;j>=i;j--){
			if(compareValues(a[j],x[j])<0)write(a,j,a[j]+1,true)
			if(compareValues(a[j],x[j])>0)write(a,j,a[j]-1,true)
		}
	}
	for(let i=len-1;i>=0;i--){
		if(isSorted(array))break;
		cf(array,aux,i)
		customFunc(cf,[aux,i])
	}
	return[5,1]
}
function tableSort(){
	let array=[...arr];
	const sc=(ar,t,a,b)=>{
		let c=compareIndices(ar,t[a],t[b]);
		return c>0||(c==0&&compareIndices(t,a,b)>0);
	}
	function mot(ar,t,a,b){
		let m=a+(b-1-a)/2|0;
		if(sc(ar,t,a,m))swap(t,a,m,true);
		if(sc(ar,t,m,b-1)){
			swap(t,m,b-1,true);
			if(sc(ar,t,a,m))return;
		}
		swap(t,a,m,true);
	}
	function par(ar,t,a,b,p){
		let i=a-1,j=b;
		swap(ar,p,p)
		while(1){
			do i++;while(i<j&&!sc(ar,t,i,p));
			do j--;while(j>=i&&sc(ar,t,j,p));
			if(i<j){swap(t,i,j,true);swap(ar,i,i)}
			else return j;
		}
	}
	function qs(ar,t,a,b){
		if(b-a<3){
			if(b-a==2&&sc(ar,t,a,a+1))swap(t,a,a+1,true);
			return;
		}
		mot(ar,t,a,b);
		let p=par(ar,t,a+1,b,a);
		swap(t,a,p,true);
		qs(ar,t,a,p);
		qs(ar,t,p+1,b);
	}
	let tb=new Array(len);
	for(let i=0;i<len;i++)write(tb,i,i,true);
	qs(array,tb,0,len);
	for(let i=0;i<tb.length;i++){
		if(compareValues(i,tb[i])!=0){
			let t=array[i],j=i,nx=tb[i];
			do{
				write(array,j,array[nx]);
				write(tb,j,j,true);
				j=nx;
				nx=tb[nx];
			}
			while(compareValues(nx,i)!=0);
			write(array,j,t);
			write(tb,j,j,true);
		}
	}
	return[5,1]
}
function binaryMergeSort(){
	let array=[...arr];
	mergeSortTemp(array,len,true)
	return[5,1]
}
function bufferPartitionMergeSort(){
	let array=[...arr];
	const shiftBW=(a,b,m,c)=>{
		while(m>b)swap(a,--c,--m);
	}
	const msw=(ar,a,b,c)=>{
		for(let i=0;i<c;i++)
			swap(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				msw(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function ipm(ar,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(compareIndices(ar,i,j)>0){
				k=j;
				while(++k<b&&compareIndices(ar,i,k)>0);
				rot(ar,i,j,k);
				i+=k-j;j=k;
			}else i++;
		}
	}
	function mot(ar,a,b){
		let m=a+(b-1-a)/2|0;
		if(compareIndices(ar,a,m)>0)swap(ar,a,m);
		if(compareIndices(ar,m,b-1)>0){
			swap(ar,m,b-1);
			if(compareIndices(ar,a,m)>0)return;
		}
		swap(ar,a,m);
	}
	function mofm(ar,a,b,s){
		let e=b,st=a,i,j,ad=true;
		while(e-st>1){
			j=st;
			for(i=st;i+2*s<=e;i+=s){
				insSort(ar,i,i+s);
				swap(ar,j++,i+s/2|0);
			}
			if(i<e){
				insSort(ar,i,e);
				swap(ar,j++,i+(e-(ad?1:0)-i)/2|0);
				if((e-i)%2==0)ad=!ad;
			}
			e=j;
		}
	}
	function par(ar,a,b){
		let i=a,j=b;
		while(1){
			do i++;while(i<j&&compareIndices(ar,i,a)>0);
			do j--;while(j>=i&&compareIndices(ar,j,a)<0);
			if(i<j)swap(ar,i,j);
			else return j;
		}
	}
	function qsel(ar,a,b,m){
		let bp=false,mom=false,m1=(m+b+1)/2|0;
		while(1){
			if(bp){
				mofm(ar,a,b,5);
				mom=true;
			}else mot(ar,a,b);
			let p=par(ar,a,b);
			swap(ar,a,p);
			let l=maxVal(1,p-a),r=maxVal(1,b-(p+1));
			bp=!mom&&(l/r>=16||r/l>=16);
			if(p>=m&&p<m1)return p;
			else if(p<m)a=p+1;
			else b=p;
		}
	}
	function merge(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<1)swap(ar,p++,i++);
			else swap(ar,p++,j++);
		}
		while(i<m)swap(ar,p++,i++);
		while(j<b)swap(ar,p++,j++);
	}
	function mergeFW(ar,p,a,m,b){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<1)swap(ar,p++,i++);
			else swap(ar,p++,j++);
		}
		return i<m?i:j
	}
	const gml=n=>{
		while(n>=32)n=(n+3)/4;
		return n|0;
	}
	function mrs(ar,a,b,p){
		let l=b-a;
		if(l<2)return;
		let i,ps,j=gml(l);
		for(i=a;i+j<=b;i+=j)binInsSort(ar,i,i+j);
		binInsSort(ar,i,b);
		while(j<l){
			ps=p;
			for(i=a;i+2*j<=b;i+=2*j,ps+=2*j)merge(ar,i,i+j,i+2*j,ps);
			if(i+j<b)merge(ar,i,i+j,b,ps);
			else while(i<b)swap(ar,i++,ps++);
			j*=2;
			ps=a;
			for(i=p;i+2*j<=p+l;i+=2*j,ps+=2*j)merge(ar,i,i+j,i+2*j,ps);
			if(i+j<p+l)merge(ar,i,i+j,p+l,ps);
			else while(i<p+l)swap(ar,i++,ps++);
			j*=2;
		}
	}
	function sort(ar,a,b){
		let minLvl=sqrt(b-a)|0;
		let m=(a+b+1)/2|0;
		mrs(ar,m,b,a);
		while(m-a>minLvl){
			let m1=(a+m+1)/2|0;
			m1=qsel(ar,a,m,m1);
			mrs(ar,m1,m,a);
			let bSize=m1-a,m2=minVal(m1+bSize,b);
			m1=mergeFW(ar,a,m1,m,m2);
			while(m1<m){
				shiftBW(ar,m1,m,m2);
				m1=m2-(m-m1);a=m1-bSize;m=m2;
				if(m==b)break;
				m2=minVal(m2+bSize,b);
				m1=mergeFW(ar,a,m1,m,m2);
			}
			m=m1;a=m1-bSize;
		}
		binInsSort(ar,a,m);
		ipm(ar,a,m,b);
	}
	let insSort=insertSort,binInsSort=binInsertSort
	sort(array,0,len);
	return[5,1]
}
function binaryInsertionSort(){
	let array=[...arr];
	binInsertSort(array,0,len)
	return[5,1]
}
function fifthMergeSort(){
	let array=[...arr];
	class IndexPair{
		constructor(a,b){this.aE=a;this.bE=b;}
	}
	function ipmFW(a,b,s,m,e){
		let l=s,r=m;
		while(l<m&&r<e){
			if(compareIndices(a,l,r)<1)write(a,b++,a[l++]);
			else write(a,b++,a[r++]);
		}
		while(l<m)write(a,b++,a[l++]);
		while(r<e)write(a,b++,a[r++]);
	}
	function ipmBW(a,b,bl,m,e){
		let l=m-1,r=e-1;
		while(b>r&&r>=m){
			if(compareIndices(a,l,r)>0)write(a,b--,a[l--]);
			else write(a,b--,a[r--]);
		}
		if(r==l)while(r>=0)write(a,b--,a[r--]);
		else if(r<m)while(l>=0)write(a,b--,a[l--]);
		return new IndexPair(l+1,r+1);
	}
	function mwbFW(a,b,d,l,le,m,e){
		let r=m;
		while(l<le&&r<e){
			if(compareValues(b[l],a[r])<1)write(a,d++,b[l++]);
			else write(a,d++,a[r++]);
		}
		while(l<le)write(a,d++,b[l++]);
	}
	function merge(a,b,cs,s,m,e,fb){
		let f,t,p;
		if(fb){f=b;t=a;p=s;s-=cs;m-=cs;e-=cs;
		}else{f=a;t=b;p=s-cs;}
		let l=s,r=m;
		while(l<m&&r<e){
			if(compareIndices(f,l,r)<1)write(t,p++,f[l++],!fb);
			else write(t,p++,f[r++],!fb);
		}
		while(l<m)write(t,p++,f[l++],!fb);
		while(r<e)write(t,p++,f[r++],!fb);
	}
	function pp(a,b,s,e){
		let i;
		for(i=s;i+8<e;i+=8)binInsertSort(a,i,i+8);
		if(e-i>1)binInsertSort(a,i,e);
		let ln=e-s,fb=false;
		for(let g=8;g<ln;g*=2,fb=!fb){
			let fm=g*2;
			for(i=s;i+fm<e;i+=fm)merge(a,b,s,i,i+g,i+fm,fb);
			if(i+g<e)merge(a,b,s,i,i+g,e,fb);
			else{
				if(fb)arraycopy(b,i-s,a,i,e-i);
				else arraycopy(a,i,b,i-s,e-i,1);
			}
		}
		if(fb)arraycopy(b,0,a,s,ln);
	}
	let l5th=len/5|0,bl=len-l5th*4,b=new Array(bl),two5th=2*l5th;
	pp(array,b,0,bl);
	for(let i=0,s=bl;i<4;i++)pp(array,b,s,s+=l5th);
	arraycopy(array,0,b,0,bl,true);
	for(let i=0,s=bl;i<2;i++,s+=two5th)ipmFW(array,s-bl,s,s+l5th,s+two5th);
	let fm=ipmBW(array,len-1,bl,two5th,2*two5th);
	if(fm.bE>0)mwbFW(array,array,bl,0,fm.aE,two5th,len);
	mwbFW(array,b,0,0,bl,bl,len);
	return[5,1]
}
function chaliceSort(){
	let array=[...arr];
	const Bms=new BMS();
	function cCbr(n){
		let a=0,b=11;
		while(a<b){
			let m=(a+b)/2|0;
			if((1<<3*m)>=n)b=m;
			else a=m+1;
		}
		return 1<<a;
	}
	function cKy(bL,n){
		let a=1,b=n/4|0;
		while(a<b){
			let m=(a+b)/2|0;
			if((n-4*m-1)/bL-2|0<m)b=m;
			else a=m+1;
		}
		return a;
	}
	function lSrEx(ar,tmp,a,b){
		for(let i=a,s=tmp.length;i<b;i+=s){
			let j=minVal(b,i+s);
			Bms.binaryInsertion(ar,i,j);
			if(i>a)Bms.mergeBWExt(ar,tmp,a,i,j);
		}
	}
	function fKySM(ar,a,b,a1,b1,full,n){
		let p=a,pEnd=0;
		if(full){
			for(;p<b;p++){
				let loc=Bms.fBinSearch(ar,a1,b1,ar[p]);
				if(loc==b1||compareValues(ar[p],ar[loc])!=0){
					pEnd=p+1;
					break;
				}
			}
			if(pEnd!=0){
				for(let i=pEnd;i<b&&pEnd-p<n;i++){
					let loc=Bms.fBinSearch(ar,a1,b1,ar[i]);
					if(loc==b1||compareValues(ar[i],ar[loc])!=0){
						loc=Bms.fBinSearch(ar,p,pEnd,ar[i]);
						if(loc==pEnd||compareValues(ar[i],ar[loc])!=0){
							Bms.rotate(ar,p,pEnd,i);
							let len1=i-pEnd;
							p+=len1;loc+=len1;pEnd=i+1;
							Bms.insertTo(ar,i,loc);
						}
					}
				}
			}else pEnd=p;
		}else{
			pEnd=p+1;
			for(let i=pEnd;i<b&&pEnd-p<n;i++){
				let loc=Bms.fBinSearch(ar,p,pEnd,ar[i]);
				if(loc==pEnd||compareValues(ar[i],ar[loc])!=0){
					Bms.rotate(ar,p,pEnd,i);
					let len1=i-pEnd;
					p+=len1;loc+=len1;pEnd=i+1;
					Bms.insertTo(ar,i,loc);
				}
			}
		}
		return[p,pEnd];
	}
	function fKy(ar,tmp,a,b,n,s){
		let t=fKySM(ar,a,b,0,0,false,minVal(n,s)),p=t[0],pEnd=t[1];
		if(s<n&&pEnd-p==s){
			for(n-=s;;n-=s){
				t=fKySM(ar,pEnd,b,p,pEnd,true,minVal(s,n));
				let keys=t[1]-t[0];
				if(keys==0)break;
				if(keys<s||n==s){
					Bms.rotate(ar,pEnd,t[0],t[1]);
					t[0]=pEnd;pEnd+=keys;
					Bms.mergeBWExt(ar,tmp,p,t[0],pEnd);
					break;
				}else{
					Bms.rotate(ar,p,pEnd,t[0]);
					p+=t[0]-pEnd;pEnd=t[1];
					Bms.mergeBWExt(ar,tmp,p,t[0],pEnd);
				}
			}
		}
		Bms.rotate(ar,a,p,pEnd);
		return pEnd-p;
	}
	function fBtSM(ar,a,b,a1,bw,n){
		let p=a,pEnd,cmp=bw?-1:1;
		while(p<b&&compareIndices(ar,p,a1,1,true)!=cmp)p++;a1++;
		if(p<b){
			pEnd=p+1;
			for(let i=pEnd;i<b&&pEnd-p<n;i++){
				if(compareIndices(ar,i,a1,1,true)==cmp){
					Bms.rotate(ar,p,pEnd,i);
					p+=i-pEnd;pEnd=i+1;a1++;
				}
			}
		}else pEnd=p;
		return[p,pEnd];
	}
	function fBt(ar,tmp,a,b,n,s){
		lSrEx(ar,tmp,a,a+n);
		let a0=a,a1=a+n,c=0,c0=0;
		for(let i=0;c<n&&i<2;i++){
			let p=a1,pEnd=p;
			while(true){
				let t=fBtSM(ar,pEnd,b,a0,i==1,minVal(s,n-c)),bits=t[1]-t[0];
				if(bits==0)break;
				a0+=bits;c+=bits;
				if(bits<s||c==n){
					Bms.rotate(ar,pEnd,t[0],t[1]);
					t[0]=pEnd;pEnd+=bits;
					break;
				}else{
					Bms.rotate(ar,p,pEnd,t[0]);
					p+=t[0]-pEnd;pEnd=t[1];
				}
			}
			Bms.rotate(ar,a1,p,pEnd);
			a1+=pEnd-p;
			if(i==0)c0=c;
		}
		if(c<n)return-1;
		else{
			Bms.multiSwap(ar,a+c0,a+n+c0,n-c0);
			return c0;
		}
	}
	function BtRev(ar,a,b){
		let len=b-a,m=0,d1=len>>1,d2=d1+(d1>>1);
		for(let i=1;i<len-1;i++){
			let j=d1;
			for(let k=i,n=d2;(k&1)==0;j-=n,k>>=1,n>>=1);
			m+=j;
			if(m>i)swap(ar,a+i,a+m);
		}
	}
	function UnShuf(ar,a,b){
		let len=(b-a)>>1,c=0;
		for(let n=2;len>0;len>>=1,n*=2){
			if((len&1)==1){
				let a1=a+c;
				BtRev(ar,a1,a1+n);
				BtRev(ar,a1,a1+n/2|0);
				BtRev(ar,a1+n/2|0,a1+n);
				Bms.rotate(ar,a+c/2|0,a1,a1+n/2|0);
				c+=n;
			}
		}
	}
	function rdBuf(ar,tmp,a,m,b){
		let s=tmp.length;
		while(m-a>s&&m<b){
			let i=Bms.fBinSearch(ar,m,b,ar[a+s]);
			Bms.rotate(ar,a+s,m,i);
			let t=i-m;m=i;
			Bms.mergeFWExt(ar,tmp,a,a+s,m);
			a+=t+s;
		}
		if(m<b)Bms.mergeFWExt(ar,tmp,a,m,b);
	}
	function DlMrBW(ar,a,m,b,p){
		let i=m-1;b--;
		while(p>b+1&&b>=m){
			if(compareValues(ar[b],ar[i])>=0)swap(ar,--p,b--);
			else swap(ar,--p,i--);
		}
		if(b<m)Bms.shiftBW(ar,a,i+1,p);
		else{
			i++;b++;p=m-(i-a);
			while(a<i&&m<b){
				if(compareValues(ar[a],ar[m])<1)swap(ar,p++,a++);
				else swap(ar,p++,m++);
			}
			while(a<i)swap(ar,p++,a++);
		}
	}
	function DlMrBWExt(ar,a,m,b,p){
		let i=m-1;b--;
		while(p>b+1&&b>=m){
			if(compareValues(ar[b],ar[i])>=0)write(ar,--p,ar[b--]);
			else write(ar,--p,ar[i--]);
		}
		if(b<m)Bms.shiftBWExt(ar,a,i+1,p);
		else{
			i++;b++;p=m-(i-a);
			while(a<i&&m<b){
				if(compareValues(ar[a],ar[m])<1)write(ar,p++,ar[a++]);
				else write(ar,p++,ar[m++]);
			}
			while(a<i)write(ar,p++,ar[a++]);
		}
	}
	function SmMr(ar,p,a,m,rev){
		let i=m,cmp=rev?0:1;
		while(a<m){
			if(compareValues(ar[a],ar[i])<cmp)write(ar,p++,ar[a++]);
			else write(ar,p++,ar[i++]);
		}
		return i;
	}
	function SmTlMr(ar,tmp,p,a,m,b){
		let i=m,bLen=tmp.length;
		while(a<m&&i<b){
			if(compareValues(ar[a],ar[i])<1)write(ar,p++,ar[a++]);
			else write(ar,p++,ar[i++]);
		}
		if(a<m){
			if(a>p)Bms.shiftFWExt(ar,p,a,m);
			arraycopy(tmp,0,ar,b-bLen,bLen);
		}else{
			a=0;
			while(a<bLen&&i<b){
				if(compareValues(tmp[a],ar[i])<1)write(ar,p++,tmp[a++]);
				else write(ar,p++,ar[i++]);
			}
			while(a<bLen)write(ar,p++,tmp[a++]);
		}
	}
	function BlCyc(ar,a,t,tIdx,tLen,bLen){
		for(let i=0;i<tLen-1;i++){
			if(compareValues(ar[t+i],ar[tIdx+i])>0||(i>0&&compareValues(ar[t+i],ar[tIdx+i-1])<0)){
				arraycopy(ar,a+i*bLen,ar,a-bLen,bLen);
				let val=i,next=Bms.fBinSearch(ar,tIdx,tIdx+tLen,ar[t+i])-tIdx;
				do{
					arraycopy(ar,a+next*bLen,ar,a+val*bLen,bLen);
					swap(ar,t+i,t+next);
					val=next;next=Bms.fBinSearch(ar,tIdx,tIdx+tLen,ar[t+i])-tIdx;
				}while(next!=i);
				arraycopy(ar,a-bLen,ar,a+val*bLen,bLen);
			}
		}
	}
	function BlMr(ar,tmp,a,m,b,tl,tLen,t,tIdx,bp1,bp2,bLen){
		if(b-m<=bLen)return Bms.mergeBWExt(ar,tmp,a,m,b);
		Bms.insertTo(ar,t+tl-1,t);
		let i=a+bLen-1,j=m+bLen-1,ti=t,tj=t+tl,tp=tIdx;
		while(ti<t+tl&&tj<t+tLen){
			if(compareValues(ar[i],ar[j])<=0){
				swap(ar,tp++,ti++);
				i+=bLen;
			}else{
				swap(ar,tp++,tj++);
				swap(ar,bp1,bp2);
				j+=bLen;
			}
			bp1++;bp2++;
		}
		while(ti<t+tl){
			swap(ar,tp++,ti++);
			bp1++;bp2++;
		}
		while(tj<t+tLen){
			swap(ar,tp++,tj++);
			swap(ar,bp1++,bp2++);
		}
		t^=tIdx;tIdx^=t;t^=tIdx;
		heapSort(ar,tIdx,tIdx+tLen,true)
		arraycopy(ar,m-bLen,tmp,0,bLen,true);
		arraycopy(ar,a,ar,m-bLen,bLen);
		BlCyc(ar,a+bLen,t,tIdx,tLen,bLen);
		Bms.multiSwap(ar,t,tIdx,tLen);
		bp1-=tLen;bp2-=tLen;
		let f=a+bLen,a1=f,bp3=bp2+tLen,rev=compareIndices(ar,bp1,bp2)>0;
		while(true){
			do{
				if(rev)swap(ar,bp1,bp2);
				bp1++;bp2++;a1+=bLen;
			}while(bp2<bp3&&compareIndices(ar,bp1,bp2)==(rev?1:-1));
			if(bp2==bp3)return SmTlMr(ar,tmp,f-bLen,f,rev?f:a1,b);
			f=SmMr(ar,f-bLen,f,a1,rev);
			rev=!rev;
		}
	}
	function BlCycEs(ar,a,t,tIdx,tLen,bLen){
		for(let i=0;i<tLen-1;i++){
			if(compareValues(ar[t+i],ar[tIdx+i])>0||(i>0&&compareValues(ar[t+i],ar[tIdx+i-1])<0)){
				let next=Bms.fBinSearch(ar,tIdx,tIdx+tLen,ar[t+i])-tIdx;
				do{
					Bms.multiSwap(ar,a+i*bLen,a+next*bLen,bLen);
					swap(ar,t+i,t+next);
					next=Bms.fBinSearch(ar,tIdx,tIdx+tLen,ar[t+i])-tIdx;
				}while(next!=i);
			}
		}
	}
	function ipmBW(ar,a,m,b,rev){
		let f=rev?Bms.rightBinSearch(ar,m,b,ar[m-1]):Bms.fBinSearch(ar,m,b,ar[m-1]);
		b=f;
		while(b>m&&m>a){
			let i=rev?Bms.fBinSearch(ar,a,m,ar[b-1]):Bms.rightBinSearch(ar,a,m,ar[b-1]);
			Bms.rotate(ar,i,m,b);
			let t=m-i;m=i;b-=t+1;
			if(m==a)break;
			b=rev?Bms.rightBinSearch(ar,m,b,ar[m-1]):Bms.fBinSearch(ar,m,b,ar[m-1]);
		}
		return f;
	}
	function BlMrEs(ar,a,m,b,lenA,lenB,tl,tLen,t,tIdx,bp1,bp2,bLen){
		if(b-m<=bLen)return ipmBW(ar,a,m,b,false);
		let a1=a+lenA,b1=b-lenB,i=a1+bLen-1,j=m+bLen-1,ti=tIdx,tj=tIdx+tl,tp=t;
		while(ti<tIdx+tl&&tj<tIdx+tLen){
			if(compareValues(ar[i],ar[j])<=0){
				swap(ar,ti++,tp++);
				i+=bLen;
			}else{
				swap(ar,tj++,tp++);
				swap(ar,bp1,bp2);
				j+=bLen;
			}
			bp1++;bp2++;
		}
		while(ti<tIdx+tl){
			swap(ar,ti++,tp++);
			bp1++;bp2++;
		}
		while(tj<tIdx+tLen){
			swap(ar,tj++,tp++);
			swap(ar,bp1++,bp2++);
		}
		t^=tIdx;tIdx^=t;t^=tIdx;
		heapSort(ar,tIdx,tIdx+tLen,true)
		BlCycEs(ar,a1,t,tIdx,tLen,bLen);
		Bms.multiSwap(ar,t,tIdx,tLen);
		bp1-=tLen;bp2-=tLen;
		let f=a1,a2=f,bp3=bp2+tLen,rev=compareIndices(ar,bp1,bp2)>0;
		while(true){
			do{
				if(rev)swap(ar,bp1,bp2);
				bp1++;bp2++;a2+=bLen;
			}
			while(bp2<bp3&&compareIndices(ar,bp1,bp2)==(rev?1:-1));
			if(bp2==bp3){
				if(!rev)ipmBW(ar,a1,b1,b,false);
				Bms.inPlaceMerge(ar,a,a1,b);
				return;
			}
			f=ipmBW(ar,f,a2,a2+bLen,rev);
			rev=!rev;
		}
	}
	function run(ar,l){
		let a=0,b=l,n=b-a;
		if(n<128){
			if(n<32)Bms.binaryInsertion(ar,a,b);
			else fifthMergeSort()
			return;
		}
		let cbr=2*cCbr(n/4|0),bLen=2*cbr,kLen=cKy(bLen,n),tmp=new Array(bLen),keys=fKy(ar,tmp,a,b,2*kLen,cbr);
		if(keys<8){
			for(let j=1;j<n;j*=2)for(let i=a+j;i<b;i+=2*j)ipmBW(ar,i-j,i,minVal(i+j,b),false);
			return;
		}else if(keys<2*kLen){
			keys-=keys%4;kLen=keys/2|0;
		}
		let a1=a+keys,a2=a1+keys,bSep=fBt(ar,tmp,a1,b,kLen,cbr);
		if(bSep==-1){
			lSrEx(ar,tmp,a,a2);
			return Bms.inPlaceMerge(ar,a,a2,b);
		}
		let a3=a2+bLen,i,j=1;n=b-a3;
		Bms.binaryInsertion(ar,a2,a3);
		arraycopy(ar,a2,tmp,0,bLen,true);
		for(;j<cbr;j*=2){
			let p=maxVal(2,j);
			for(i=a3;i+2*j<b;i+=2*j)Bms.mergeWithBufFWExt(ar,i,i+j,i+2*j,i-p);
			if(i+j<b)Bms.mergeWithBufFWExt(ar,i,i+j,b,i-p);
			else Bms.shiftFWExt(ar,i-p,i,b);
			a3-=p;b-=p;
		}
		i=b-n%(2*j);
		if(i+j<b)Bms.mergeWithBufBWExt(ar,i,i+j,b,b+j);
		else Bms.shiftBWExt(ar,i,b,b+j);
		for(i-=2*j;i>=a3;i-=2*j)Bms.mergeWithBufBWExt(ar,i,i+j,i+2*j,i+3*j);
		a3+=j;b+=j;j*=2;
		for(i=a3;i+2*j<b;i+=2*j)Bms.mergeWithBufFWExt(ar,i,i+j,i+2*j,i-j);
		if(i+j<b)Bms.mergeWithBufFWExt(ar,i,i+j,b,i-j);
		else Bms.shiftFWExt(ar,i-j,i,b);
		a3-=j;b-=j;j*=2;i=b-n%(2*j);
		if(i+j<b)DlMrBWExt(ar,i,i+j,b,b+j/2|0);
		else Bms.shiftBWExt(ar,i,b,b+j/2|0);
		for(i-=2*j;i>=a3;i-=2*j)DlMrBWExt(ar,i,i+j,i+2*j,i+2*j+j/2|0);
		a3+=j/2|0;b+=j/2|0;j*=2;
		if(keys>=j){
			Bms.rotate(ar,a,a1,a3);
			a2=a1+bLen;
			if(kLen>=j){
				for(let mLvl=2*j;j<kLen;j*=2){
					let p=maxVal(mLvl,j);
					for(i=a3;i+2*j<b;i+=2*j)Bms.mergeWithBufFW(ar,i,i+j,i+2*j,i-p);
					if(i+j<b)Bms.mergeWithBufFW(ar,i,i+j,b,i-p);
					else Bms.shiftFW(ar,i-p,i,b);
					a3-=p;b-=p;
				}
				i=b-n%(2*j);
				if(i+j<b)Bms.mergeWithBufBW(ar,i,i+j,b,b+j);
				else Bms.shiftBW(ar,i,b,b+j);
				for(i-=2*j;i>=a3;i-=2*j)Bms.mergeWithBufBW(ar,i,i+j,i+2*j,i+3*j);
				a3+=j;b+=j;j*=2;
			}
			if(keys>=j){
				for(i=a3;i+2*j<b;i+=2*j)Bms.mergeWithBufFW(ar,i,i+j,i+2*j,i-j);
				if(i+j<b)Bms.mergeWithBufFW(ar,i,i+j,b,i-j);
				else Bms.shiftFW(ar,i-j,i,b);
				a3-=j;b-=j;j*=2;
				i=b-n%(2*j);
				if(i+j<b)DlMrBW(ar,i,i+j,b,b+j/2|0);
				else Bms.shiftBW(ar,i,b,b+j/2|0);
				for(i-=2*j;i>=a3;i-=2*j)DlMrBW(ar,i,i+j,i+2*j,i+2*j+j/2|0);
				a3+=j/2|0;b+=j/2|0;j*=2;
			}
			Bms.rotate(ar,a,a2,a3);
			a2=a1+keys;
			heapSort(ar,a,a1,true)
		}
		arraycopy(tmp,0,ar,a2,bLen);
		UnShuf(ar,a,a1);
		let limit=bLen*(kLen+2);
		for(let k=j/bLen-1|0;j<n&&minVal(2*j,n)<=limit;j*=2,k=2*k+1){
			for(i=a3;i+2*j<=b;i+=2*j)BlMr(ar,tmp,i,i+j,i+2*j,k,2*k,a,a+kLen,a1,a1+kLen,bLen);
			if(i+j<b)BlMr(ar,tmp,i,i+j,b,k,(b-i-1)/bLen-1|0,a,a+kLen,a1,a1+kLen,bLen);
		}
		for(;j<n;j*=2){
			bLen=(2*j)/kLen|0;
			let lenA=j%bLen,lenB=lenA;
			for(i=a3;i+2*j<=b;i+=2*j)BlMrEs(ar,i,i+j,i+2*j,lenA,lenB,kLen/2|0,kLen,a,a+kLen,a1,a1+kLen,bLen);
			if(i+j<b)BlMrEs(ar,i,i+j,b,lenA,(b-i-j)%bLen,kLen/2|0,(kLen/2|0)+(b-i-j)/bLen|0,a,a+kLen,a1,a1+kLen,bLen);
		}
		Bms.multiSwap(ar,a1+bSep,a1+kLen+bSep,kLen-bSep);
		lSrEx(ar,tmp,a,a3);
		rdBuf(ar,tmp,a,a3,b);
	}
	run(array,len)
	return[5,1]
}
function blockSelectionSort(){
	let array=[...arr];
	const sqr=n=>{
		let i=1;
		for(;i*i<n;i*=2);
		return i;
	}
	function msw(c,a,b,l){
		for(let i=0;i<l;i++)
			swap(c,a+i,b+i);
	}
	function rot(c,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0)
			if(r<l){
				msw(c,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(c,a,m,l);
				a+=l;m+=l;r-=l;
			}
	}
	function imp(c,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b)
			if(compareIndices(c,i,j)>0){
				k=j;
				do k++;while(k<b&&compareIndices(c,i,k)>0);
				rot(c,i,j,k);
				i+=k-j;j=k;
			}else i++;
		return i;
	}
	function ipmBW(c,a,m,b){
		let i=m-1,j=b-1,k;
		while(j>i&&i>=a)
			if(compareIndices(c,i,j)>0){
				k=i;
				do k--;while(k>=a&&compareIndices(c,k,j)>0);
				rot(c,k+1,i+1,j+1);
				j-=i-k;i=k;
			}else j--;
	}
	function ser(c,a,b,l){
		let m=a;
		a+=l;
		while(a<b){
			let o=compareIndices(c,a,m);
			if(o<0||(o==0&&compareIndices(c,a+l-1,m+l-1)<0))m=a;
			a+=l;
		}
		return m;
	}
	function seb(c,a,m,b,l){
		let k=a,j=m;
		while(k<m&&compareIndices(c,k,m)<1)k+=l;
		if(k==m)return;
		let i=m;
		msw(array,k,j,l);
		k+=l;j+=l;
		while(k<j&&j<b)
			if(compareIndices(c,i,j)<1){
				if(k!=i)msw(c,k,i,l);
				k+=l;i=ser(c,maxVal(m,k),j,l);
			}else{
				if(i==k)i=j;
				if(k!=j)msw(c,k,j,l);
				k+=l;j+=l;
			}
		while(k<j){
			i=ser(c,k,b,l);
			if(k!=i)msw(c,k,i,l);
			k+=l;
		}
	}
	for(let i,j=1;j<len;j*=2){
		let l=sqr(j),n=j,b=len-len%l;
		while(n>16){
			for(i=0;i+j<b;i+=2*j)
				for(let k=i;k+n<minVal(i+2*j,b);k+=n)
					seb(array,k,k+n,minVal(k+2*n,b),l);
			n=l;l=sqr(l);
		}
		for(i=0;i+j<b;i+=2*j)
			for(let k=i,f=i;k+n<minVal(i+2*j,b);k+=n)
				f=imp(array,f,k+n,minVal(k+2*n,b));
		ipmBW(array,len-len%(2*j),b,len);
	}
	return[5,1]
}
function iterativeIntroCircleSort(){
	let array=[...arr];
	let t=0,n=1,i=0;
	for(;n<len;n*=2,t+=.5);
	do{
		if(++i<t|0)continue;
		binInsertSort(array,0,len);
		break;
	}while(icsr(array,n));
	return[5,1]
}
function recursiveIntroCircleSort(){
	let array=[...arr];
	let t=0,n=1,i=0;
	for(;n<len;n*=2,t+=.5);
	do{
		if(++i<t|0)continue;
		binInsertSort(array,0,len);
		break;
	}while(rcsr(array,0,n-1,0));
	return[5,1]
}
function medianMergeSort(){
	let array=[...arr];
	function mot(c,a,b){
		let m=a+(b-1-a)/2|0;
		if(compareIndices(c,a,m)>0)swap(c,a,m);
		if(compareIndices(c,m,b-1)>0){
			swap(c,m,b-1);
			if(compareIndices(c,a,m)>0)return;
		}
		swap(c,a,m);
	}
	function mom(c,a,b,s){
		let e=b,t=a,i,j,d=true;
		while(e-t>1){
			j=t;
			for(i=t;i+2*s<=e;i+=s){
				insSort(c,i,i+s);
				swap(c,j++,i+s/2|0);
			}
			if(i<e){
				insSort(c,i,e);
				swap(c,j++,i+(e-(d?1:0)-i)/2|0);
				if((e-i)%2==0)d=!d;
			}
			e=j;
		}
	}
	function par(c,a,b,p){
		let i=a-1,j=b;
		while(1){
			do i++;while(i<j&&compareIndices(c,i,p)<0);
			do j--;while(j>=i&&compareIndices(c,j,p)>0);
			if(i<j)swap(c,i,j);
			else return j;
		}
	}
	function mer(c,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(c,i,j)<1)swap(c,p++,i++);
			else swap(c,p++,j++);
		}
		while(i<m)swap(c,p++,i++);
		while(j<b)swap(c,p++,j++);
	}
	const gml=n=>{
		while(n>31)n=(n+3)/4|0;
		return n;
	}
	function mrs(c,a,b,p){
		let l=b-a;
		if(l<2)return;
		let i,o,j=gml(l);
		for(i=a;i+j<=b;i+=j)binInsSort(c,i,i+j);
		binInsSort(c,i,b);
		while(j<l){
			o=p;
			for(i=a;i+2*j<=b;i+=2*j,o+=2*j)mer(c,i,i+j,i+2*j,o);
			if(i+j<b)mer(c,i,i+j,b,o);
			else while(i<b)swap(c,i++,o++);
			j*=2;o=a;
			for(i=p;i+2*j<=p+l;i+=2*j,o+=2*j)mer(c,i,i+j,i+2*j,o);
			if(i+j<p+l)mer(c,i,i+j,p+l,o);
			else while(i<p+l)swap(c,i++,o++);
			j*=2;
		}
	}
	function mms(c,a,b){
		let s=a,e=b,d=false,mm=false;
		while(e-s>16){
			if(d){
				mom(c,s,e,5);
				mm=true;
			}else mot(c,s,e);
			let p=par(c,s+1,e,s);
			swap(c,s,p);
			let l=p-s,r=e-(p+1);
			d=!mm&&((l==0||r==0)||(l/r|0>=16||r/l|0>=16));
			if(l<=r){
				mrs(c,s,p,p+1);
				s=p+1;
			}else{
				mrs(c,p+1,e,2*p+1-e);
				e=p;
			}
		}
		binInsSort(c,s,e);
	}
	let insSort=insertSort,binInsSort=binInsertSort;
	mms(array,0,len);
	return[5,1]
}
function mergeInsertionSort(){
	let array=[...arr];
	function bsw(a,b,c,s){
		while(s-->0)swap(a,b--,c--);
	}
	function bin(a,b,c,s){
		while(b-s>=c){
			bsw(a,b-s,b,s);
			b-=s;
		}
	}
	function brv(a,b,c,s){
		c-=s;
		while(c>b){
			bsw(a,b,c,s);
			b+=s;c-=s;
		}
	}
	function bsr(a,b,c,s,v){
		while(b<c){
			let m=b+(((c-b)/s|0)/2|0)*s;
			if(compareValues(v,a[m])<0)c=m;
			else b=m+s;
		}
		return b;
	}
	function ord(a,b,c,s){
		for(let i=b,j=i+s;j<c;i+=s,j+=2*s)bin(a,j,i,s);
		brv(a,b+(((c-b)/s|0)/2|0)*s,c,s);
	}
	let k=1;
	for(;2*k<=len;k*=2)for(let i=2*k-1;i<len;i+=2*k)if(compareIndices(array,i-k,i)>0)bsw(array,i-k,i,k,1);
	for(;k>0;k/=2,k|=0){
		let a=k-1,i=a+2*k,g=2,p=4;
		while(i+2*k*g-k<=len){
			ord(array,i,i+2*k*g-k,k);
			let b=a+k*(p-1);i+=k*g-k;
			for(let j=i;j<i+k*g;j+=k)bin(array,j,bsr(array,a,b,k,array[j]),k);
			i+=k*g+k;g=p-g;p*=2;
		}
		for(;i<len;i+=2*k)bin(array,i,bsr(array,a,i,k,array[i]),k);
	}
	return[5,1]
}
function hyrbidCombSort(){
	let array=[...arr];
	combSortTemp(array,len,1.3,true);
	return[5,1]
}
function fluxSort(){
	let array=[...arr];
	const Fo=24,qds=new QdS();
	function fA(a,n){
		let cnt=n,b=0,pta=0;
		while(--cnt>0)if(compareIndices(a,pta,++pta)>0)b++;
		if(b==0)return false;
		if(b==n-1)return!!reversal(a,0,n-1,0);
		if(b<=(n/6|0)||b>=(n/6|0)*5){
			qds.quadSort(a,0,n);
			return false;
		}
		return true;
	}
	function mo5(a,v0,v1,v2,v3,v4){
		let t=new Array(4),v;
		v=(compareIndices(a,v0,v1)+1)/2|0;t[0]=v;t[1]=v^1;
		v=(compareIndices(a,v0,v2)+1)/2|0;t[0]+=v;t[2]=v^1;
		v=(compareIndices(a,v0,v3)+1)/2|0;t[0]+=v;t[3]=v^1;
		v=(compareIndices(a,v0,v4)+1)/2|0;t[0]+=v;
		if(t[0]==2)return v0;
		v=(compareIndices(a,v1,v2)+1)/2|0;t[1]+=v;t[2]+=v^1;
		v=(compareIndices(a,v1,v3)+1)/2|0;t[1]+=v;t[3]+=v^1;
		v=(compareIndices(a,v1,v4)+1)/2|0;t[1]+=v;
		if(t[1]==2)return v1;
		v=(compareIndices(a,v2,v3)+1)/2|0;t[2]+=v;t[3]+=v^1;
		v=(compareIndices(a,v2,v4)+1)/2|0;t[2]+=v;
		if(t[2]==2)return v2;
		v=(compareIndices(a,v3,v4)+1)/2|0;t[3]+=v;
		return t[3]==2?v3:v4;
	}
	function mo3(a,v0,v1,v2){
		let t=new Array(2),v;
		v=(compareIndices(a,v0,v1)+1)/2|0;t[0]=v;t[1]=v^1;
		v=(compareIndices(a,v0,v2)+1)/2|0;t[0]+=v;
		if(t[0]==1)return v0;
		v=(compareIndices(a,v1,v2)+1)/2|0;t[1]+=v;
		return t[1]==1?v1:v2;
	}
	function mo15(a,ptx,n){
		let v0,v1,v2,v3,v4,div=n/16|0;
		v0=mo3(a,ptx+div*2,ptx+div*1,ptx+div*3);
		v1=mo3(a,ptx+div*5,ptx+div*4,ptx+div*6);
		v2=mo3(a,ptx+div*8,ptx+div*7,ptx+div*9);
		v3=mo3(a,ptx+div*11,ptx+div*10,ptx+div*12);
		v4=mo3(a,ptx+div*14,ptx+div*13,ptx+div*15);
		return mo5(a,v2,v0,v1,v3,v4);
	}
	function mo9(a,ptx,n){
		let v0,v1,v2,div=n/16|0;
		v0=mo3(a,ptx+div*2,ptx+div*1,ptx+div*4);
		v1=mo3(a,ptx+div*8,ptx+div*6,ptx+div*10);
		v2=mo3(a,ptx+div*14,ptx+div*12,ptx+div*15);
		return mo3(a,v0,v1,v2);
	}
	function fP(a,sw,m,s,n){
		let v,aSz,sSz,pta,pts,ptx,pte,piv;
		ptx=m.every((e,i)=>e==a[i])?s:0;piv=m[n>1024?mo15(m,ptx,n):mo9(m,ptx,n)];pte=ptx+n;pta=s;pts=0;
		while(ptx<pte){
			v=(compareValues(m[ptx],piv)+1)/2|0;
			write(a,pta,m[ptx]);pta+=v^1;
			write(sw,pts,m[ptx++],true);pts+=v;
		}
		sSz=pts;aSz=n-sSz;
		if(aSz<=(sSz/16|0)||sSz<=Fo){
			arraycopy(sw,0,a,pta,sSz);
			qds.quadSortSwap(a,sw,pta,sSz);
		}else fP(a,sw,sw,pta,sSz);
		if(sSz<=(aSz/16|0)||aSz<=Fo)qds.quadSortSwap(a,sw,s,aSz);
		else fP(a,sw,a,s,aSz);
	}
	function fs(a,n){
		if(n<32)qds.quadSort(a,0,n);
		else if(fA(a,n))fP(a,new Array(n),a,0,n);
	}
	fs(array,len);
	insertSort(array,0,len)
	return[5,1]
}
function quadSort(){
	let array=[...arr];
	new QdS().quadSort(array,0,len)
	return[5,1]
}
function weaveMergeSort(){
	let array=[...arr];
	function win(a,s,e){
		for(let j=s;j<e;j++){
			let p=j
			while(p>s&&compareIndices(a,p,p-1)<1)swap(a,p,--p);
		}
	}	
	function wem(a,n,x,m){
		let i=1,t=m-n;
		while(i<=t)multiSwap(a,m+i,n+(i++*2)-1);
		win(a,n,x+1);
	}
	function wms(a,n,x){
		if(x-n==0)0;
		else if(x-n==1){
			if(compareIndices(a,n,x)>0)swap(a,n,x);
		}else{
			let m=(n+x)/2|0
			wms(a,n,m);
			wms(a,m+1,x);
			wem(a,n,x,m);
		}
	}
	wms(array,0,len-1);
	return[5,1]
}
function sqrtSort(){
	let array=[...arr];
	function msw(ar,a,b,l,x){
		while(l--!=0)swap(ar,a++,b++,x);
	}
	function sqmr(ar,p,lL,rL,d,x){
		let mP=lL+rL+d-1,r=lL+rL-1,l=lL-1;
		while(l>=0)
			if(r<lL||compareIndices(ar,p+l,p+r)>0)write(ar,p+mP--,ar[p+l--],x);
			else write(ar,p+mP--,ar[p+r--],x);
		if(r!=mP)while(r>=lL)write(ar,p+mP--,ar[p+r--],x);
	}
	function sqmlwb(ar,p,lE,rE,d,x){
		let l=0,r=lE;rE+=lE;
		while(r<rE)
			if(l==lE||compareIndices(ar,p+l,p+r)>0)write(ar,p+d++,ar[p+r++],x);
			else write(ar,p+d++,ar[p+l++],x)
		if(d!=l)while(l<lE)write(ar,p+d++,ar[p+l++],x);
	}
	function sqmd(ar,aP,buf,bP,lL,rL,x){
		let aM=0,bM=0,d=-rL;
		while(bM<rL)
			if(aM==lL||compareValues(ar[aP+aM],buf[bP+bM])>=0)write(ar,aP+d++,buf[bP+bM++],x);
			else write(ar,aP+d++,ar[aP+aM++],x);
		if(d!=aM)while(aM<lL)write(ar,aP+d++,ar[aP+aM++],x);
	}
	function sqsmwb(ar,p,lol,lof,bL,x){
		let d=-bL,l=0,r=lol,lE=r,rE=r+bL,tF=1-lof;
		while(l<lE&&r<rE)
			if(compareIndices(ar,p+l,p+r)-tF<0)write(ar,p+d++,ar[p+l++],x);
			else write(ar,p+d++,ar[p+r++],x);
		let ln,fr=lof;
		if(l<lE){
			ln=lE-l;
			while(l<lE)write(ar,p+--rE,ar[p+--lE],x);
		}else{
			ln=rE-r;fr=tF;
		}
		return[ln,fr];
	}
	function smbflwb(keys,mK,ar,p,bC,rBL,aBC,lL,x){
		if(bC==0)return sqmlwb(ar,p,aBC*rBL,lL,-rBL,x);
		let lol=rBL,lof=compareValues(keys[0],mK)<0?0:1,pI=rBL,rTP;
		for(let kI=1;kI<bC;kI++,pI+=rBL){
			rTP=pI-lol;
			let nF=compareValues(keys[kI],mK)<0?0:1;
			if(nF==lof){
				arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,x);
				rTP=pI;lol=rBL;
			}else[lol,lof]=sqsmwb(ar,p+rTP,lol,lof,rBL,x);
		}
		rTP=pI-lol;
		if(lL!=0){
			if(lof!=0){
				arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,x);
				rTP=pI;lol=rBL*aBC;lof=0;
			}else lol+=rBL*aBC;
			sqmlwb(ar,p+rTP,lol,lL,-rBL,x);
		}else arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,x);
	}
	function sBBls(ar,p,ln,bL,x){
		let eD,pt;
		for(let d=1;d<ln;d+=2){
			eD=compareIndices(ar,p+(d-1),p+d)>0?1:0;
			write(ar,p+d-3,ar[p+d-1+eD],x);
			write(ar,p+d-2,ar[p+d-eD],x);
		}
		if(ln%2!=0)write(ar,p+ln-3,ar[p+ln-1],x);
		p-=2;
		for(pt=2;pt<bL;pt*=2){
			let lf=0,rh=ln-2*pt;
			while(lf<=rh){
				sqmlwb(ar,p+lf,pt,pt,-pt,x);
				lf+=2*pt;
			}
			let rs=ln-lf;
			if(rs>pt)sqmlwb(ar,p+lf,pt,rs-pt,-pt,x);
			else while(lf<ln)write(ar,p+lf-pt,ar[p+lf++],x);
			p-=pt;
		}
		let rTB=ln%(2*bL),loP=ln-rTB;
		if(rTB<=bL)arraycopy(ar,p+loP,ar,p+loP+bL,rTB,x);
		else sqmr(ar,p+loP,bL,rTB-bL,bL,x);
		while(loP>0){
			loP-=2*bL;
			sqmr(ar,p+loP,bL,bL,bL,x);
		}
	}
	function sqCmBl(ar,p,ln,bL,rBL,tags,x){
		let cmL=ln/(2*bL)|0,lO=ln%(2*bL),lI=0;
		if(lO<=bL){ln-=lO;lO=0}
		for(let i=0;i<=cmL;i++){
			if(i==cmL&&lO==0)break;
			let bP=p+i*2*bL,bC=(i==cmL?lO:2*bL)/rBL|0,tI=bC+(i==cmL?1:0),mK=bL/rBL|0;
			for(let j=0;j<=tI;j++)write(tags,j,j,true);
			for(tI=1;tI<bC;tI++){
				lI=tI-1;
				for(let rI=tI;rI<bC;rI++){
					let rC=compareIndices(ar,bP+lI*rBL,bP+rI*rBL);
					if(rC>0||(rC==0&&tags[lI]>tags[rI]))lI=rI;
				}
				if(lI!=tI-1){
					msw(ar,bP+(tI-1)*rBL,bP+lI*rBL,rBL,x);
					swap(tags,tI-1,lI,true);
				}
			}
			let aBC=0,lL=0;
			if(i==cmL)lL=lO%rBL;
			if(lL!=0)while(aBC<bC&&compareIndices(ar,bP+bC*rBL,bP+(bC-aBC-1)*rBL)<0)aBC++;
			smbflwb(tags,mK,ar,bP,bC-aBC,rBL,aBC,lL,x);
		}
		for(lI=ln-1;lI>=0;lI--)write(ar,p+lI,ar[p+lI-rBL],x);
	}
	function sqSort(ar,p,ln,eB,eBP,tags,x){
		if(ln<=16)return insertSort(ar,p,ln,x);
		let bL=1;
		while(bL*bL<ln)bL*=2;
		arraycopy(ar,p,eB,eBP,bL,x);
		sqSort(eB,eBP,bL,ar,p,tags,!x);
		sBBls(ar,p+bL,ln-bL,bL,x);
		let bL2=bL;
		while(ln>(bL2*=2))sqCmBl(ar,p+bL,ln-bL,bL2,bL,tags,x);
		sqmd(ar,p+bL,eB,eBP,ln-bL,bL,x);
	}
	let bL=1;
	while(bL*bL<len)bL*=2;
	let nK=(len-1)/bL+2|0,eB=new Array(bL),tags=new Array(nK);
	sqSort(array,0,len,eB,0,tags,false);
	return[5,1]
}
function optimizedYujisBufferedMergeSort(){
	let array=[...arr];
	const cL=n=>{
		let i;for(i=0;(1<<i)<n;i++);
		return i;
	}
	const msw=(c,a,b,l)=>{
		for(let i=0;i<l;i++)swap(c,a+i,b+i);
	}
	const ito=(a,b,c)=>{
		let t=a[b];
		while(b>c)write(a,b,a[--b]);
		write(a,c,t);
	}
	function bs(ar,s,e,v,l){
		let a=s,b=e;
		while(a<b){
			let m=a+(b-a)/2|0;
			let c=l?compareValues(v,ar[m])<=0:compareValues(v,ar[m])<0;
			if(c)b=m;else a=m+1;
		}		
		return a;
	}
	const bins=(a,b,c)=>{
		for(let i=b+1;i<c;i++)ito(a,i,bs(a,b,i,a[i],false));
	}
	function mwbs(ar,a,m,b,p,u){
		let i=0,j=m,k=a;
		if(u){
			while(i<m-a&&j<b){
				if(compareIndices(ar,j,p+i)<0){
					let q=bs(ar,j,b,ar[p+i],true);
					while(j<q)swap(ar,k++,j++);
				}
				swap(ar,k++,p+i++);
			}
			while(i<m-a)swap(ar,k++,p+i++);
		}else{
			while(i<m-a&&j<b)
				if(compareIndices(ar,p+i,j)<1)swap(ar,k++,p+i++);
				else swap(ar,k++,j++);
			while(i<m-a)swap(ar,k++,p+i++);
		}
	}
	function mr(ar,a,m,b,p){
		let i=a,j=m,lo=0;
		while(i<m&&j<b)
			if(compareIndices(ar,i,j)<1)swap(ar,p++,i++);
			else swap(ar,p++,j++);
		while(i<m)swap(ar,p++,i++);
		for(;j<b;lo++)swap(ar,p++,j++);
		return lo;
	}
	function mrS(ar,a,p,l){
		let i,j=16,cl=cL(l),ps=(l>16&&(cl&1)==1)?p:a,n=ps,pn;
		for(i=ps;i+16<=ps+l;i+=16)bins(ar,i,i+16);
		bins(ar,i,ps+l);
		while(j<l){
			ps=n;n^=a^p;pn=n;
			for(i=ps;i+2*j<=ps+l;i+=2*j,pn+=2*j)mr(ar,i,i+j,i+2*j,pn);
			if(i+j<ps+l)mr(ar,i,i+j,ps+l,pn);
			else while(i<ps+l)swap(ar,i++,pn++);
			j*=2;
		}
	}
	function bfmr(a,b,c){
		if(c-b<=16)return bins(a,b,c);
		let m=(b+c+1)/2|0,n=(b+m+1)/2|0,l=(c-b)/16|0;
		mrS(a,m,2*m-c,c-m);
		while(m-b>l){
			mrS(a,2*n-m,n,m-n);
			mwbs(a,n,m,c,2*n-m,(c-m)/(m-n)|0>=cL(n-b));
			m=n;n=(b+m+1)/2|0;
		}
		bfmr(a,b,m);
		msw(a,b,c-(m-b),m-b);
		bfmr(a,c-(m-b)-mr(a,m,c-(m-b),c,b),c);

	}
	bfmr(array,0,len);
	return[5,1]
}
function gritSort(){
	let array=[...arr];
	let MIN_SORT=74;
	if(len>=298){
		//alert("grit sort max array 297")
		arraycopy([...arr].sort((a,b)=>a-b),0,array,0,len)
		return[5,1];
	}
	const prL=n=>{
		let r=1;
		while((r<<r)+r-1<n)r++;
		return r;
	}
	const log2=n=>31-clz32(n);
	function calcSLen(n,m){
		let a=2,b=n;
		let logN=log2(maxVal(n,2)-1)+1;
		while(a<b){
			let ms=(a+b)/2|0,mq=n/(ms+1)|0,m1=m-mq*logN,logS=log2(ms-1)+1,qf=((m1/mq|0)/(mq+1)|0)/logS|0;
			if(qf>=1)b=ms;
			else a=ms+1;
		}
		return a;
	}
	class BitArray{
		constructor(a,pa,pb,sz,w){
			this.ar=a;this.pa=pa;this.pb=pb;this.size=sz;this.w=w;this.length=sz*w;
		}
		flipBit(a,b){swap(this.ar,a,b)}
		getBit(a,b){return compareIndices(this.ar,a,b)>0}
		setBit(a,b,t){if(this.getBit(a,b)^t)this.flipBit(a,b)}
		free(){
			let i1=this.pa+this.length;
			for(let i=this.pa,j=this.pb;i<i1;i++,j++)this.setBit(i,j,false);
		}
		set(idx,uInt){
			if(idx>=0&&idx<this.size){
				let s=idx*this.w,i1=this.pa+s+this.w;
				for(let i=this.pa+s,j=this.pb+s;i<i1;i++,j++,uInt>>=1)
					this.setBit(i,j,(uInt&1)==1);
			}
		}
		get(idx){
			if(idx>=0&&idx<this.size){
				let r=0,s=idx*this.w;
				for(let k=0,i=this.pa+s,j=this.pb+s;k<this.w;k++,i++,j++)
					r|=(this.getBit(i,j)?1:0)<<k;
				return r;
			}else return""
		}
		incr(idx){
			if(idx>=0&&idx<this.size){
				let s=idx*this.w,i1=this.pa+s+this.w;
				for(let i=this.pa+s,j=this.pb+s;i<i1;i++,j++){
					this.flipBit(i,j);
					if(this.getBit(i,j))return;
				}
			}
		}
	}
	class BitArray2D{
		constructor(a,pa,pb,x,y,w){
			this.bits=new BitArray(a,pa,pb,x*y,w);this.x=x;
		}
		free(){this.bits.free()}
		set(i,j,uInt){this.bits.set(j*this.x+i,uInt)}
		get(i,j){return this.bits.get(j*this.x+i)}
		incr(i,j){this.bits.incr(j*this.x+i)}
	}
	function bSw(ar,a,b,s){while(s-->0)swap(ar,a++,b++);}
	let rot=IndexRots.cycleReverse
	function gR(ar,a,b,r){
		let c=0,ce=0;
		for(let i=a;i<b;i++){
			if(i==r)continue;
			let cmp=compareIndices(ar,i,r);
			c+=cmp==-1?1:0;ce+=cmp<=0?1:0;
		}
		return ce<<32|c;
	}
	const iCan=(a,i,n,x)=>compareIndices(a,i,n)>0&&compareIndices(a,i,x)<0;
	function slBlM(ar,a,b,med,min,max){
		let lMin=min,lMax=max;
		for(let i=a;;i++){
			if(iCan(ar,i,lMin,lMax)){
				let c=0,ce=0;
				for(let j=a;j<b;j++){
					if(j==i)continue;
					if(iCan(ar,j,min,max)){
						let cmp=compareIndices(ar,j,i);
						c+=cmp==-1?1:0;ce+=cmp<=0?1:0;
					}
				}
				if(med>=c&&med<=ce)return i;
				else if(ce<med)lMin=i;
				else lMax=i;
			}
		}
	}
	function sR(ar,a,b,med,min,max){
		let rank=gR(ar,a,b,min),r=rank|0,re=rank>>32|0;
		if(med>=r&&med<=re)return min;
		let cand=re+1;rank=gR(ar,a,b,max);r=rank|0;re=rank>>32|0;
		if(med>=r&&med<=re)return max;
		let n=b-a,a1=0,b1=0;cand=r-cand;
		while(cand>3){
			let sqr=sqrt(cand)|0,s=(n-1)/sqr+1|0,j=a;
			for(;j+s<b;j+=s){
				let i=j,fCnt=0;
				while(!iCan(ar,i,min,max)&&++fCnt<=s-sqr)i++;
				if(fCnt>s-sqr)continue;
				else{
					let found=false,cCnt=1;a1=i++;
					for(;fCnt<=s-sqr;i++)
						if(iCan(ar,i,min,max)){
							if(++cCnt==sqr){
								found=true;break;
							}
						}else fCnt++;
					if(found){
						b1=i+1;break;
					}
				}
			}
			if(j+s>=b){
				let i=j;
				while(!iCan(ar,i,min,max))i++;a1=i++;
				for(let cCnt=1;cCnt<sqr;i++)if(iCan(ar,i,min,max))cCnt++;
				b1=i+1;
			}
			let bMed=slBlM(ar,a1,b1,sqr/2|0,min,max),c=0,ce=0;r=0;re=0;
			for(let i=a;i<b;i++){
				if(i==bMed)continue;
				let cmp=compareIndices(ar,i,bMed);
				r+=cmp==-1?1:0;re+=cmp<1?1:0;
				if(iCan(ar,i,min,max)){
					c+=cmp==-1?1:0;ce+=cmp<1?1:0;
				}
			}
			if(med>=r&&med<=re)return bMed;
			else if(re<med){min=bMed;cand-=ce+1;
			}else{max=bMed;cand-=cand-c;}
		}
		for(let i=a;i<b;i++)
			if(iCan(ar,i,min,max)){
				if(--cand==0)return i;
				rank=gR(ar,a,b,i);r=rank|0;re=rank>>32|0;
				if(med>=r&&med<=re)return i;
			}
		return-1;
	}
	const pivCmp=(v,p,c)=>compareValues(v,p)<c;
	function pBX(ar,pa,pb,v,wLen){
		while(wLen-->0){
			if((v&1)==1)swap(ar,pa+wLen,pb+wLen);
			v>>=1;
		}
	}
	function pBG(ar,pa,piv,pCmp,wLen,bit){
		let r=0;
		while(wLen-->0){
			r<<=1;r|=(pivCmp(ar[pa++],piv,pCmp)?0:1)^bit;
		}
		return r;
	}
	function blC(ar,p,n,p1,bLen,wLen,piv,pCmp,bit){
		for(let i=0;i<n;i++){
			let dest=pBG(ar,p+i*bLen,piv,pCmp,wLen,bit);
			while(dest!=i){
				bSw(ar,p+i*bLen,p+dest*bLen,bLen);
				dest=pBG(ar,p+i*bLen,piv,pCmp,wLen,bit);
			}
			pBX(ar,p+i*bLen,p1+i*bLen,i,wLen);
		}
	}
	function parE(ar,aux,a,b,piv,pCmp){
		let j=0;
		for(let i=a;i<b;i++)
			if(pivCmp(ar[i],piv,pCmp))write(ar,a++,ar[i]);
			else write(aux,j++,ar[i],true);
		arraycopy(aux,0,ar,a,j);
		return a;
	}
	function blPar(ar,aux,a,b,bLen,piv,pCmp){
		if(b-a<=bLen)return parE(ar,aux,a,b,piv,pCmp);
		let p=a,l=0,r=0,lb=0,rb=0;
		for(let i=a;i<b;i++){
			if(pivCmp(ar[i],piv,pCmp)){
				write(ar,p+l++,ar[i]);
				if(l==bLen){
					l=0;lb++;p+=bLen;
				}
			}else{
				write(aux,r++,ar[i],true);
				if(r==bLen){
					arraycopy(ar,p,ar,p+bLen,l);
					arraycopy(aux,0,ar,p,bLen);
					r=0;rb++;p+=bLen;
				}
			}
		}
		let min=minVal(lb,rb),m=a+lb*bLen;
		if(min>0){
			let bCnt=lb+rb,wLen=log2(min-1)+1;
			for(let i=0,j=0,k=0;i<min;i++){
				while(!pivCmp(ar[a+j*bLen+wLen],piv,pCmp))j++;
				while(pivCmp(ar[a+k*bLen+wLen],piv,pCmp))k++;
				pBX(ar,a+(j++)*bLen,a+(k++)*bLen,i,wLen);
			}
			if(lb<rb){
				for(let i=bCnt-1,j=0;j<rb;i--)if(!pivCmp(ar[a+i*bLen+wLen],piv,pCmp))bSw(ar,a+i*bLen,a+(bCnt-(++j))*bLen,bLen);
				blC(ar,a,lb,m,bLen,wLen,piv,pCmp,0);
			}else{
				for(let i=0,j=0;j<lb;i++)if(pivCmp(ar[a+i*bLen+wLen],piv,pCmp))bSw(ar,a+i*bLen,a+(j++)*bLen,bLen);
				blC(ar,m,rb,a,bLen,wLen,piv,pCmp,1);
			}
		}
		arraycopy(aux,0,ar,b-r,r);
		if(l>0){
			arraycopy(ar,b-r-l,aux,0,l,true);
			arraycopy(ar,a+lb*bLen,ar,a+lb*bLen+l,rb*bLen);
			arraycopy(aux,0,ar,a+lb*bLen,l);
		}
		return a+lb*bLen+l;
	}
	function mergeFWExt(ar,tmp,a,m,b){
		let s=m-a,i=0,j=m;
		arraycopy(ar,a,tmp,0,s,true);
		while(i<s&&j<b)
			if(compareValues(tmp[i],ar[j])<1)write(ar,a++,tmp[i++]);
			else write(ar,a++,ar[j++]);
		while(i<s)write(ar,a++,tmp[i++]);
	}
	function mergeBWExt(ar,tmp,a,m,b){
		let s=b-m,i=s-1,j=m-1;
		arraycopy(ar,m,tmp,0,s,true);
		while(i>=0&&j>=a)
			if(compareValues(tmp[i],ar[j])>=0)write(ar,--b,tmp[i--]);
			else write(ar,--b,ar[j--]);
		while(i>=0)write(ar,--b,tmp[i--]);
	}
	function blMrH(ar,swp,a,m,b,p,bLen,piv,pCmp,bit){
		if(b-m<=2*bLen||m-a<=2*bLen)return mergeBWExt(ar,swp,a,m,b);
		let bCnt=0,wLen=log2((b-a)/bLen-3|0)+1,i=a,j=m,k=0,l=0,r=0,c=0;
		while(c++<2*bLen){
			if(compareIndices(ar,i,j)<1)write(swp,k++,ar[i++],true,l++);
			else write(swp,k++,ar[j++],true,r++);
		}
		let t=0,pc=p,f=l>=r;k=f?i-l:j-r;c=0;
		do{
			if(j==b||compareIndices(ar,i,j)<1){
				write(ar,k++,ar[i++]);l++;
			}else{
				write(ar,k++,ar[j++]);r++;
			}
			if(++c==bLen){
				pBX(ar,k-bLen,pc,t++,wLen);
				if(f)l-=bLen;
				else r-=bLen;
				pc+=bLen;f=l>=r;k=f?i-l:j-r;c=0;bCnt++;
			}
		}while(i<m);
		let b1=j-c;
		arraycopy(ar,k-c,ar,b1,c);
		r-=c;l=minVal(l,m-a-l);
		arraycopy(ar,a,ar,m-l,l);
		arraycopy(ar,a+l,ar,b1-r,r);
		arraycopy(swp,0,ar,a,2*bLen);
		blC(ar,a+2*bLen,bCnt,p,bLen,wLen,piv,pCmp,bit);
	}
	function blMr(ar,swp,a,m,b,p,bLen,piv,pCmp,bit){
		if(b-a<MIN_SORT)return;
		let a1=a+(m-a)%bLen;
		blMrH(ar,swp,a1,m,b,p,bLen,piv,pCmp,bit);
		mergeFWExt(ar,swp,a,a1,b);
	}
	function stCDest(ar,a,a1,b1,b,p,piv,cmp){
		let d=a1,e=0;
		for(let i=a1+1;i<b;i++){
			let bit=compareValues(ar[i],piv)==cmp,val=bit?ar[i]:ar[p+(i-a)],vCmp=compareValues(val,ar[a1]);
			if(vCmp==-1)d++;
			else if(i<b1&&bit&&vCmp==0)e++;
		}
		while(1){
			if(compareValues(ar[d],piv)==cmp&&e--==0)break;
			d++;
		}
		return d;
	}
	function stC(ar,a,b,p,piv,cmp){
		for(let i=a;i<b;i++){
			if(compareValues(ar[i],piv)==cmp){
				let j=i;
				while(true){
					let k=stCDest(ar,a,i,j,b,p,piv,cmp),t=ar[i];
					if(k==i)break;
					write(ar,i,ar[k]);
					write(ar,k,ar[p+(k-a)]);
					write(ar,p+(k-a),t);
					j=k;
				}
				swap(ar,i,p+(i-a));
			}
		}
	}
	function gSR(ar,a,b,p,s1,s2,piv,cmp){
		if(b-a<MIN_SORT)return stC(ar,a,b,p,piv,cmp);
		let m=(a+b)/2|0;
		for(let i=a;i<m;i+=s1)stC(ar,i,minVal(i+s1,m),p+(i-a),piv,cmp);
		for(let i=m;i<b;i+=s2)stC(ar,i,minVal(i+s2,b),p+(i-a),piv,cmp);
	}
	function fPs(ar,qIdx,a,p,q,piv,cmp){
		let f=a,fKeys=0;
		for(let i=a;fKeys<q;i++)
			if(compareValues(ar[i],piv)!=cmp){
				rot(ar,f,f+fKeys,i);
				swap(ar,p+(i-a),i);
				f=i-fKeys;
				qIdx.set(fKeys,i-a-(fKeys++));
			}
		rot(ar,a,f,f+q);
	}
	function sPs(ar,qIdx,a,b){
		for(let i=a;i<b-1;i++){
			let min=i,iIdx=qIdx.get(i-a),mIdx=iIdx;
			for(let j=min+1;j<b;j++){
				let cmp=compareIndices(ar,j,min);
				if(cmp<0){
					min=j;mIdx=qIdx.get(j-a);
				}else if(cmp==0){
					let jIdx=qIdx.get(j-a);
					if(jIdx<mIdx){
						min=j;mIdx=jIdx;
					}
				}
			}
			if(min>i){
				swap(ar,i,min);
				qIdx.set(i-a,mIdx);
				qIdx.set(min-a,iIdx);
			}
		}
	}
	function pEq(val,vPos,pivL,pivR,ql,qr){
		let cmpL=ql==-1?1:compareValues(val,pivL),cmpR=qr==-1?-1:compareValues(val,pivR);
		return(cmpL>0||(cmpL==0&&vPos>=ql))&&(cmpR<0||(cmpR==0&&vPos<qr));
	}
	function pBS(ar,qIdx,a,b,val,vPos){
		let a1=a;
		while(a1<b){
			let m=a1+(b-a1)/2|0,cmp=compareValues(val,ar[m]);
			if(cmp<0||(cmp==0&&vPos<qIdx.get(m-a)))b=m;
			else a1=m+1;
		}
		return a1;
	}
	function gParH(ar,a,b,pa,pb,p,s,piv,cmp){
		let n=b-a,rCnt=(n-1)/s+1|0,c=0,q=n/(s+1)|0,logS=log2(s-1)+1,runs=new BitArray(ar,pa+rCnt,pb+rCnt,rCnt,logS);
		while(1){
			let min=-1,mPos=-1;
			for(let i=0;i<rCnt;i++)
				if(compareIndices(ar,pa+i,pb+i)<0){
					let rMin=a+i*s+runs.get(i);
					if(min==-1||compareIndices(ar,rMin,mPos)<0){
						min=i;mPos=rMin;
					}
				}
			if(min==-1)break;
			if(mPos==minVal(a+(min+1)*s,b)-1)swap(ar,pa+min,pb+min);
			else runs.incr(min);
			if(c++==s){
				swap(ar,mPos,p+(mPos-a));c=0;
			}
		}
		bSw(ar,pa,pb,rCnt);
		runs.free();
		let qIdx=new BitArray(ar,pa,pb,q,log2(n-1)+1),a1=a+q,counts=new BitArray2D(ar,pa+qIdx.length,pb+qIdx.length,q,q+1,logS);
		fPs(ar,qIdx,a,p,q,piv,cmp);
		sPs(ar,qIdx,a,a1);
		for(let i=0;i<q;i++){
			if(i>0)for(let j=0;j<q+1;j++)counts.set(i,j,counts.get(i-1,j));
			let k=a1+i*s;
			for(let j=0;j<s;j++)counts.incr(i,pBS(ar,qIdx,a,a1,ar[k+j],k+j-a1)-a);
		}
		for(let i=a1;i<b;i++)
			if(compareValues(ar[i],piv)==cmp){
				let j=i;
				while(1){
					let loc=pBS(ar,qIdx,a,a1,ar[i],j-a1)-a,curS=(j-a1)/s|0,pivL=loc>0?ar[a+loc-1]:-1,pivR=loc<q?ar[a+loc]:-1,ql=loc>0?qIdx.get(loc-1):-1,qr=loc<q?qIdx.get(loc):-1,cntA=curS>0?counts.get(curS-1,loc):0,cntB=0;
					for(let i1=maxVal(i+1,a1+curS*s);i1<j;i1++)if(compareValues(ar[i1],piv)==cmp&&pEq(ar[i1],i1-a1,pivL,pivR,ql,qr))cntB++;
					let k=a1+loc*s+cntA;
					for(;!(compareValues(ar[k],piv)==cmp&&cntB--==0);k++);
					if(k==i)break;
					let t=ar[i];
					write(ar,i,ar[k]);
					write(ar,k,ar[p+(k-a)]);
					write(ar,p+(k-a),t);
					j=k;
				}
				swap(ar,i,p+(i-a));
			}
		qIdx.free();
		counts.free();
		bSw(ar,a,p,q);
		while(q>0){
			rot(ar,p,p+q,p+s+(q--));p+=s+1;
		}
	}
	function gPar(ar,a,b,p,s1,s2,piv,cmp){
		if(b-a<MIN_SORT)return bSw(ar,a,p,b-a);
		let m=(a+b)/2|0,p1=p+(m-a);
		if(cmp==-1){
			gParH(ar,a,m,m,p1,p,s1,piv,cmp);
			gParH(ar,m,b,p,a,p1,s2,piv,cmp);
		}else{
			gParH(ar,a,m,p1,m,p,s1,piv,cmp);
			gParH(ar,m,b,a,p,p1,s2,piv,cmp);
		}
	}
	function gSB(ar,a,b,p,s1,s2,piv,cmp){
		if(b-a<MIN_SORT)return bSw(ar,a,p,b-a);
		let m=(a+b)/2|0;
		for(let i=a;i<m;i+=s1+1){
			stC(ar,i,minVal(i+s1,m),p+(i-a),piv,cmp);
			if(i+s1<m)swap(ar,i+s1,p+(i+s1-a));
		}
		for(let i=m;i<b;i+=s2+1){
			stC(ar,i,minVal(i+s2,b),p+(i-a),piv,cmp);
			if(i+s1<b)swap(ar,i+s1,p+(i+s1-a));
		}
	}
	function main(ar,le){
		let a=0,b=le,n=b-a,min=a,max=min;
		if(n<=32)return binInsertSort(ar,a,b);
		for(let i=a+1;i<b;i++)
			if(compareIndices(ar,i,min)<0)min=i;
			else if(compareIndices(ar,i,max)>0)max=i;
		let m1=(a+b)/2|0,med=ar[sR(ar,a,b,m1,min,max)],lgBLen=prL(le),tmp=new Array(2*lgBLen);
		blPar(ar,tmp,a,blPar(ar,tmp,a,b,2*lgBLen,med,1),2*lgBLen,med,0);
		if(!compareIndices(ar,a,b-1))return;
		let m2=m1+n%2;
		for(;!compareIndices(ar,m1-1,m2);m1--,m2++);
		if(compareValues(ar[m2],med)==0){
			let m3=m2,bSize=1;
			while(++m3<b&&compareValues(ar[m3],med)==0)bSize++;
			let a1=a+bSize,len1=m1-a,s1=calcSLen(len1/2|0,(len1+1)/2|0),s2=calcSLen((len1+1)/2|0,len1/2|0),len2=len1-bSize,s3=calcSLen(len2/2|0,(len2+1)/2|0),s4=calcSLen((len2+1)/2|0,len2/2|0);
			gSR(ar,a,m1,m2,s1,s2,med,-1);
			bSw(ar,a,m2,bSize);
			gSR(ar,a1,m1,m3,s3,s4,med,1);
			if(maxVal(len1,len2)>=MIN_SORT){
				gPar(ar,a,m1,m2,s1,s2,med,-1);
				bSw(ar,a,m2,bSize);
				gPar(ar,a1,m1,m3,s3,s4,med,1);
				gSB(ar,a,m1,m2,s1,s2,med,-1);
				bSw(ar,a,m2,bSize);
				gSB(ar,a1,m1,m3,s3,s4,med,1);
				blMr(ar,tmp,a,(a+m1)/2|0,m1,m2,lgBLen,med,0,0);
				blMr(ar,tmp,m3,(m3+b)/2|0,b,a,lgBLen,med,0,1);
			}
		}else if(compareValues(ar[m1-1],med)==0){
			let m3=m1,bSize=1;
			while(--m3>a&&compareValues(ar[m3-1],med)==0)bSize++;
			let b1=b-bSize,len1=m3-a,s1=calcSLen(len1/2|0,(len1+1)/2|0),s2=calcSLen((len1+1)/2|0,len1/2|0),len2=len1+bSize,s3=calcSLen(len2/2|0,(len2+1)/2|0),s4=calcSLen((len2+1)/2|0,len2/2|0);
			gSR(ar,a,m3,m2,s1,s2,med,-1);
			bSw(ar,m3,b1,bSize);
			gSR(ar,a,m1,m2,s3,s4,med,1);
			if(maxVal(len1,len2)>=MIN_SORT){
				gPar(ar,a,m3,m2,s1,s2,med,-1);
				bSw(ar,m3,b1,bSize);
				gPar(ar,a,m1,m2,s3,s4,med,1);
				gSB(ar,a,m3,m2,s1,s2,med,-1);
				bSw(ar,m3,b1,bSize);
				gSB(ar,a,m1,m2,s3,s4,med,1);
				blMr(ar,tmp,a,(a+m3)/2|0,m3,m2,lgBLen,med,0,0);
				blMr(ar,tmp,m2,(m2+b)/2|0,b,a,lgBLen,med,1,1);
			}
		}else{
			let len1=m1-a,s1=calcSLen(len1/2|0,(len1+1)/2|0),s2=calcSLen((len1+1)/2|0,len1/2|0);
			gSR(ar,a,m1,m2,s1,s2,med,-1);
			gSR(ar,a,m1,m2,s1,s2,med,1);
			if(len1>=MIN_SORT){
				gPar(ar,a,m1,m2,s1,s2,med,-1);
				gPar(ar,a,m1,m2,s1,s2,med,1);
				gSB(ar,a,m1,m2,s1,s2,med,-1);
				gSB(ar,a,m1,m2,s1,s2,med,1);
				blMr(ar,tmp,a,(a+m1)/2|0,m1,m2,lgBLen,med,0,0);
				blMr(ar,tmp,m2,(m2+b)/2|0,b,a,lgBLen,med,0,1);
			}
		}
	}
	main(array,len)
	return[15,1]
}
function matrixSort(){
	let array=[...arr];
	class MtSp{
		constructor(w,h,l){
			this.w=w;
			this.iL=(w==1)^(h==1)||l;
		}
	}
	function gR(a,s,e,g){
		for(let i=s,j=e;i<j;i+=g,j-=g)swap(a,i,j-g);
	}
	const dCV=(l,r,d)=>d?compareValues(l,r):(compareValues(l,r)*-1);
	function inL(ar,a,b,g,dr){
		let d=0,k=ar[b],j=b-g;
		while(j>=a&&dCV(k,ar[j],dr)<0){
			write(ar,j+g,ar[j]);
			d=1;j-=g;
		}
		write(ar,j+g,k);
		return d;
	}
	function gMD(l){
		let d=sqrt(l)|0,iL=(d*d==l-1)
		for(;l%d!=0;d--);
		return new MtSp(d,l/d|0,iL);
	}
	function mS(a,s,e,g,dr){
		let d=0,l=(e-s)/g|0;
		if(l<2)return 0;
		else if(l<17){
			d=0;
			for(let i=s;i<e;i+=g)d=inL(a,s,i,g,dr)|d;
		}else{
			let nd,mSh=gMD(l);
			if(mSh.iL){
				let d1=mS(a,s,e-g,g,dr);
				let d2=inL(a,s,e-g,g,dr);
				return d1||d2;
			}
			for(let i=s+mSh.w*g;i<e;i+=2*mSh.w*g)gR(a,i,i+mSh.w*g,g);
			d=0;
			do{
				nd=0;
				for(let i=s,cd=dr;i<e;i+=mSh.w*g){
					nd=mS(a,i,i+mSh.w*g,g,cd)||nd;
					d=d||nd;
					cd=!cd;
				}
				nd=0;
				for(let i=0;i<mSh.w;d=d||nd,i++)nd=mS(a,s+i*g,e+i*g,g*mSh.w,dr)||nd;
			}while(nd);
			for(let i=s+mSh.w*g;i<e;i+=2*mSh.w*g)gR(a,i,i+mSh.w*g,g);
		}
		return d;
	}
	mS(array,0,len,1,true);
	return[5,1]
}
function kotaSort(){
	let array=[...arr];
	let tags,cch,bfPs,blL,tgL,bfL,efM,ext;
	function rot(ar,st,sp,e){
		let tm;
		while(sp<e&&sp>st)
			if(e-sp<sp-st){
				if(e-sp==1){
					tm=ar[sp];
					shf(ar,st,sp,e,true,true);
					write(ar,st,tm);
					return;
				}else{
					shf(ar,2*sp-e,sp,e,true,false);
					tm=e;e=sp;sp-=tm-sp;
				}
			}else{
				if(sp-st==1){
					tm=ar[st];
					shf(ar,st,sp,e,false,true);
					write(ar,e-1,tm);
					return;
				}else{
					shf(ar,st,sp,2*sp-st,false,false);
					tm=st;st=sp;sp+=sp-tm;
				}
			}
	}
	function kSw(ar,a,b,x){
		if(x)write(ar,a,ar[b]);
		else swap(ar,a,b);
	}
	function bS(ar,st,e,v,l){
		let a=st,b=e;
		while(a<b){
			let m=(a+b)/2|0,c=l?compareValues(v,ar[m])<1:compareValues(v,ar[m])<0;
			if(c)b=m;
			else a=m+1;
		}
		return a;
	}
	function fKy(ar,st,e,n){
		let nKs=1,p=st,pE=st+1;
		for(let i=st+1;i<e&&nKs<n;i++){
			let l=bS(ar,p,pE,ar[i],true);
			if(i==l||compareIndices(ar,i,l)){
				rot(ar,p,pE,i);
				let ic=i-pE;p+=ic;nKs++;
				rot(ar,l+=ic,pE+=ic,++pE);
			}
		}
		rot(ar,st,p,pE);
		return nKs;
	}
	function sw2Tgs(ar,a,i,x){
		if(!x)return kSw(ar,bfPs+i,a,false);
		let tm=tags[i];
		write(tags,i,ar[a],true);
		write(ar,a,tm);
	}
	function shf(ar,a,m,b,l,x){
		if(m==(l?b:a))return
		if(l)while(m>a)kSw(ar,--b,--m,x);
		else while(m<b)kSw(ar,a++,m++,x);
	}
	function mSw(ar,a,b,l,x){
		for(let i=0;i<l;i++)kSw(ar,a+i,b+i,x);
	}
	function mSwBW(ar,a,b,l,x){
		for(let i=0;i<l;i++)kSw(ar,a-i,b-i,x);
	}
	function blSl(ar,p,c){
		for(let j=0;j<c;j++){
			let st=p+j*blL,min=st;
			for(let i=j+1;i<c;i++){
				let sel=p+i*blL;
				if(compareIndices(ar,sel,min)<0)min=sel;
			}
			if(st!=min)mSw(ar,st,min,blL,false);
			sw2Tgs(ar,st,j,false);
		}
	}
	function blSlBW(ar,p,c){
		for(let j=0;j<c;j++){
			let st=p-j*blL,n=st;
			for(let i=j+1;i<c;i++){
				let s=p-i*blL;
				if(compareIndices(ar,s,n)<0)n=s;
			}
			if(st!=n)mSwBW(ar,st,n,blL,false);
			sw2Tgs(ar,st,j,false);
		}
	}
	function blCyc(ar,ps,c,p){
		for(let j=0;j<c;j++){
			let st=ps+j*blL;
			if(j!=ar[st]){
				let f=ar[st],v=j;
				mSw(ar,p,st,blL,true);
				while(v!=f){
					let vS=ps+v*blL,k=j+1,nx=ps+k*blL;
					while(compareValues(ar[nx],v)!=0)nx=ps+(++k)*blL;
					v=k;
					mSw(ar,vS,nx,blL,true);
				}
				f=ps+f*blL;
				mSw(ar,f,p,blL,true);
			}
			sw2Tgs(ar,st,j,true);
		}
	}
	function blCycBW(ar,ps,c,p){
		for(let j=0;j<c;j++){
			let st=ps-j*blL;
			if(j!=ar[st]){
				let f=ar[st],v=j;
				mSwBW(ar,p,st,blL,true);
				while(v!=f){
					let vS=ps-v*blL,k=j+1,nx=ps-k*blL;
					while(compareValues(ar[nx],v)!=0)nx=ps-(++k)*blL;
					v=k;
					mSwBW(ar,vS,nx,blL,true);
				}
				f=ps-f*blL;
				mSwBW(ar,f,p,blL,true);
			}
			sw2Tgs(ar,st,j,true);
		}
	}
	function blMr(ar,a,m,b,xT){
		if(b-m<=2*bfL)return dlMr(ar,a,m,b,bfL);
		let i=a,j=m,k,first,fAD=bfL,rightAD=0,f=i-bfL,right=j,tC=0;
		while(i<m&&fAD>=rightAD)
			for(k=0;i<m&&k<blL;k++)
				if(compareIndices(ar,i,j)<1)kSw(ar,f++,i++,ext);
				else{
					kSw(ar,f++,j++,ext);
					rightAD++;fAD--;
				}
		let sS=f;
		while(i<m&&j<b){
			while(i<m&&j<b&&rightAD>fAD){
				for(k=0,first=right;i<m&&j<b&&k<blL;k++)
					if(compareIndices(ar,i,j)<1){
						kSw(ar,right++,i++,ext);
						rightAD--;fAD++;
					}else kSw(ar,right++,j++,ext);
				for(;i<m&&k<blL;rightAD--,fAD++,k++)kSw(ar,right++,i++,ext);
				for(;j<b&&k<blL;k++)kSw(ar,right++,j++,ext);
				if(k==blL)sw2Tgs(ar,first,tC++,xT);
				else{
					shf(ar,first,first+k,b,true,ext);
					j=b-k;right=first;
				}
			}
			while(i<m&&j<b&&fAD>=rightAD){
				for(k=0,first=f;i<m&&j<b&&k<blL;k++)
					if(compareIndices(ar,i,j)<1)kSw(ar,f++,i++,ext);
					else{
						kSw(ar,f++,j++,ext);
						rightAD++;fAD--;
					}
				for(;i<m&&k<blL;k++)kSw(ar,f++,i++,ext);
				for(;j<b&&k<blL;rightAD++,fAD--,k++)kSw(ar,f++,j++,ext);
				if(k==blL)sw2Tgs(ar,first,tC++,xT);
				else{
					rot(ar,first,m,right);
					f+=right-m;fAD=0;
				}
			}
		}
		if(i>=m&&fAD==blL&&tC>0)mSw(ar,f,right-blL,blL,ext);
		else{
			if(i<m){
				rot(ar,f,m,right);
				f+=right-m;
			}
			shf(ar,f,f+fAD,right,false,ext);
		}
		if(j<b)shf(ar,j-bfL,j,b,false,ext);
		if(xT)blCyc(ar,sS,tC,b-bfL);
		else blSl(ar,sS,tC);
	}
	function blMrBW(ar,a,m,b,xT){
		let i=m-1,j=b-1,k,first,fAD=0,rightAD=bfL,f=i,right=j+bfL,tC=0;
		while(j>=m&&rightAD>=fAD){
			k=0;
			while(j>=m&&k<blL){
				if(compareIndices(ar,i,j)>0){
					kSw(ar,right--,i--,ext);
					fAD++;
					rightAD--;
				}else kSw(ar,right--,j--,ext);
				k++;
			}
		}
		let sS=right;
		while(j>=m&&i>=a){
			while(j>=m&&i>=a&&fAD>rightAD){
				first=f;
				k=0;
				while(j>=m&&i>=a&&k<blL){
					if(compareIndices(ar,i,j)>0)kSw(ar,f--,i--,ext);
					else{
						kSw(ar,f--,j--,ext);
						rightAD++;
						fAD--;
					}
					k++;
				}
				while(j>=m&&k<blL){
					kSw(ar,f--,j--,ext);
					rightAD++;
					fAD--;
					k++;
				}
				while(i>=a&&k<blL){
					kSw(ar,f--,i--,ext);
					k++;
				}
				if(k==blL)sw2Tgs(ar,first,tC++,xT);
				else{
					shf(ar,a,first+1-k,first+1,false,ext);
					i=a-1+k;
					f=first;
				}
			}
			while(j>=m&&i>=a&&rightAD>=fAD){
				first=right;
				for(k=0;j>=m&&i>=a&&k<blL;k++)
					if(compareIndices(ar,i,j)>0){
						kSw(ar,right--,i--,ext);
						fAD++;rightAD--;
					}else kSw(ar,right--,j--,ext);
				for(;j>=m&&k<blL;k++)kSw(ar,right--,j--,ext);
				for(;i>=a&&k<blL;fAD++,rightAD--,k++)kSw(ar,right--,i--,ext);
				if(k==blL)sw2Tgs(ar,first,tC++,xT);
				else{
					rot(ar,f+1,m,first+1);
					right-=m-(f+1);
					rightAD=0;
				}
			}
		}
		if(j<m&&rightAD==blL&&tC>0)mSwBW(ar,right,f+blL,blL,ext);
		else{
			if(j>=m){
				rot(ar,f+1,m,right+1);
				right-=m-(f+1);
			}
			shf(ar,f+1,right+1-rightAD,right+1,true,ext);
		}
		if(i>=a)shf(ar,a,i+1,i+1+bfL,true,ext);
		if(xT)blCycBW(ar,sS,tC,a-1+bfL);
		else blSlBW(ar,sS,tC);
	}
	function iPM(ar,a,m,b){
		for(let i=a,j=m,k;i<j&&j<b;){
			if(compareIndices(ar,i,j)>0){
				k=bS(ar,j,b,ar[i],true);
				rot(ar,i,j,k);
				i+=k-j;j=k;
			}else i++;
		}
	}
	function iPMBW(ar,a,m,b){
		for(let i=m-1,j=b-1,k;j>i&&i>=a;){
			if(compareIndices(ar,j,i)<1){
				k=bS(ar,a,i+1,ar[j],true);
				rot(ar,k,i+1,j+1);
				j-=i+1-k;
				i=k-1;
			}else j--;
		}
	}
	function iPM2(ar,st,mid,e){
		for(let i=st,m=mid,k=mid,q;m<e;m=k){
			if(compareIndices(ar,m-1,m)<1)return;
			while(i<m-1&&compareIndices(ar,i,m)<1)i++;
			swap(ar,i++,k++);
			while(i<m){
				while(i<m&&k<e&&compareIndices(ar,m,k)>0)swap(ar,i++,k++);
				if(i>=m)break;
				else if(k>=e)return rot(ar,i,m,e);
				else if(k-m>=m-i){
					rot(ar,i,m,k);break;
				}
				q=m;
				while(i<m&&q<k&&compareIndices(ar,q,k)<1)swap(ar,i++,q++);
				rot(ar,m,q,k);
			}
		}
	}
	function iPMSort2(ar,st,e){
		let l=e-st,j;
		for(let i=1;i<l;i*=2){
			for(j=st;j+2*i<e;j+=2*i)iPM2(ar,j,j+i,j+2*i);
			if(j+i<e)iPM2(ar,j,j+i,e);
		}
	}
	function mrWBuf(ar,a,m,b,l){
		let i=a,j=m,k=a-l;
		while(i<m&&j<b)
			if(compareIndices(ar,i,j)<1)kSw(ar,k++,i++,ext);
			else kSw(ar,k++,j++,ext);
		while(j<b)kSw(ar,k++,j++,ext);
		shf(ar,k,i,m,false,ext);
	}
	function dlMr(ar,a,m,b,l){
		if(b-m<=l)mrWBuf(ar,a,m,b,l);
		else{
			let i=a,j=m,k=a-l;
			while(k<i&&i<m)
				if(compareIndices(ar,i,j)<1)kSw(ar,k++,i++,ext);
				else kSw(ar,k++,j++,ext);
			if(k<i)shf(ar,j-l,j,b,false,ext);
			else{
				let i2=m-1,j2=b-1;k=(m-1)+(b-j);
				while(i2>=i&&j2>=j)
					if(compareIndices(ar,i2,j2)>0)kSw(ar,k--,i2--,ext);
					else kSw(ar,k--,j2--,ext);
				while(j2>=j)kSw(ar,k--,j2--,ext);
			}
		}
	}
	function dlMrBW(ar,a,m,b,l){
		let i=m-1,j=b-1,k=b-1+l;
		while(k>j&&j>=m)
			if(compareIndices(ar,i,j)>0)kSw(ar,k--,i--,ext);
			else kSw(ar,k--,j--,ext);
		if(j<m)shf(ar,a,i+1,i+1+l,true,ext);
		else{
			let i2=a,j2=m;i++;j++;k=m-(i-a);
			while(i2<i&&j2<j)
				if(compareIndices(ar,i2,j2)<1)kSw(ar,k++,i2++,ext);
				else kSw(ar,k++,j2++,ext);
			while(i2<i)kSw(ar,k++,i2++,ext);
		}
	}
	function mrWBufStat(ar,a,m,b,p,bw){
		if(m-a<1||b-m<1)return;
		let i,j,k,q;
		if(bw){
			i=b-m-1;j=m-1;k=b-1;
			while(i>=0&&j>=a){
				if(compareIndices(ar,j,p+i)>=0){
					q=bS(ar,a,j+1,ar[p+i],true);
					while(j>=q)swap(ar,k--,j--);
				}
				swap(ar,k--,p+i--);
			}
			while(i>=0)swap(ar,k--,p+i--);
		}else{
			i=0;j=m;k=a;
			while(i<m-a&&j<b){
				if(compareIndices(ar,j,p+i)<0){
					q=bS(ar,j,b,ar[p+i],true);
					while(j<q)swap(ar,k++,j++);
				}
				swap(ar,k++,p+i++);
			}
			while(i<m-a)swap(ar,k++,p+i++);
		}
	}
	function mrExB(ar,a,b,bw){
		let i,j,k,m;
		if(bw){
			i=bfL-1;j=b-1-bfL;k=b-1;
			while(i>=0&&j>=a){
				if(compareValues(cch[i],ar[j])<1){
					m=bS(ar,a,j+1,cch[i],true);
					while(j>=m)write(ar,k--,ar[j--]);
				}
				write(ar,k--,cch[i--]);
			}
			while(i>=0)write(ar,k--,cch[i--]);
		}else{
			i=0;j=a+bfL;k=a;
			while(i<bfL&&j<b){
				if(compareValues(ar[j],cch[i])<0){
					m=bS(ar,j,b,cch[i],true);
					while(j<m)write(ar,k++,ar[j++]);
				}
				write(ar,k++,cch[i++]);
			}
			while(i<bfL)write(ar,k++,cch[i++]);
		}
	}
	function kIt(ar,st,e,xT){
		let i=1,j,effStart=st+bfL,length=e-effStart;
		if(!ext)
			while(i<16){
				for(j=effStart;j+2*i<e;j+=2*i)iPM2(ar,j,j+i,j+2*i);
				if(j+i<e)iPM2(ar,j,j+i,e);
				i*=2;
			}
		while(i<=bfL){
			let l=i;
			for(j=effStart;j+2*i<e;j+=2*i)mrWBuf(ar,j,j+i,j+2*i,l);
			if(j+i<e)mrWBuf(ar,j,j+i,e,l);
			else shf(ar,j-l,j,e,false,ext);
			i*=2;
			for(j=effStart-l;j+2*i<e-l;j+=2*i);
			if(j+i<e-l)dlMrBW(ar,j,j+i,e-l,l);
			else shf(ar,j,e-l,e,true,ext);
			for(j-=2*i;j>=effStart-l;j-=2*i)dlMrBW(ar,j,j+i,j+2*i,l);
			i*=2;
			if(ext&&efM<minVal(i,bfL)){
				arraycopy(cch,0,ar,effStart-efM,efM,false);
				ext=false;
			}
		}
		while(i<length){
			for(j=effStart;j+2*i<e;j+=2*i)blMr(ar,j,j+i,j+2*i,xT);
			if(j+i<e)blMr(ar,j,j+i,e,xT);
			else shf(ar,j-bfL,j,e,false,ext);
			i*=2;
			if(i>=length)return true;
			for(j=st;j+2*i<e-bfL;j+=2*i);
			if(j+i<e-bfL)blMrBW(ar,j,j+i,e-bfL,xT);
			else shf(ar,j,e-bfL,e,true,ext);
			for(j-=2*i;j>=st;j-=2*i)blMrBW(ar,j,j+i,j+2*i,xT);
			i*=2;
		}
		return false;
	}
	function kSr(ar,st,e){
		let length=e-st;
		if(length<129)return iPMSort2(ar,st,e);
		ext=false;bfPs=st;
		for(blL=1;blL*blL<length;blL*=2);
		let ideal=blL*2;
		bfL=fKy(ar,st,e,ideal);
		if(bfL<ideal){
			if(bfL==1)return;
			else if(bfL<=16)return iPMSort2(ar,st,e);
			else return iPMSort2(ar,st,e);
		}
		ideal=length/blL|0;tgL=fKy(ar,st+bfL,e,ideal);
		if(tgL<ideal){
			if(tgL<=16)return iPMSort2(ar,st,e);
			else return iPMSort2(ar,st,e);
		}
		let bufStart=st+tgL,effStart=bufStart+bfL,bufE=st+bfL;
		shf(ar,st,bufE,effStart,false,false);
		let bw=kIt(ar,bufStart,e,false);
		if(bw){
			let eStart=e-bfL;
			mSw(ar,st,eStart,tgL,false);
			mrWBufStat(ar,st,bufStart,eStart,eStart,false);
			iPMSort2(ar,eStart,e);
			let mid=eStart+blL,pos=bS(ar,st,eStart,ar[mid-1],true);
			rot(ar,pos,eStart,mid);
			pos+=blL;
			mSwBW(ar,e-1,pos-1,blL,false);
			mrWBufStat(ar,st,pos-blL,pos,mid,true);
			iPMSort2(ar,mid,e);
			iPMBW(ar,pos,mid,e);
		}else{
			mrWBufStat(ar,bufE,effStart,e,st,false);
			iPMSort2(ar,st,bufE);
			let mid=st+blL,pos=bS(ar,bufE,e,ar[mid],true);
			rot(ar,mid,bufE,pos);
			pos-=blL;
			mSw(ar,st,pos,blL,false);
			mrWBufStat(ar,pos,pos+blL,e,st,false);
			iPMSort2(ar,st,mid);
			iPM(ar,st,mid,pos);
		}
	}
	function kSrDbuf(ar,st,e){
		let length=e-st;
		if(length<17)return iPMSort2(ar,st,e);
		ext=true;bfPs=st;
		for(blL=1;blL*blL<length;blL*=2);
		bfL=blL*2;efM=bfL;
		if(bfL<length/4|0){
			let ideal=length/blL|0;
			tgL=fKy(ar,st,e,ideal);
			if(tgL<ideal){
				if(tgL<=16)return iPMSort2(ar,st,e);
				else return iPMSort2(ar,st,e);
			}
		}else tgL=0;
		cch=new Array(bfL);
		let bufStart=st+tgL,effStart=bufStart+bfL;
		iPMSort2(ar,bufStart,effStart);
		arraycopy(ar,bufStart,cch,0,bfL,true);
		let bw=kIt(ar,bufStart,e,false);
		mrExB(ar,bufStart,e,bw);
		iPM(ar,st,bufStart,e);
	}
	function kSrSbuf(ar,st,e){
		let length=e-st;
		if(l<17)return iPMSort2(ar,st,e);
		ext=true;bfPs=st;
		for(blL=1;blL*blL<l;blL*=2);
		bfL=blL*2;efM=minVal(32,bfL);
		if(efM==bfL)return kSrDbuf(ar,st,e);
		let ideal=blL*2;
		bfL=fKy(ar,st,e,ideal);
		if(bfL<ideal){
			if(bfL==1)return;
			else if(bfL<=16)return iPMSort2(ar,st,e);
			else return iPMSort2(ar,st,e);
		}
		if(bfL<l/4|0){
			ideal=l/blL|0;tgL=fKy(ar,st+bfL,e,ideal);
			if(tgL<ideal){
				if(tgL<=16)return iPMSort2(ar,st,e);
				else return iPMSort2(ar,st,e);
			}
		}else tgL=0;
		let bufStart=st+tgL,effStart=bufStart+bfL,bufE=st+bfL;
		shf(ar,st,bufE,effStart,false,false);
		cch=new Array(efM);
		arraycopy(ar,effStart-efM,cch,0,efM,true);
		let bw=kIt(ar,bufStart,e,false);
		if(bw){
			let eStart=e-bfL;
			mSw(ar,st,eStart,tgL,false);
			mrWBufStat(ar,st,bufStart,eStart,eStart,false);
			iPMSort2(ar,eStart,e);
			let mid=eStart+blL,pos=bS(ar,st,eStart,ar[mid-1],true);
			rot(ar,pos,eStart,mid);
			pos+=blL;
			mSwBW(ar,e-1,pos-1,blL,false);
			mrWBufStat(ar,st,pos-blL,pos,mid,true);
			iPMSort2(ar,mid,e);
			iPMBW(ar,pos,mid,e);
		}else{
			mrWBufStat(ar,bufE,effStart,e,st,false);
			iPMSort2(ar,st,bufE);
			let mid=st+blL,pos=bS(ar,bufE,e,ar[mid],true);
			rot(ar,mid,bufE,pos);
			pos-=blL;
			mSw(ar,st,pos,blL,false);
			mrWBufStat(ar,pos,pos+blL,e,st,false);
			iPMSort2(ar,st,mid);
			iPM(ar,st,mid,pos);
		}
	}
	let nr=1
	for(let i=1;i<len;i++)if(compareIndices(array,i-1,i)<0)nr=0
	if(nr)reversal(array,0,maxVal(len/16|0,64),0)
	kSr(array,0,len)
	return[5,1]
}
function timSort(){
	let array=[...arr];
	TimSorting.sort(new TimSorting(array,len),array,0,len)
	return[5,1]
}
function unstableGrailSort(){
	let array=[...arr];
	function msw(a,b,c,d){
		while(d!=0){
			swap(a,b++,c++);
			d--;
		}
	}
	function rot(a,p,A,B){
		while(A!=0&&B!=0){
			if(A<=B){
				msw(a,p,p+A,A);
				p+=A;B-=A;
			}else{
				msw(a,p+A-B,p+A,B);
				A-=B;
			}
		}
	}
	function gbs(a,p,l,P,L){
		let R=-1,r=l;
		while(R<r-1){
			let m=R+(r-R>>1);
			if(compareIndices(a,p+m,P)>(L?-1:0))r=m;
			else R=m;
		}
		return r;
	}
	function gmrwob(a,p,l1,l2){
		let d=l1<l2;
		while((d?l1:l2)!=0){
			let l=gbs(a,d?p+l1:p,d?l2:l1,p+(d?0:l1+l2-1),d);
			if(l!=(d?0:l1)){
				rot(a,d?p:p+l,l1-(d?0:l),d?l:l2);
				if(d){p+=l;l2-=l}else l1=l
			}
			if((d?l2:l1)==0)break;
			do{if(d){p++;l1--}else l2--}while((d?l1:l2)!=0&&compareIndices(a,d?p:p+l1-1,p+l1+(d?0:l2-1))<1);
		}
	}
	function gmrbl(a,p,bC,bL,aBC,lL){
		if(bC==0)return gmrl(a,p,aBC*bL,lL,0-bL);
		let lOL=bL,pI=bL,rTP;
		for(let kI=1;kI<bC;kI++,pI+=bL){
			rTP=pI-lOL;lOL=gsmrwb(a,p+rTP,lOL,bL);
		}
		rTP=pI-lOL;
		if(lL!=0){
			lOL+=bL*aBC;
			gmrl(a,p+rTP,lOL,lL,-bL);
		}else msw(a,p+rTP,p+rTP-bL,lOL);
	}
	function gmrl(a,p,lL,rL,d){
		let l=0,r=lL;rL+=lL;
		while(r<rL)
			if(l==lL||compareIndices(a,p+l,p+r)>0)swap(a,p+d++,p+r++);
			else swap(a,p+d++,p+l++);
		if(d!=l)msw(a,p+d,p+l,lL-l);
	}
	function gmrr(a,p,lL,rL,d){
		let mP=lL+rL+d-1,r=lL+rL-1,l=lL-1;
		while(l>=0)
			if(r<lL||compareIndices(a,p+l,p+r)>0)swap(a,p+mP--,p+l--);
			else swap(a,p+mP--,p+r--);
		if(r!=mP)while(r>=lL)swap(a,p+mP--,p+r--);
	}
	function gsmrwb(a,p,lOL,bL){
		let d=0-bL,l=0,r=lOL,lE=r,rE=r+bL,ln;
		while(l<lE&&r<rE)
			if(compareIndices(a,p+l,p+r)<1)swap(a,p+d++,p+l++);
			else swap(a,p+d++,p+r++);
		if(l<lE){
			ln=lE-l;
			while(l<lE)swap(a,p+--lE,p+--rE);
		}else ln=rE-r;
		return ln;
	}
	function gbbl(a,p,ln,bL){
		let xD,pr;
		for(let i=1;i<ln;i+=2){
			xD=0;
			if(compareIndices(a,p+i-1,p+i)>0)xD=1;
			swap(a,p+i-3,p+i-1+xD);
			swap(a,p+i-2,p+i-xD);
		}
		if(ln%2!=0)swap(a,p+ln-1,p+ln-3);
		p-=2;pr=2;
		for(;pr<bL;pr*=2){
			let l=0,r=ln-2*pr;
			while(l<=r){
				gmrl(a,p+l,pr,pr,0-pr);
				l+=2*pr;
			}
			let rs=ln-l;
			if(rs>pr)gmrl(a,p+l,pr,rs-pr,0-pr);
			else rot(a,p+l-pr,pr,rs);
			p-=pr;
		}
		let rTB=ln%(2*bL),lOP=ln-rTB;
		if(rTB<=bL)rot(a,p+lOP,rTB,bL);
		else gmrr(a,p+lOP,bL,rTB-bL,bL);
		while(lOP>0){
			lOP-=2*bL;
			gmrr(a,p+lOP,bL,bL,bL);
		}
	}
	function gcbl(a,p,ln,bL,rBL){
		let cL=ln/(2*bL)|0,lO=ln%(2*bL);
		if(lO<=bL){
			ln-=lO;lO=0;
		}
		for(let i=0;i<=cL;i++){
			if(i==cL&&lO==0)break;
			let bP=p+i*2*bL,bC=(i==cL?lO:2*bL)/rBL|0;
			for(let j=1;j<bC;j++){
				let lI=j-1;
				for(let rI=j;rI<bC;rI++){
					let rC=compareIndices(a,bP+lI*rBL,bP+rI*rBL);
					if(rC>0||(rC==0&&compareIndices(a,bP+(lI+1)*rBL-1,bP+(rI+1)*rBL-1)>0))lI=rI;
				}
				if(lI!=j-1)msw(a,bP+(j-1)*rBL,bP+lI*rBL,rBL);
			}
			let aBC=0,lL=0;
			if(i==cL)lL=lO%rBL;
			if(lL!=0)while(aBC<bC&&compareIndices(a,bP+bC*rBL,bP+(bC-aBC-1)*rBL)<0)aBC++;
			gmrbl(a,bP,bC-aBC,rBL,aBC,lL);
		}
		while(--ln>=0)swap(a,p+ln,p+ln-rBL);
	}	
	if(len<16)insertSort(array,0,len);
	else{
		let bL=1,uL;
		for(;bL**2<len;bL*=2,uL=bL);
		gbbl(array,bL,len-bL,uL);
		while(len-bL>(uL*=2))gcbl(array,bL,len-bL,uL,bL);
		binDoubleInsert(array,0,bL);
		gmrwob(array,0,bL,len-bL);
	}
	return[5,1]
}
function grailSort(){
	let array=[...arr];
	class GPair{
		constructor(l,f){this.lol=l;this.lof=f}
		getLOL(){return this.lol}
		getLOF(){return this.lof}
	}
	function gmsw(a,b,c,d){
		while(d--!=0)swap(a,b++,c++);
	}
	function rot(a,p,A,B){
		while(A!=0&&B!=0)
			if(A<=B){
				gmsw(a,p,p+A,A);
				p+=A;B-=A;
			}else{
				gmsw(a,p+A-B,p+A,B);
				A-=B;
			}
	}
	function gbs(a,p,ln,P,L){
		let l=-1,r=ln;
		while(l<r-1){
			let m=l+((r-l)>>1),c=L?-1:0;
			if(compareIndices(a,p+m,P)>c)r=m;
			else l=m;
		}
		return r;
	}
	function jFK(a,p,ln,K){
		let f=1,k=0;
		for(let d=1;d<ln&&f<K;d++){
			let l=gbs(a,p+k,f,p+d,true);
			if(l==f||compareIndices(a,p+d,p+k+l)){
				rot(a,p+k,f,d-(k+f));
				k=d-f;
				rot(a,p+k+l,f++-l,1);
			}
		}
		rot(a,p,k,f);
		return f;
	}
	function gmrwob(a,p,l1,l2){
		let d=l1<l2;
		while((d?l1:l2)!=0){
			let l=gbs(a,d?p+l1:p,d?l2:l1,p+(d?0:l1+l2-1),d);
			if(l!=(d?0:l1)){
				rot(a,d?p:p+l,l1-(d?0:l),d?l:l2);
				if(d){p+=l;l2-=l}else l1=l
			}
			if((d?l2:l1)==0)break;
			do{if(d){p++;l1--}else l2--}while((d?l1:l2)!=0&&compareIndices(a,d?p:p+l1-1,p+l1+(d?0:l2-1))<1);
		}
	}
	function gmrbl(a,P,K,p,C,L,h,B,l){
		if(C==0){
			if(h)gmrl(a,p,B*L,l,0-L);
			else gmrwob(a,p,L*B,l);
			return;
		}
		let lOL=L,lOF=compareIndices(a,P,K)<0?0:1,pI=L,rTP;
		for(let I=1;I<C;I++,pI+=L){
			rTP=pI-lOL;
			let F=compareIndices(a,P+I,K)<0?0:1;
			if(F==lOF){
				if(h)gmsw(a,p+rTP-L,p+rTP,lOL);
				rTP=pI;lOL=L;
			}else if(h){
				let r=gsmrwb2(a,p+rTP,lOL,lOF,L);
				lOL=r.getLOL();lOF=r.getLOF();
			}else{
				let r=gsmrwob(a,p+rTP,lOL,lOF,L);
				lOL=r.getLOL();lOF=r.getLOF();
			}
		}
		rTP=pI-lOL;
		if(l!=0){
			if(lOF!=0){
				if(h)gmsw(a,p+rTP-L,p+rTP,lOL);
				rTP=pI;lOL=L*B;lOF=0;
			}else lOL+=L*B;
			if(h)gmrl(a,p+rTP,lOL,l,-L);
			else gmrwob(a,p+rTP,lOL,l);
		}else if(h)gmsw(a,p+rTP,p+(rTP-L),lOL);
	}
	function gmrl(a,p,fL,hL,d){
		let f=0,r=fL;hL+=fL;
		while(r<hL)
			if(f==fL||compareIndices(a,p+f,p+r)>0)swap(a,p+d++,p+r++);
			else swap(a,p+d++,p+f++);
		if(d!=f)gmsw(a,p+d,p+f,fL-f);
	}
	function gmrr(a,p,fL,hL,d){
		let mP=fL+hL+d-1,r=fL+hL-1,f=fL-1;
		while(f>=0)
			if(r<fL||compareIndices(a,p+f,p+r)>0)swap(a,p+mP--,p+f--);
			else swap(a,p+mP--,p+r--);
		if(r!=mP)while(r>=fL)swap(a,p+mP--,p+r--);
	}
	function gsmrwob(a,p,lOL,lOF,rBL){
		if(rBL==0)return new GPair(lOL,lOF);
		let ln1=lOL,ln2=rBL,tF=1-lOF;
		if(ln1!=0&&compareIndices(a,p+ln1-1,p+ln1)-tF>=0)
			while(ln1!=0){
				let fL=gbs(a,p+ln1,ln2,p,tF!=0);
				if(fL!=0){
					rot(a,p,ln1,fL);
					p+=fL;ln2-=fL;
				}
				if(ln2==0)return new GPair(ln1,lOF);
				do{p++;ln1--;}while(ln1!=0&&compareIndices(a,p,p+ln1)-tF<0);
			}
		return new GPair(ln2,tF);
	}
	function gsmrwb(a,p,lOL,lOF,blL){
		let d=-blL,f=0,r=lOL,fE=r,rE=r+blL,tF=1-lOF;
		while(f<fE&&r<rE)
			if(compareIndices(a,p+f,p+r)-tF<0)write(a,p+d++,a[p+f++]);
			else write(a,p+d++,a[p+r++]);
		let l,fr=lOF;
		if(f<fE){
			l=fE-f;
			while(f<fE)write(a,p+--rE,a[p+--fE]);
		}else{
			l=rE-r;fr=tF;
		}
		return new GPair(l,fr);
	}
	function gsmrwb2(a,p,lOL,lOF,blL){
		let d=-blL,f=0,r=lOL,fE=r,rE=r+blL,tF=1-lOF;
		while(f<fE&&r<rE)
			if(compareIndices(a,p+f,p+r)-tF<0)swap(a,p+d++,p+f++);
			else swap(a,p+d++,p+r++);
		let l,fr=lOF;
		if(f<fE){
			l=fE-f;
			while(f<fE)swap(a,p+--fE,p+--rE);
		}else{
			l=rE-r;fr=tF;
		}
		return new GPair(l,fr);
	}
	function gmrlwb(a,p,fE,rE,d){
		let f=0,r=fE;rE+=fE;
		while(r<rE)
			if(f==fE||compareIndices(a,p+f,p+r)>0)write(a,p+d++,a[p+r++]);
			else write(a,p+d++,a[p+f++]);
		if(d!=f)while(f<fE)write(a,p+d++,a[p+f++]);
	}
	function gmrblwb(a,P,m,p,blC,rBL,aBC,lL){
		if(blC==0)return gmrlwb(a,p,aBC*rBL,lL,0-rBL);
		let lOL=rBL,lOF=compareIndices(a,P,m)<0?0:1,pI=rBL,rTP;
		for(let I=1;I<blC;I++,pI+=rBL){
			rTP=pI-lOL;
			let F=compareIndices(a,P+I,m)<0?0:1;
			if(F==lOF){
				arraycopy(a,p+rTP,a,p+rTP-rBL,lOL);
				rTP=pI;lOL=rBL;
			}else{
				let r=gsmrwb(a,p+rTP,lOL,lOF,rBL);
				lOL=r.getLOL();lOF=r.getLOF();
			}
		}
		rTP=pI-lOL;
		if(lL!=0){
			if(lOF!=0){
				arraycopy(a,p+rTP,a,p+rTP-rBL,lOL);
				rTP=pI;lOL=rBL*aBC;lOF=0;
			}else lOL+=rBL*aBC;
			gmrlwb(a,p+rTP,lOL,lL,0-rBL);
		}else arraycopy(a,p+rTP,a,p+rTP-rBL,lOL);
	}
	function gBBl(a,p,ln,bLn,xb,bP,xB){
		let bB=bLn<xB?bLn:xB;
		while((bB&(bB-1))!=0)bB&=bB-1;
		let xD,pt;
		if(bB!=0){
			arraycopy(a,p-bB,xb,bP,bB,true);
			for(let d=1;d<ln;d+=2){
				xD=0;
				if(compareIndices(a,p+d-1,p+d)>0)xD=1;
				write(a,p+d-3,a[p+d-1+xD]);
				write(a,p+d-2,a[p+d-xD]);
			}
			if(ln%2!=0)write(a,p+ln-3,a[p+ln-1]);
			p-=2;
			for(pt=2;pt<bB;pt*=2){
				let f=0,r=ln-2*pt;
				while(f<=r){
					gmrlwb(a,p+f,pt,pt,0-pt);
					f+=2*pt;
				}
				let s=ln-f;
				if(s>pt)gmrlwb(a,p+f,pt,s-pt,-pt);
				else for(;f<ln;f++)write(a,p+f-pt,a[p+f]);
				p-=pt;
			}
			arraycopy(xb,bP,a,p+ln,bB);
		}else{
			for(let d=1;d<ln;d+=2){
				xD=0;
				if(compareIndices(a,p+d-1,p+d)>0)xD=1;
				swap(a,p+d-3,p+d-1+xD);
				swap(a,p+d-2,p+d-xD);
			}
			if(ln%2!=0)swap(a,p+ln-1,p+ln-3);
			p-=2;pt=2;
		}
		for(;pt<bLn;pt*=2){
			let f=0,r=ln-2*pt;
			while(f<=r){
				gmrl(a,p+f,pt,pt,0-pt);
				f+=2*pt;
			}
			let s=ln-f;
			if(s>pt)gmrl(a,p+f,pt,s-pt,0-pt);
			else rot(a,p+f-pt,pt,s);
			p-=pt;
		}
		let rTB=ln%(2*bLn),fOP=ln-rTB;
		if(rTB<=bLn)rot(a,p+fOP,rTB,bLn);
		else gmrr(a,p+fOP,bLn,rTB-bLn,bLn);
		while(fOP>0){
			fOP-=2*bLn;
			gmrr(a,p+fOP,bLn,bLn,bLn);
		}
	}
	function gCBl(a,P,p,ln,bLn,rBL,h,bu,bP){
		let oL=ln/(2*bLn)|0,fO=ln%(2*bLn);
		if(fO<=bLn){
			ln-=fO;fO=0;
		}
		if(bu!=null)arraycopy(a,p-rBL,bu,bP,rBL,true);
		for(let i=0;i<=oL;i++){
			if(i==oL&&fO==0)break;
			let blP=p+i*2*bLn,blC=(i==oL?fO:2*bLn)/rBL|0;
			binDoubleInsert(a,P,blC+(i==oL?1:0));
			let m=bLn/rBL|0;
			for(let j=1;j<blC;j++){
				let fI=j-1;
				for(let rI=j;rI<blC;rI++){
					let rC=compareIndices(a,blP+fI*rBL,blP+rI*rBL);
					if(rC>0||(rC==0&&compareIndices(a,P+fI,P+rI)>0))fI=rI;
				}
				if(fI!=j-1){
					gmsw(a,blP+(j-1)*rBL,blP+fI*rBL,rBL);
					swap(a,P+(j-1),P+fI);
					if(m==j-1||m==fI)m^=(j-1)^fI;
				}
			}
			let aBC=0,lL=0;
			if(i==oL)lL=fO%rBL;
			if(lL!=0)while(aBC<blC&&compareIndices(a,blP+blC*rBL,blP+(blC-aBC-1)*rBL)<0)aBC++;
			if(bu!=null)gmrblwb(a,P,P+m,blP,blC-aBC,rBL,aBC,lL);
			else gmrbl(a,P,P+m,blP,blC-aBC,rBL,h,aBC,lL);
		}
		if(bu!=null){
			for(let i=ln;--i>=0;)write(a,p+i,a[p+i-rBL]);
			arraycopy(bu,bP,a,p-rBL,rBL);
		}else if(h)while(--ln>=0)swap(a,p+ln,p+ln-rBL);
	}
	function gLSS(a,p,ln){
		for(let d=1;d<ln;d+=2)if(compareIndices(a,p+d-1,p+d)>0)swap(a,p+(d-1),p+d);
		for(let t=2;t<ln;t*=2){
			let f=0,r=ln-2*t;
			for(;f<=r;f+=2*t)gmrwob(a,p+f,t,t);
			let q=ln-f;
			if(q>t)gmrwob(a,p+f,t,q-t);
		}
	}
	function gSort(a,p,ln,b,bP,bL){
		if(ln<=16)return binDoubleInsert(a,p,ln);
		let blL=1;
		while(blL*blL<ln)blL*=2;
		let nK=(ln-1)/blL+1|0,F=jFK(a,p,ln,nK+blL),E=true;
		if(F<nK+blL){
			if(F<4)return gLSS(a,p,ln);
			nK=blL;
			while(nK|=0>F)nK/=2;nK|=0;
			E=false;blL=0;
		}
		let d=blL+nK,bLn=E?blL:nK;
		if(E)gBBl(a,p+d,ln-d,bLn,b,bP,bL);
		else gBBl(a,p+d,ln-d,bLn,null,bP,0);
		while(ln-d>(bLn*=2)){
			let rBL=blL,bBE=E;
			if(!E)
				if(nK>4&&(nK/8|0)*nK>=bLn){
					rBL=nK/2|0;bBE=true;
				}else{
					let cK=1,i=bLn*F/2|0;
					for(;cK<nK&&i!=0;i/=8,i|=0)cK*=2;
					rBL=(2*bLn)/cK|0;
				}
			gCBl(a,p,p+d,ln-d,bLn,rBL,bBE,bBE&&rBL<=bL?b:null,bP);
		}
		binDoubleInsert(a,p,d);
		gmrwob(a,p,d,ln-d);
	}
	function gIPM(a,p,l1,l2){
		if(l1<3||l2<3)return gmrwob(a,p,l1,l2);
		let m=l1<l2?(l1+l2/2|0):(l1/2|0),l1l,l1r;l1l=l1r=gbs(a,p,l1,p+m,true);
		if(l1r<l1&&!compareIndices(a,p+l1r,p+m))l1r=gbs(a,p+l1l,l1-l1l,p+m,false)+l1l;
		let l2l,l2r;l2l=l2r=gbs(a,p+l1,l2,p+m,true);
		if(l2r<l2&&!compareIndices(a,p+l1+l2r,p+m))l2r=gbs(a,p+l1+l2l,l2-l2l,p+m,false)+l2l;
		if(l1l==l1r)rot(a,p+l1r,l1-l1r,l2r);
		else{
			rot(a,p+l1l,l1-l1l,l2l);
			if(l2r!=l2l)rot(a,p+l1r+l2l,l1-l1r,l2r-l2l);
		}
		gIPM(a,p+l1r+l2r,l1-l1r,l2-l2r);
		gIPM(a,p,l1l,l2l);
	}
	function gIPMS(a,s,l){
		for(let d=s+1;d<l;d+=2)if(compareIndices(a,d-1,d)>0)swap(a,d-1,d);
		for(let p=2;p<l;p*=2){
			let f=s,r=l-2*p;
			for(;f<=r;f+=2*p)gIPM(a,f,p,p);
			let e=l-f;
			if(e>p)gIPM(a,f,p,e-p);
		}
	}
	let bt=prompt("Buffer Type(0-2)",0),b=null,bl=0;
	switch(Number(bt)){
		case 1:b=new Array(32);bl=32;break;
		case 2:
			let t=1;
			for(;t**2<len;t*=2);b=new Array(t);bl=t;
		break;
	}
	gSort(array,0,len,b,0,bl);
	return[5,1]
}
function synchronousSqrtSort(){
	let array=[...arr];
	const Bms=new BMS();
	function sMrBw(ar,a,m,b,p,r){
		let i=m-1,j=b-1,c=r?-1:0;
		while(i>=a&&j>=m)
			if(compareIndices(ar,i,j)>c)write(ar,--p,ar[i--]);
			else write(ar,--p,ar[j--]);
		return i+1;
	}
	function bSel(ar,T,a,b,L,t,J){
		for(let i=0;i<minVal(J+1,T.length-t);i++)write(T,t+i,i+(i<=(J/2|0)?0:T.length),true);
		for(let j=a,p=a;j<b-L;j+=L){
			let m=p==j?j+L:j;
			for(let i=m+L;i<b;i+=L)
				if(i!=p){
					let c=compareIndices(ar,i,m);
					if(c<0||(!c&&compareIndices(T,t+(i-a)/L|0,t+(m-a)/L|0)<0))m=i;
				}
			if(m>j)
				if(p==j){
					arraycopy(ar,m,ar,j,L);
					write(T,t+(j-a)/L|0,T[t+(m-a)/L|0]);
					p=m;
				}else{
					Bms.multiSwap(ar,j,m,L);
					swap(T,t+(j-a)/L|0,t+(m-a)/L|0);
				}
		}
	}
	function mrblBW(ar,T,a,b,ti,tb,L){
		let tj=tb-1,mkv=T.length,f=b,a1=f-L,r=compareValues(T[tj],mkv)<0;
		for(;;r=!r){
			do{tj--;a1-=L;}while(tj>=ti&&(r?compareValues(T[tj],mkv)<0:compareValues(T[tj],mkv)>=0));
			if(tj<ti){Bms.shiftBWExt(ar,a,f,f+L);break;}
			f=sMrBw(ar,a1,a1+L,f,f+L,r);
		}
	}
	function main(ar,l){
		if(l<17)return Bms.binaryInsertion(ar,0,l);
		let L=1;
		while(L*L<l)L*=2;
		let m=l%L,a=L+m,b=l,I=b-a,i,j=1,t=new Array(L+m),T=new Array((l-1)/L+1|0);
		Bms.binaryInsertion(ar,0,a);
		arraycopy(ar,0,t,0,a,true);
		for(;j<L;j*=2){
			let p=maxVal(2,j);
			for(i=a;i+2*j<b;i+=2*j)Bms.mergeWithBufFWExt(ar,i,i+j,i+2*j,i-p);
			if(i+j<b)Bms.mergeWithBufFWExt(ar,i,i+j,b,i-p);
			else Bms.shiftFWExt(ar,i-p,i,b);
			a-=p;b-=p;
		}
		let p=I%(2*j);i=b-p;
		if(i+j<b)Bms.mergeWithBufBWExt(ar,i,i+j,b,b+j);
		else Bms.shiftBWExt(ar,i,b,b+j);
		for(i-=2*j;i>=a;i-=2*j)Bms.mergeWithBufBWExt(ar,i,i+j,i+2*j,i+3*j);
		a+=j;b+=j;j*=2;
		for(let ti,tj=4;j<I;j*=2,tj*=2){
			for(i=a,ti=0;i+2*j<b;i+=2*j,ti+=tj)bSel(ar,T,i-L,i+2*j,L,ti,tj);
			let F=i+j<b;p=(b-i)/L|0;
			if(F)bSel(ar,T,i-L,b,L,ti,tj);
			a-=L;b-=L;i-=L;
			if(F)mrblBW(ar,T,i,b,ti,ti+p,L);
			for(i-=2*j,ti-=tj;i>=a;i-=2*j,ti-=tj)mrblBW(ar,T,i,i+2*j,ti,ti+tj,L);
			a+=L;b+=L;
		}
		p=0;i=0;j=a;
		while(i<a&&j<b)
			if(compareValues(t[i],ar[j])<1)write(ar,p++,t[i++]);
			else write(ar,p++,array[j++]);
		while(i<a)write(ar,p++,t[i++]);
	}
	main(array,len)
	return[5,1]
}
function cocktailMergeSort(){
	let array=[...arr];
	let mRL=new TimSorting().minRunLength(len);
	if(len==mRL)cocktailShakerTemp(array,0,len);
	else{
		let i=0,tim=new TimSorting(array,len);
		for(;i<=len-mRL;i+=mRL)cocktailShakerTemp(array,i,i+mRL);
		if(i+mRL>len)cocktailShakerTemp(array,i,len);
		TimSorting.sort(tim,array,0,len);
	}
	return[5,1]
}
function optimizedDualPivotQuickSort(){
	let array=[...arr];
	function dp(a,l,r,d){
		let ln=r-l;
		if(ln<27)return binInsertSort(a,l,r+1);
		let t=ln/d|0,m1=l+t,m2=r-t;
		if(m1<=l)m1=l+1;
		if(m2>=r)m2=r-1;
		if(compareIndices(a,m1,m2)<0){
			swap(a,m1,l);
			swap(a,m2,r);
		}else{
			swap(a,m1,r);
			swap(a,m2,l);
		}
		let p1=a[l],p2=a[r],e=l+1,gr=r-1;
		for(let k=e;k<=gr;k++)
			if(compareValues(a[k],p1)<0)swap(a,k,e++);
			else if(compareValues(a[k],p2)>0){
				while(k<gr&&compareValues(a[gr],p2)>0)gr--;
				swap(a,k,gr--);
				if(compareValues(a[k],p1)<0)swap(a,k,e++);
			}
		let i=gr-e;
		if(i<13)d++;
		swap(a,e-1,l);
		swap(a,gr+1,r);
		dp(a,l,e-2,d);
		dp(a,gr+2,r,d);
		if(i>ln-13&&p1!=p2)
			for(let k=e;k<=gr;k++)
				if(!compareValues(a[k],p1))swap(a,k,e++);
				else if(!compareValues(a[k],p2)){
					swap(a,k,gr--);
					if(!compareValues(a[k],p1))swap(a,k,e++);
				}
		if(p1<p2)dp(a,e,gr,d);
	}	
	dp(array,0,len-1,3);
	return[5,1]
}
function remiSort(){
	let array=[...arr];
	const mwms=new MWMS();
	function cbr(n){
		let a=0,b=minVal(1291,n);
		while(a<b){
			let m=(a+b)/2|0;
			if(m**3>=n)b=m;
			else a=m+1;
		}
		return a;
	}
	function siftDown(array,keys,r,len,a,t){
		let j=r;
		while(2*j+1<len){
			j=2*j+1;
			if(j+1<len){
				let cmp=compareIndices(array,a+keys[j+1],a+keys[j]);
				if(cmp>0||(cmp==0&&compareIndices(keys,j+1,j)>0))j++;
			}
		}
		for(let cmp=compareIndices(array,a+t,a+keys[j]);cmp>0||(cmp==0&&compareValues(t,keys[j])>0);j=(j-1)/2|0,cmp=compareIndices(array,a+t,a+keys[j]));
		for(let t2;j>r;j=(j-1)/2|0){
			t2=keys[j];
			write(keys,j,t,true);
			t=t2;
		}
		write(keys,r,t,true);
	}
	function tableSort(array,keys,a,b){
		let len=b-a;
		for(let i=(len-1)/2|0;i>=0;i--)siftDown(array,keys,i,len,a,keys[i]);
		for(let i=len-1;i>0;i--){
			let t=keys[i];
			write(keys,i,keys[0],true);
			siftDown(array,keys,0,i,a,t);
		}
		for(let i=0;i<len;i++){
			if(compareValues(i,keys[i])){
				let t=array[a+i],j=i,next=keys[i];
				do{
					write(array,a+j,array[a+next]);
					write(keys,j,j,true);
					j=next;next=keys[next];
				}while(compareValues(next,i));
				write(array,a+j,t);
				write(keys,j,j,true);
			}
		}
	}
	function blockCycle(array,buf,keys,a,bLen,bCnt){
		for(let i=0;i<bCnt;i++){
			if(compareValues(i,keys[i])){
				arraycopy(array,a+i*bLen,buf,0,bLen,true);
				let j=i,next=keys[i];
				do{
					arraycopy(array,a+next*bLen,array,a+j*bLen,bLen);
					write(keys,j,j,true);
					j=next;next=keys[next];
				}while(compareValues(next,i));
				arraycopy(buf,0,array,a+j*bLen,bLen);
				write(keys,j,j,true);
			}
		}
	}
	function kWayMerge(array,buf,keys,heap,b,pa,p,bLen,rLen){
		let k=p.length,size=k,a=pa[0],a1=pa[1];
		for(let i=0;i<k;i++)write(heap,i,i,true);
		for(let i=(k-1)/2|0;i>=0;i--)mwms.siftDown(array,heap,pa,heap[i],i,k);
		for(let i=0;i<rLen;i++){
			let min=heap[0];
			write(buf,i,array[pa[min]],true);
			write(pa,min,pa[min]+1,true);
			if(pa[min]==minVal(a+(min+1)*rLen,b))mwms.siftDown(array,heap,pa,heap[--size],0,size);
			else mwms.siftDown(array,heap,pa,heap[0],0,size);
		}
		let t=0,cnt=0,c=0;
		while(pa[c]-p[c]<bLen)c++;
		do{
			let min=heap[0];
			write(array,p[c],array[pa[min]]);
			write(pa,min,pa[min]+1,true);
			write(p,c,p[c]+1,true);
			if(pa[min]==minVal(a+(min+1)*rLen,b))mwms.siftDown(array,heap,pa,heap[--size],0,size);
			else mwms.siftDown(array,heap,pa,heap[0],0,size);
			if(++cnt==bLen){
				write(keys,t++,(c>0)?(p[c]/bLen|0)-bLen-1:-1,true);
				c=cnt=0;
				while(pa[c]-p[c]<bLen)c++;
			}
		}while(size>0);
		while(cnt-->0){
			write(p,c,p[c]-1,true);
			write(array,--b,array[p[c]]);
		}
		write(pa,k-1,b,true);
		write(keys,keys.length-1,-1,true);
		t=0;
		while(keys[t]!=-1)t++;
		for(let i=1,j=a;j<p[0];i++){
			while(p[i]<pa[i]){
				write(keys,t++,p[i]/bLen-bLen|0,true);
				while(keys[t]!=-1)t++;
				arraycopy(array,j,array,p[i],bLen);
				write(p,i,p[i]+bLen,true);
				j+=bLen;
			}
		}
		arraycopy(buf,0,array,a,rLen);
		blockCycle(array,buf,keys,a1,bLen,(b-a1)/bLen|0);
	}
	let a=0,b=len,bLen=cbr(len),rLen=bLen*bLen,rCnt=(len-1)/rLen+1|0;
	if(rCnt<2){
		let keys=new Array(len);
		for(let i=0;i<keys.length;i++)write(keys,i,i,true);
		tableSort(array,keys,a,b);
		return;
	}
	let keys=new Array(rLen),buf=new Array(rLen),heap=new Array(rCnt),p=new Array(rCnt),pa=new Array(rCnt);
	for(let i=0;i<keys.length;i++)write(keys,i,i,true);
	for(let i=a,j=0;i<b;i+=rLen,j++){
		tableSort(array,keys,i,minVal(i+rLen,b));
		write(pa,j,i,true);
	}
	arraycopy(pa,0,p,0,rCnt,true);
	kWayMerge(array,buf,keys,heap,b,pa,p,bLen,rLen);
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function s(m=0,i=0){
	arr=create(count);
	let stp=shuf.start(arr,i),tck=0,ostpl=stp.length;canskip=0;
	if(shufflesholder.style.height=="300px")shufflesholder.click();
	swaps=0;writes=0;canq2=0;names.innerText="Shuffling...";nextsort.innerText="Next: ...";
	let shuffling=setInterval(()=>{
		tck++%5==0&&display(arr)
		if(stp.length){
			playsound=audio.checked;inputdisplay.innerText=""
			for(let i=0;i<=ostpl*.002&&stp.length;i++){
				let c=stp.shift()
				switch(c[0]){
					case"swap":swap(arr,c[1],c[2],true);mark(c[1]);mark(c[2]);break;
					case"set":write(arr,c[1],c[2],true);mark(c[1]);break;
					case"custom":eval(atob(c[1]))(arr,...c.splice(2,1/0));break;
				}
			}
		}else{
			markarray.checked=0;canskip=1;canq2=1;playsound=0
			clearInterval(shuffling);
			names.innerText="currently frozen/crashed";
			setTimeout(()=>{
				names.innerText=sn[m][0]+" ("+(m+1)+"/"+Object.keys(sn).length+")";
				nextsort.innerText="Next: "+sn[(m+1)%Object.keys(sn).length][0];
				inputdisplay.innerText=inputs[i]
				inputdisplay2.innerText=1+i+" "+String.fromCharCode(47)+" "+Object.keys(inputs).length
				rdisp([...sn[m][1](),function(){
					didskip=0;display(arr)
					let stat=finalresult.innerText=="true";
					names.innerText="Verifying...";
					let z=-1,y=setInterval(()=>{
						canskip=0
						if(z>=len){
							clearInterval(y);playsound=false
							setTimeout(()=>{
								if(!loopsort.checked){
									let snl=Object.keys(sn).length
									if(++m==snl){
										if(queue==null)i++;
										i%=Object.keys(inputs).length;m%=snl
									}
								}
								if(nextshuffle.checked){i++
									if(!(i%=Object.keys(inputs).length)){m++
										if(queue!=null){
											m=queue+1;queue=null;
											nextsort.innerText="Next: ...";
										}
									}
									if(queue2!=null){
										i=queue2;queue2=null
									}
									return s(--m,i)
								}
								if(queue2!=null){
									i=queue2;queue2=null
								}
								if(queue==null)s(m,i)
								else{
									s(queue,i);queue=null;
								}
							},3e2)
						}
						for(let n=0;n<len*.03;n++){
							mark(++z+1,stat?"lime":"red")
							sound(arr[z])
							ctx.fillRect(z*bw,count-arr[z],bw,dtype.checked?arr[z]:bw)
						}
					},1e3/45)
				}])
			},5);
		}
	})
}
function set(v){sn.push(v)}
function get(n,cs=0){
	if(n.trim().length==0)return 0;
	if(!isNaN(n))return parseInt(n)-1;
	for(let i=0;i<sn.length;i++)if(sn[i][0].toLowerCase()==n.toLowerCase())return i;
	n=cs?n:n.toLowerCase();
	let offset=[];
	for(let i=0;i<sn.length;i++){
		let v=cs?sn[i][0]:sn[i][0].toLowerCase();offset[i]=[0,i];
		if(n.match(v))return i
		for(let j=0;j<n.length;j++)if(n[j]==v[j])offset[i][0]++
		offset[i][0]/=n.length
		offset[i][0]*=100;
	}
	return offset.sort((a,b)=>b[0]-a[0])[0][1]
}
set(["Iterative Bitonic Sort",iterativeBitonicSort])
set(["Batcher's Bitonic Sort",batcherBitonicSort])
set(["Iterative Bose-Nelson Sort",iterativeBoseNelsonSort])
set(["Recursive Bose-Nelson Sort",recursiveBoseNelsonSort])
set(["Crease Sort",creaseSort])
set(["Iterative Diamond Sort",iterativeDiamondSort])
set(["Recursive Diamond Sort",recursiveDiamondSort])
set(["Fold Sort",foldSort])
set(["Batcher's Merge-Exchange Sort",batcherMergeExchangeSort])
set(["Recursive Odd-Even Merge Sort",recursiveOddEvenMergeSort])
set(["Iterative Pairwise Merge Sort",iterativePairwiseMergeSort])
set(["Recursive Pairwise Merge Sort",recursivePairwiseMergeSort])
set(["Iterative Weave Sort",iterativeWeaveSort])
set(["Recursive Weave Sort",recursiveWeaveSort])
set(["LSD Radix Sort",LSDRadixSort])
set(["MSD Radix Sort",MSDRadixSort])
set(["In-Place LSD Radix Sort",inPlaceLSDRadixSort])
set(["In-Place MSD Radix Sort",inPlaceMSDRadixSort])
set(["L/MSD Radix Sort",LMSDRadixSort])
set(["Index Sort",indexSort])
set(["Bubble Sort",bubbleSort])
set(["Circloid Sort",circloidSort])
set(["Comb Sort",combSort])
set(["Complete Graph Sort",completeGraphSort])
set(["Cocktail Shaker Sort",cocktailShakerSort])
set(["Gnome Sort",gnomeSort])
set(["Left/Left Quick Sort",LLQuickSort])
set(["Left/Right Quick Sort",LRQuickSort])
set(["Odd-Even Sort",oddEvenSort])
set(["Stooge Sort",stoogeSort])
set(["Slope Sort",slopeSort])
set(["Shell Sort",shellSort])
set(["Recursive Shell Sort",recursiveShellSort])
set(["Andrey Astrelin's In-Place Merge Sort",andreySort])
set(["Block-Swap Merge Sort",blockSwapMergeSort])
set(["In-Place Merge Sort",inPlaceMergeSort])
set(["Rotate Merge Sort",rotateMergeSort])
set(["Strand Sort",strandSort])
set(["Weaved Merge Sort",weavedMergeSort])
set(["Weave Merge Sort",weaveMergeSort])
set(["Pancake Sort",pancakeSort])
set(["Max Heap Sort",maxHeapSort])
set(["Min Heap Sort",minHeapSort])
set(["Cycle Sort",cycleSort])
set(["Fun Sort",funSort])
set(["Asteraceae Sort",asteraceaeSort])
set(["Awkward Sort",awkwardSort])
set(["Chinotto Sort",chinottoSort])
set(["Circle Merge Sort",circleMergeSort])
set(["Clamber Sort",clamberSort])
set(["Cocktail Grate Sort",cocktailGrateSort])
set(["Cocktail Push Sort",cocktailPushSort])
set(["Dandelion Sort",dandelionSort])
set(["Float Sort",floatSort])
set(["Iterative Quick Sort",iterativeQuickSort])
set(["Index Quick Sort",indexQuickSort])
set(["Pseudo Heap Sort",pseudoHeapSort])
set(["Iterative Circle Sort",iterativeCircleSort])
set(["Recursive Circle Sort",recursiveCircleSort])
set(["Left/Left Quick Sort (Middle Pivot)",LLQuickSortMiddlePivotSort])
set(["Push Sort",pushSort])
set(["Reflection Sort",reflectionSort])
set(["Split Center Sort",splitCenterSort])
set(["Wiggle Sort",wiggleSort])
set(["Zipper Sort",zipperSort])
set(["Pairwise Circle Sort",pairwiseCircleSort])
set(["Iterative Sinking Merge Sort",iterativeSinkingMergeSort])
set(["Recursive Sinking Merge Sort",recursiveSinkingMergeSort])
set(["Cocktail Shell Sort",cocktailShellSort])
set(["Index Merge Sort",indexMergeSort])
set(["Mob Merge Sort",mobMergeSort])
set(["Modulo Merge Sort",moduloMergeSort])
set(["Split-16 Merge Sort",split16MergeSort])
set(["Cube Root Quick Sort",cbrtQuickSort])
set(["Apollyon Sort",apollyonSort])
set(["Optimized Pancake Sort",optimizedPancakeSort])
set(["Magnetica Quick Sort",magneticaQuickSort])
set(["Cocktail Peel Sort",cocktailPeelSort])
set(["Ecolo Sort",ecoloSort])
set(["Fall Sort",fallSort])
set(["Heavy Heap Sort",heavyHeapSort])
set(["Sandpaper Sort",sandPaperSort])
set(["Recursive Burning Sort",recursiveBurningSort])
set(["Corrupt Sort",corruptSort])
set(["Circle Halver Sort",circleHalverSort])
set(["Iterative Pairwise Sort",iterativePairwiseSort])
set(["Recursive Pairwise Sort",recursivePairwiseSort])
set(["Iterative [4,4] Van Voorhis Sort",iterativeVanVoorhisSort])
set(["Rotate LSD Radix Sort",rotateLSDRadixSort])
set(["Dig Sort",digSort])
set(["Cityscape Sort",cityscapeSort])
set(["Iterative Cleric Sort",iterativeClericSort])
set(["Recursive Cleric Sort",recursiveClericSort])
set(["Debris Sort",debrisSort])
set(["Evub Sort",evubSort])
set(["Iterative Firing Squad Sort",iterativeFiringSquadSort])
set(["Recursive Firing Squad Sort",recursiveFiringSquadSort])
set(["Ford Sort",fordSort])
set(["Future Sort",futureSort])
set(["Iterative Pop Sort",iterativePopSort])
set(["Jump Down Sort",jumpDownSort])
set(["Monolithic Clurge Sort",monolithicClurgeSort])
set(["Pairwise Comb Sort",pairwiseCombSort])
set(["Pancake Quick Sort",pancakeQuickSort])
set(["Pop Pop Sort",popPopSort])
set(["Swapless Push Sort",swaplessPushSort])
set(["Rebound Sort",reboundSort])
set(["Rubble Sort",rubbleSort])
set(["Search Sort",searchSort])
set(["Selection Sort",selectionSort])
set(["Iterative Shircle Sort",iterativeShircleSort])
set(["Recursive Shircle Sort",recursiveShircleSort])
set(["X Pattern Sort",XSort])
set(["Block Shell Sort",blockShellSort])
set(["Rotate MSD Radix Sort",rotateMSDRadixSort])
set(["Flash Sort",flashSort])
set(["American Flag Sort",americanFlagSort])
set(["Classic 3-Smooth Comb Sort",classic3SmoothCombSort])
set(["Iterative 3-Smooth Comb Sort",iterative3SmoothCombSort])
set(["Recursive 3-Smooth Comb Sort",recursive3SmoothCombSort])
set(["Binary Double Insertion Sort",binaryDoubleInsertionSort])
set(["Ecta Sort",ectaSort])
set(["Flan Sort",flanSort])
set(["Circular Grail Sort",circularGrailSort])
set(["Poplar Heap Sort",poplarHeapSort])
set(["Adaptive Grail Sort",adaptiveGrailSort])
set(["Intro Sort",introSort])
set(["Triangular Heap Sort",triangularHeapSort])
set(["Laziest Stable Sort",laziestStableSort])
set(["Lazierest Stable Sort",lazierestSort])
set(["Binary Quick Sort",binaryQuickSort])
set(["Static Sort",staticSort])
set(["Binary Gnome Sort",binaryGnomeSort])
set(["Dual-Pivot Quick Sort",dualPivotQuickSort])
set(["Optimized Dual-Pivot Quick Sort",optimizedDualPivotQuickSort])
set(["Shove Sort",shoveSort])
set(["Quad Stooge Sort",quadStoogeSort])
set(["Insertion Sort",insertionSort])
set(["Forced Stable Quick Sort",forcedStableQuickSort])
set(["Optimized Stooge(Studio)Sort",optimizedStoogeSortStudio])
set(["Swapless Bubble Sort",swaplessBubbleSort])
set(["Gravity Sort",gravitySort])
set(["Table Sort",tableSort])
set(["Binary Merge Sort",binaryMergeSort])
set(["Buffer Partition Merge(BPM)Sort",bufferPartitionMergeSort])
set(["Binary Insertion Sort",binaryInsertionSort])
set(["Fifth Merge Sort",fifthMergeSort])
set(["Chalice Sort",chaliceSort])
set(["Block Selection Sort",blockSelectionSort])
set(["Iterative Intro Circle Sort",iterativeIntroCircleSort])
set(["Recursive Intro Circle Sort",recursiveIntroCircleSort])
set(["Median Merge Sort",medianMergeSort])
set(["Merge-Insertion Sort",mergeInsertionSort])
set(["Hyrbid Comb Sort",hyrbidCombSort])
set(["Flux Sort",fluxSort])
set(["Quad Sort",quadSort])
set(["Sqrt Sort",sqrtSort])
set(["Optimized Andrey/Yuji Sort",optimizedYujisBufferedMergeSort])
set(["Grit Sort",gritSort])
set(["Matrix Sort",matrixSort])
set(["Kota Sort",kotaSort])
set(["Tim Sort",timSort])
set(["Unstable Grail Sort",unstableGrailSort])
set(["Grail Sort",grailSort])
set(["Synchronous Sqrt Sort",synchronousSqrtSort])
set(["Cocktail Merge Sort",cocktailMergeSort])
set(["Remi Sort",remiSort])
//set(["test Sort",testSort])
sn.sort((a,b)=>a[0].localeCompare(b[0]))
const inputs={0:"Random",1:"Reversed",2:"Slightly",3:"Sorted",4:"Naive Random",5:"Shuffled Tail",6:"Shuffled Head",7:"Shifted Element",8:"Noisy",9:"Shuffled Odds",10:"Final Merge Pass",11:"Shuffled Final Merge",12:"Shuffled Half",13:"Partitioned",14:"Sawtooth",15:"Pipe Organ",16:"Final Bitonic Pass",17:"Interlaced",18:"Double Layered",19:"Final Radix Pass",20:"Real Final Radix",21:"Recursive Final Radix",22:"Half Rotation",23:"Half Reversed",24:"Logarithmic Slopes",25:"Heapified",26:"Triangular Heapified",27:"Circle Pass",28:"Final Pairwise Pass",29:"Recursive Reversal",30:"Gray Code Fractal",31:"Sierpinski Triangle",32:"Triangular",33:"Quicksort Adversary",34:"Grailsort Adversary",35:"Modulo",36:"Quadratic",37:"Cubic",38:"Bit Reversal",39:"Random Block",40:"Block Reverse",41:"Sine Wave",42:"Partial Merge",43:"Many Similar",44:"Perlin Noise",45:"Bell Curve",46:"Ruler",47:"Blancmange Curve",48:"Cantor Function",49:"Sum of Divisors",50:"FSD",51:"Decreasing Random",52:"Euler's Totient Function"}
function hold(e){
	["touchstart","mousedown"].forEach(m=>e.addEventListener(m,v=>e.style.opacity=.5));
	["touchend","mouseup","mouseout"].forEach(m=>e.addEventListener(m,v=>e.style.opacity=1));
}
function appendTo(parent,text,func){
	let a=document.createElement("div");
	a.className="selectbtn";a.textContent=text;hold(a)
	if(typeof func=="function")a.onclick=func
	else{a.onclick=function(){queue=get(text);nextsort.innerText="Next: "+text;cancel=1;setTimeout(()=>cancel=0)}}
	parent.appendChild(a)
}
sn.forEach(e=>{
	let name=e[0].toLowerCase();
	appendTo(sortsholder,e[0]);
	if(name.match("merge"))appendTo(mergesortsholder,e[0]);
	if(name.match("quick"))appendTo(quicksortsholder,e[0]);
	if(name.match("recur"))appendTo(recursortsholder,e[0]);
	if(name.match("itera"))appendTo(itersortsholder,e[0]);
	if(name.match("cocktail"))appendTo(cocktailsortsholder,e[0]);
	if(name.match("binary"))appendTo(binarysortsholder,e[0]);
})
Object.values(inputs).forEach((e,i)=>{
	appendTo(shufflesholder,e,function(){
		inputdisplay2.innerText=(i+1)+" "+String.fromCharCode(47)+" "+Object.keys(inputs).length;
		queue2=i;cancel=1;setTimeout(()=>cancel=0);
	})
})
Array.from(document.querySelectorAll("div.topicname")).map((e,i)=>{
	let ch=document.querySelectorAll("div.btnholder")[i]
	e.onclick=function(){
		if(cancel||!canq2&&e.textContent.substr(0,8)=="Shuffles")return;
		let h=parseFloat(window.getComputedStyle(ch).getPropertyValue("opacity"))==1
		ch.style.height=(h?0:300)+"px";ch.style.opacity=h?0:1;ch.style.padding=(h?0:3)+"px 0px";
		document.querySelectorAll("div.space")[i].style.display=h?"none":"block";
	}
})
let req=get("tim");if(Object.values(sn).map(e=>e[0].toLowerCase()).indexOf("test sort")>=0)req=get("test")
s(req)
/*
to do: clean remi sort
folder: hybrids
at 200 sorts do a cleaning
*/
function testallsorts(){
	arr=create(count);
	for(let i=0;i<len;i++)swap(arr,i,random()*(len-i)+i,true);
	sn.forEach(sort=>{
		sort[1]();
		let tmp=[...arr];
		logs.splice(0,1/0).forEach(e=>{
			let c=e.map(format)
			switch(c[0]){
				case"swap":swap(tmp,c[1],c[2],true);break;
				case"set":write(tmp,c[1],c[2],true);break;
				case"msw":multiSwap(tmp,c[1],c[2],true);break;
				case"rev":reversal(tmp,c[1],c[2],true);break;
				case"insert":insertTo(tmp,c[1],c[2],true);break;
				case"custom":eval(atob(c[1]))(tmp,...c.splice(2,1/0));break;
			}
		})
		if(!isSorted(tmp.splice(0,1/0)))console.log(sort[0]);else console.log("sorted")
	})
}
//testallsorts()
console.log("no issues")
		</script>
	</body>
</html>