<!DOCTYPE html>
<html>
	<head>
		<title></title>
		<meta name="viewport"content="width=device-width,initial-scale=1">
		<style>
			body{
				overflow-y:scroll;
				padding:0;
				margin:0 auto;
				zoom:.6;
			}
			div.holder{display:flex}
			#cvs{
				background:#000;
				aspect-ratio:auto;
			}
			td.lfa{text-align:right}
			td,#names,.topicname,#nextsort{
				font-family:monospace;
				color:#fff;
			}
			fieldset{width:fit-content}
			div.btnholder{
				transition-timing-function:linear;
				transition-duration:.2s;
				border-radius:4px;
				background:rgb(29,42,53);
				border:3px black solid;
				height:0px;
				opacity:0;
				margin:0 5;
				overflow:scroll;
				width:fit-content;
			}
			div.selectbtn{
				color:#fff;
				background:rgb(4,170,109);
				border-radius:10px;
				padding:3px;
				margin:3px;
				border:1px black solid;
			}
			div.topicname{
				margin:5px;
				border:2px dashed grey;
				padding:2px;
				text-align:center;
			}
			div.space{display:none;}
		</style>
	</head>
	<body style="background:rgb(14,21,26)">
		<br>
		<span id=names></span>
		<div class=holder>
			<fieldset>
				<table>
					<tr>
						<td colspan=2 style='text-align:center'>Options</td>
					</tr>
					<tr>
						<td id=m0>bar</td>
						<td><input type=checkbox oninput='m0.innerText=dtype.checked?"bar":"pixel"'id=dtype checked/></td>
					</tr>
					<tr>
						<td>loop</td>
						<td><input type=checkbox id=loopsort /></td>
					</tr>
					<tr>
						<td>mark</td>
						<td><input type=checkbox id=markarray checked/></td>
					</tr>
					<tr>
						<td>pause</td>
						<td><input type=checkbox id=pause /></td>
					</tr>
					<tr>
						<td>zoom (25-200)</td>
						<td>
							<input style='width:40px'value=60 type=number oninput='if(this["value"]>=25&&this["value"]<=200)document.body.style.zoom=this["value"]/100'/>
						</td>
					</tr>
					<tr>
						<td>skip</td>
						<td>
							<button style='width:40px'onclick='canskip&&arr.sort((a,b)=>a-b)&&(didskip=true)'>btn</button>
						</td>
					</tr>
				</table>
			</fieldset>
			<fieldset>
				<table>
					<tr>
						<td colspan=2 style='text-align:center'>Info</td>
					</tr>
					<tr>
						<td>Elements</td>
						<td class=lfa id=elementcount></td>
					</tr>
					<tr>
						<td>FPS</td>
						<td class=lfa id=fpsdisplay>60</td>
					</tr>
					<tr>
						<td>Swaps</td>
						<td class=lfa id=swapdisplay>0</td>
					</tr>
					<tr>
						<td>Writes</td>
						<td class=lfa id=writedisplay>0</td>
					</tr>
					<tr>
						<td>Input</td>
						<td id=inputdisplay></td>
					</tr>
				</table>
			</fieldset>
			<fieldset>
				<table>
					<tr>
						<td colspan=2 style='text-align:center'>Debug</td>
					</tr>
					<tr>
						<td>Frame</td>
						<td class=lfa id=framecount></td>
					</tr>
					<tr>
						<td>Rate</td>
						<td class=lfa id=framerate></td>
					</tr>
					<tr>
						<td>Sorted</td>
						<td class=lfa id=finalresult></td>
					</tr>
					<tr>
						<td>Duration</td>
						<td class=lfa id=duration></td>
					</tr>
					<tr>
						<td>Estim Finish</td>
						<td class=lfa id=estimated></td>
					</tr>
				</table>
			</fieldset>
		</div>
		<div class=holder>
			<div>
				<canvas id=cvs></canvas>
				<div id=nextsort>Next: ...</div>
			</div>
			<div>
				<div class=topicname>Sorts<div class=space>&nbsp;</div><div class=holder><div id=sortsholder class=btnholder></div></div></div>
				<div class=topicname>Merge<div class=space>&nbsp;</div><div class=holder><div id=mergesortsholder class=btnholder></div></div></div>
				<div class=topicname>Quick<div class=space>&nbsp;</div><div class=holder><div id=quicksortsholder class=btnholder></div></div></div>
				<div class=topicname>Cocktail<div class=space>&nbsp;</div><div class=holder><div id=cocktailsortsholder class=btnholder></div></div></div>
				<div class=topicname>Recursive<div class=space>&nbsp;</div><div class=holder><div id=recursortsholder class=btnholder></div></div></div>
				<div class=topicname>Iterative<div class=space>&nbsp;</div><div class=holder><div id=itersortsholder class=btnholder></div></div></div>
			</div>
		</div>
		<br>
		<script>
window.onresize=resize;
window.onblur=function(){pause.checked=true}
window.onfocus=function(){pause.checked=false}
const ctx=cvs.getContext("2d"),count=512,len=count,{random,ceil,floor,round,sqrt,cbrt,log,abs,pow,clz32}=Math,math=Math;
let swaps=0,writes=0,bw=(maxVal(window.innerWidth,window.innerHeight)/minVal(window.innerWidth,window.innerHeight)).toFixed(2),arr,canskip=1,didskip=0;
const logs=[],sn=[];
let queue;
let curDur=Date.now(),dcd=false;
function resize(){
	bw=(maxVal(window.innerWidth,window.innerHeight)/minVal(window.innerWidth,window.innerHeight)).toFixed(2);let horizontal=maxVal(window.innerWidth,window.innerHeight),vertical=minVal(window.innerWidth,window.innerHeight);Array.from(document.getElementsByTagName("td")).map(e=>e.style.fontSize=horizontal/50+"px");names.style.fontSize=horizontal/50+"px";cvs.width=count*bw;cvs.height=count;cvs.style.width=horizontal*.75+"px";cvs.style.height=vertical*.75+"px";elementcount.innerText=count;
}
resize()
const fps=(()=>{
	let elapsed=Date.now(),el2=Date.now(),frame=0,fps=60;
	let update=()=>{
		let rate=1;
		if(Date.now()-elapsed<=1e3/rate)frame+=rate
		else{
			elapsed=Date.now()
			fps=frame
			fpsdisplay.innerText=frame
			frame=0
		}
		if(Date.now()-el2>=1e3/16){
			el2=Date.now()
			swapdisplay.innerText=swaps.toLocaleString()
			writedisplay.innerText=writes.toLocaleString()
			dcd&&(duration.innerText=((Date.now()-curDur)/1000).toFixed(1)+"s");
		}
		requestAnimationFrame(update)
	}
	requestAnimationFrame(update)
	return{g:()=>fps}
})();
const isSorted=a=>a.every((e,i)=>!i||a[i-1]<=e);
const rangeSorted=(a,s,e)=>a.every((v,i)=>!i||a[i-1]<=v||i>=e);
function display(a){
	ctx.clearRect(0,0,cvs.width,cvs.height)
	ctx.fillStyle="#fff";
	for(let i=0;i<len;i++)ctx.fillRect(i*bw,count-a[i],bw,dtype.checked?a[i]:bw)
}
function mark(i,after){
	if(fps.g()>=30){
		ctx.fillStyle="#f00";
		ctx.fillRect(i*bw,count-arr[i],bw,dtype.checked?arr[i]:bw)
	}
	if(after)ctx.fillStyle=after;
}
function format(e){
	if(parseFloat(e)+""!=="NaN")
		return parseFloat(e);
	else return e
}
function rdisp(args){
	if(args.length==3){var[interval,m,onfinish]=args,refresh=24
	}else if(args.length==4){var[interval,m,refresh,onfinish]=args}else return;
	let elapsed=Date.now();markarray.checked=m;
	let updts=0,avrge=0,ticks=0,frames=0,clen=logs.length,tr=maxVal(len*.001,clen*.0005)|0,tmp=[...arr],orlen=clen
	if(interval<0){tr=len*abs(interval)|0;interval=10}
	logs.forEach(e=>{
		let c=e.split(",").map(format)
		switch(c[0]){
			case"swap":swap(tmp,c[1],c[2]);break;
			case"set":tmp[c[1]]=c[2];break;
			case"multiSwap":multiSwap(tmp,c[1],c[2],0);break;
			case"reversal":reversal(tmp,c[1],c[2],0);break;
			case"insert":insertTo(tmp,c[1],c[2],0);break;
			case"custom":eval(atob(c[1]))(tmp,...c.splice(2,1e300));break;
		}
	})
	finalresult.innerText=isSorted(tmp);finalresult.style.color=isSorted(tmp.splice(0,Infinity))?"#fff":"#f00";
	swaps=0;writes=0;dcd=true;curDur=Date.now();
	let n=setInterval(()=>{
		if(pause.checked)return;
		if(Date.now()-elapsed>1e3/refresh){
			elapsed=Date.now()
			display(arr)
			perms=0
			framecount.innerText=(orlen-clen).toLocaleString()+" / "+orlen.toLocaleString();
			framerate.innerText=frames+"/s"
			if(ticks++%5==0)
				estimated.innerText=(avrge/updts-3.5).toFixed(1)+"s";
		}
		for(let rate=0;rate<=tr;rate++){
			updts++;frames++
			setTimeout(()=>frames--,1e3)
			avrge+=orlen/frames
			if(clen--&&!didskip){
				let c=logs.shift().split(",").map(format)
				switch(c[0]){
					case"swap":swap(arr,c[1],c[2],1);break;
					case"set":write(arr,c[1],c[2]);mark(c[1]);break;
					case"multiSwap":multiSwap(arr,c[1],c[2],0);break;
					case"reversal":reversal(arr,c[1],c[2],0);break;
					case"insert":insertTo(arr,c[1],c[2],0);break;
					case"custom":eval(atob(c[1]))(arr,...c.splice(2,1e300));break;
				}
			}else{
				clearArr(logs)
				arr.sort((a,b)=>a-b);
				clearInterval(n)
				onfinish()
				dcd=false
				setTimeout(()=>{
					finalresult.innerText=framecount.innerText=framerate.innerText="...";
				},5)
				break;
			}
		}
	},interval)
	let ratio=orlen/count|0;
	if(ratio>=100)
		console.log(names.innerText,"\nneeds optimization\n",ratio)
}
function create(c){
	return Array(c).fill().map((e,i)=>++i)
}
/* Sauces: 
* https://github.com/Gaming32/ArrayV/blob/main/src/main/java/io/github/arrayv/sorts/
* https://github.com/Gaming32/ArrayV-Extra-Sorts/blob/main/src/main/java/io/github/arrayv/sorts/
* https://github.com/Gaming32/ArrayV/tree/main/src/main/java/io/github/arrayv/utils
* https://github.com/PCBoyGames/ArrayV-v4.0/tree/ad703423641022a396437e2025405916f2435b13/src/sorts
* https://github.com/PCBoyGames/ArrayV-v4.0/tree/ad703423641022a396437e2025405916f2435b13/src/utils
*/
const Rots={
	swapBlocksBackwards:function(ar,a,b,l,r=1){
		let func=r?rswap:swap;
		for(let i=0;i<l;i++)
			func(ar,a+l-i-1,b+l-i-1);
	},
	blockSwap:function(ar,a,b,l,r=1){
		let func=r?rswap:swap;
		for(let i=0;i<l;i++)
			func(ar,a+i,b+i);
	},
	shiftForwards:function(a,s,l,r=1){
		let func=r?rset:write;
		let t=a[s];
		for(let i=0;i<l;i++)
			func(a,s+i,a[s+i+1]);
		func(a,s+l,t);
	},
	shiftBackwards:function(a,s,l,r=1){
		let func=r?rset:write;
		let t=a[s+l];
		for(let i=l;i>0;i--)
			func(a,s+i,a[s+i-1]);
		func(a,s,t);
	},
	mapIndex:function(i,n,l){
		return(i-n+l)%l;
	},
	swap:function(ar,a,v,r=1){
		let func=r?rset:write;
		let old=ar[a];
		func(ar,a,v);
		return old;
	},
	griesMills:function(a,p,A,B,r=1){
		while(A!=0&&B!=0){
			if(A<=B){
				this.blockSwap(a,p,p+A,A,r);
				p+=A;
				B-=A;
			}else{
				this.blockSwap(a,p+(A-B),p+A,B,r);
				A-=B;
			}
		}
	},
	threeReversal:function(a,p,A,B,r=1){
		reversal(a,p,p+A-1,r);
		reversal(a,p+A,p+A+B-1,r);
		reversal(a,p,p+A+B-1,r);
	},
	holyGriesMills:function(a,p,A,B,r=1){
		while(A>1&&B>1){
			while(A<=B){
				this.blockSwap(a,p,p+A,A,r);
				p+=A;
				B-=A;
			}
			if(A<=1||B<=1)break;
			while(A>B){
				this.swapBlocksBackwards(a,p+A-B,p+A,B,r);
				A-=B;
			}
		}
		if(lenA==1)
			this.shiftForwards(a,p,B,r);
		else if(lenB==1)
			this.shiftBackwards(a,p,A,r);
	},
	helium:function(a,p,A,B,r=1){
		while(B>1&&A>1)
			if(B<A){
				this.blockSwap(a,p,p+A,B,r);
				p+=B;
				A-=B;
			}else{
				this.swapBlocksBackwards(a,p,p+B,A,r);
				B-=A;
			}
		if(B==1)this.shiftBackwards(a,p,A,r);
		else if(A==1)this.shiftForwards(a,p,B,r);
	},
	cycleReverse:function(ar,p,A,B,r=1){
		if(A<1||B<1)return;
		let a=p,b=p+A-1,c=p+A,d=p+A+B-1;
		let s;
		let func=r?rset:write;
		let func2=r?rswap:swap;
		while(a<b&&c<d){
			s=ar[b];
			func(ar,b--,ar[a]);
			func(ar,a++,ar[c]);
			func(ar,c++,ar[d]);
			func(ar,d--,s);
		}
		while(a<b){
			s=ar[b];
			func(ar,b--,ar[a]);
			func(ar,a++,ar[d]);
			func(ar,d--,s);
		}
		while(c<d){
			s=ar[c];
			func(ar,c++,ar[d]);
			func(ar,d--,ar[a]);
			func(ar,a++,s);
		}
		if(a<d){
			if(d-a>2)reversal(ar,a,d,r);
			else func2(ar,a,d);
		}
	},
	juggling:function(a,p,A,B,r=1){
		let l=A+B;
		A%=l;
		if(A==0)return;
		let func=r?rswap:swap;
		for(let c=0,i=0,v=a[p+i],s=i;c<l;c++){
			let n=this.mapIndex(i,A,l);
			v=func(a,p+n,v);
			if(n==s){
				s=i=this.mapIndex(i,1,l);
				v=a[p+i];
			}else
				i=n;
		}
	},
	bridge:function(a,p,l,b,r=1){
		if(l<1||b<1)return;
		let pta=p,ptb=p+l,ptc=p+b,ptd=ptb+b;
		let func=r?rset:write;
		if(l<b){
			let bridge=b-l;
			if(bridge<l){
				let loop=l;
				let swap=new Array(bridge);
				arraycopy(a,ptb,swap,0,bridge,r);
				while(loop-->0){
					func(a,--ptc,a[--ptd]);
					func(a,ptd,a[--ptb]);
				}
				arraycopy(swap,0,a,pta,bridge);
			}else{
				let swap=new Array(l);
				arraycopy(a,pta,swap,0,l,r);
				arraycopy(a,ptb,a,pta,b,r);
				arraycopy(swap,0,a,ptc,l);
			}
		}else if(b<l){
			let bridge=l-b;
			if(bridge<b){
				let loop=b;
				let swap=new Array(bridge);
				arraycopy(a,ptc,swap,0,bridge,r);
				while(loop-->0){
					func(a,ptc++,a[pta]);
					func(a,pta++,a[ptb++]);
				}
				arraycopy(swap,0,a,ptd-bridge,bridge);
			}else{
				let swap=new Array(b);
				arraycopy(a,ptb,swap,0,b,r);
				while(l-->0)
					func(a,--ptd,a[--ptb]);
				arraycopy(swap,0,a,pta,b);
			}
		}else
			while(left-->0)
				(r?rswap:swap)(a,pta++,ptb++);
	},
	neon:function(a,p,A,B,r=1){
		let end=p+A+B;
		let func=r?rset:write;
		while(A>0&&B>0){
			if(A<B){
				for(let i=0;i<A;i++){
					let t=a[p+i],j=p+i+A;
					for(;j<end;j+=A)
						func(a,j-A,a[j]);
					func(array,j-lenA,t);
				}
				p+=B;
				B%=A;
				A-=B;
			}else{
				for(let i=0;i<B;i++){
					let t=a[p+i+A],j=p+i+A-B;
					for(;j>=p;j-=B)
						func(a,j+B,a[j]);
					func(a,j+B,t);
				}
				end=p+B;
				A%=B;
				B-=A;
			}
		}
	},
	foolish:function(a,p,A,B,r=1){
		if(A<B)
			for(let i=0;i<A;i++)
				insertTo(a,p,p+A+B-1,r);
		else
			for(let i=0;i<B;i++)
				insertTo(a,p+A+B-1,p,r);
	},
	morefoolish:function(a,p,A,B,r=1){
		if(A>B)
			for(let i=0;i<A;i++)
				insertTo(a,p,p+A+B-1,r);
		else
			for(let i=0;i<B;i++)
				insertTo(a,p+A+B-1,p,r);
	},
	radon:function(a,p,A,B,r=1){
		let func=r?rswap:swap;
		let min=Math.min(A,B),max=Math.max(A,B),bridge=max-min;
		if(min<1)return;
		if(bridge<=min)reversal(a,p+min,p+max-1);
		for(let i=0;i<min;i++)func(a,p+i,p+max+i);
		if(bridge==0)return;
		if(A>B){
			if(bridge>min)
				this.cycleReverse(a,p+min,bridge,min,r);
			else{
				let swap,a1=p+min,b=p+max,c=b+min-1;
				while(b<c){
					swap=a[c];
					func(a,c--,array[a1]);
					func(a,a1++,array[b]);
					func(a,b++,swap);
				}
				reversal(a,a1,c);
			}
		}else{
			if(bridge>min){
				this.cycleReverse(a,p,min,bridge,r);
			}else{
				let swap,a1=p,b=a+min-1,c=a+max-1;
				while(a<b){
					swap=array[a1];
					func(a,a1++,a[c]);
					func(a,c--,a[b]);
					func(a,b--,swap);
				}
				reversal(a,a1,c);
			}
		}
	},
	centered:function(a,p,A,B,r=1){
		if(A<1||B<1)return;
		if(A<B){
			let h=(B-A)/2|0;
			this.blockSwap(a,p,p+A+h,lenA,r);
			this.centered(a,p+A+h,A,B-A-h,r);
			this.centered(a,p,A,h,r);
		}else if(A==B){
			this.blockSwap(a,p,p+A,A,r);
		}else{
			let h=(A-B)/2|0;
			this.blockSwap(a,p+h,p+A,lenB,r);
			this.centered(a,p,h,B,r);
			this.centered(a,p+h+B,A-B-h,B,r);
		}
	},
	adaptable:function(a,p,A,B,r=1){
		if(A==0||B==0)return;
		if(A%B==0||B%A==0)this.holyGriesMills(a,p,A,B,r);
		else this.cycleReverse(a,p,A,B,r);
	}
}
const IndexRots={
	griesMills:function(a,s,m,e){
		Rots.griesMills(a,s,m-s,e-m);
	},
	threeReversal:function(a,s,m,e){
		Rots.threeReversal(a,s,m-s,e-m);
	},
	juggling:function(a,s,m,e){
		Rots.juggling(a,s,m-s,e-m);
	},
	holyGriesMills:function(a,s,m,e){
		Rots.holyGriesMills(a,s,m-s,e-m);
	},
	helium:function(a,s,m,e){
		Rots.helium(a,s,m-s,e-m);
	},
	cycleReverse:function(a,s,m,e){
		Rots.cycleReverse(a,s,m-s,e-m);
	},
	bridge:function(a,s,m,e){
		Rots.bridge(a,s,m-s,e-m);
	},
	neon:function(a,s,m,e){
		Rots.neon(a,s,m-s,e-m);
	},
	foolish:function(a,s,m,e){
		Rots.foolish(a,s,m-s,e-m);
	},
	morefoolish:function(a,s,m,e){
		Rots.morefoolish(a,s,m-s,e-m);
	},
	radon:function(a,s,m,e){
		Rots.radon(a,s,m-s,e-m);
	},
	centered:function(a,s,m,e){
		Rots.centered(a,s,m-s,e-m);
	},
	adaptable:function(a,s,m,e){
		Rots.adaptable(a,s,m-s,e-m);
	}
}
function getDigit(a,p,r){
	return(a/pow(r,p))%r|0;
}
function minVal(...a){
	return math.min(...a)
}
function maxVal(...a){
	return math.max(...a)
}
function maxLog(a,l,b){
	let m=i=0;
	for(;i<l;i++){
		let v=a[i];
		if(v>m)m=v;
	}
	return log(m)/log(b)|0;
}
function compareValues(a,b){
	a|=0;b|=0
	return a==b?0:a>b?1:-1
}
function compareIndices(a,b,c){
	b|=0;c|=0
	return a[b]==a[c]?0:a[b]>a[c]?1:-1
}
function swap(a,f,t,m=0){
	f|=0;t|=0;
	if(m&&markarray.checked){
		mark(f);
		mark(t);
	}
	let o=a[f];
	a[f]=a[t];
	a[t]=o;
	swaps++
	writes+=2
}
function customFunc(f,args){
	logs.push(["custom",btoa("("+f+")"),...args].join(","))
}
function rmultiSwap(a,p,t){
	multiSwap(a,p,t,1)
}
function rswap(arr,f,t){
	logs.push(["swap",f,t].join(","))
	swap(arr,f,t)
	swaps--
	writes-=2
}
function rset(arr,i,val){
	logs.push(["set",i,val].join(","))
	arr[i]=val
}
function insertTo(a,p,t,m=1){
	let tp=a[p];
	switch(m){
		case 0:
			if(t-p>0)
				for(let i=p;i<t;i++)write(a,i,a[i+1]);
			else if(t-p<0)
				for(let i=p;i>t;i--)write(a,i,a[i-1]);
			if(p!=t)rset(a,t,tp);
			break;
		case 1:
			if(t-p>0)
				for(let i=p;i<t;i++)rset(a,i,a[i+1]);
			else if(t-p<0)
				for(let i=p;i>t;i--)rset(a,i,a[i-1]);
			if(p!=t)rset(a,t,tp);
			break;
		case 2:
			logs.push(["insert",p,t].join(","))
			insertTo(a,p,t,0)
			break;
	}
}
function multiSwap(a,p,t,r){
	if(r)
		logs.push(["multiSwap",p,t].join(","))
	if(t-p>0)
		for(let i=p;i<t;i++)
			swap(a,i,i+1);
	else
		for(let i=p;i>t;i--)
			swap(a,i,i-1);
}
function reversal(a,s,l,m=1){
	if(l-s<=0)return;
	switch(m){
		case 0:
			for(let i=s;i<s+((l-s+1)/2);i++)
				swap(a,i,s+l-i);
			break;
		case 1:
			for(let i=s;i<s+((l-s+1)/2);i++)
				rswap(a,i,s+l-i);
			break;
		case 2:
			logs.push(["reversal",s,l].join(","))
			reversal(a,s,l,0)
			break;
	}
}
function customBinaryInsert(a,s,e,r=1){
	for(let i=s;i<e;i++){
		let num=a[i];
		let lo=s,hi=i;
		while(lo<hi){
			let mid=lo+((hi-lo)/2)|0;
			if(compareValues(num,a[mid])<0)hi=mid;
			else lo=mid+1;
		}
		let j=i-1;
		let change=false;
		let func=r?rset:write
		while(j>=lo){
			func(a,j+1,a[j]);
			j--;
			change=true;
		}
		if(change)func(a,lo,num);
	}
}
function write(a,t,v){
	a[t]=v|0;
	writes++
}
function clearArr(a){
	a.splice(0,1.7e308)
}
function arraycopy(s,sp,d,dp,l,r){
	let b=s!=d||dp<sp;
	let st=b?0:l-1,
		e=b?l:-1,
		dr=b?1:-1;
	for(let i=st;i!=e;i+=dr)
		if(r)rset(d,dp+i,s[sp+i]);
		else write(d,dp+i,s[sp+i]);
}
function getMax(a,l){
	let m=0;
	for(let i=0;i<l;i++)
		if(a[i]>m)m=a[i];
	return m;
}
function getMaxIndex(a,l){
	let i=0;
	for(let n=0;n<l;++n)
		if(a[n]>a[i])i=n;
	return i;
}
function getMin(a,l){
	let m=Infinity;
	for(let i=0;i<l;i++)
		if(a[i]<m)m=a[i];
	return m;
}
const circleDepth=parseFloat("1e-"+(len*.9|0).toString().length)
/*templates*/
function icsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)
		for(let s=0;s+g<len;s+=2*g)
			for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)
				if(h<len&&compareIndices(a,lw,h)>0)
					rswap(a,lw,h,sc++);
	return sc;
}
function rcsr(a,l,h,s){
	if(l==h)return s;
	let hi=h,lo=l,m=(h-l)/2|0;
	for(;l<h;l++,h--)
		if(h<len&&compareIndices(a,l,h)>0)
			rswap(a,l,h,s++);
	s=rcsr(a,lo,lo+m,s);
	if(lo+m+1<len)s=rcsr(a,lo+m+1,hi,s);
	return s;
}
function iclsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)
		for(let s=0;s+g<len;s+=2*g)
			for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)
				if(h<len&&compareIndices(a,lw,h)>0)
					reversal(a,lw,h,1,sc++);
	return sc;
}
function rclsr(a,lo,hi,s){
	if(lo==hi)return s;
	let h=hi,l=lo,m=(hi-lo)/2|0;
	for(;lo<hi;lo++,hi--)
		if(hi<len&&compareIndices(a,lo,hi)>0)
			reversal(a,lo,hi,1,s++);
	s=rclsr(a,l,l+m,s);
	if(l+m+1<len)
		s=rclsr(a,l+m+1,h,s);
	return s;
}
function ishsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)
		for(let s=0;s+g<len;s+=2*g)
			for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)
				if(h<len&&compareIndices(a,lw,h)>0)
					insertTo(a,lw,h,2,sc++);
	return sc;
}
function rshsr(a,lo,hi,s){
	if(lo==hi)return s;
	let h=hi,l=lo,m=(hi-lo)/2|0;
	for(;lo<hi;lo++,hi--)
		if(hi<len&&compareIndices(a,lo,hi)>0)
			insertTo(a,lo,hi,2,s++);
	s=rshsr(a,l,l+m,s);
	if(l+m+1<len)
		s=rshsr(a,l+m+1,h,s);
	return s;
}
function insertSort(a,s,e){
	for(let i=s;i<e;i++){
		let p=i-1,c=a[i];
		while(p>=s&&compareValues(a[p],c)>0)
			rset(a,p+1,a[p--]);
		rset(a,p+1,c);
	}
}
function siftDown(a,r,d,s,m,t){
	let cv=m?-1:1;
	while(r<=d/2){
		let l=2*r;
		if(l<d&&compareIndices(a,s+l-1,s+l)==cv)l++;
		if(compareIndices(a,s+r-1,s+l-1)==cv){
			t?swap(a,s+r-1,s+l-1):rswap(a,s+r-1,s+l-1);
			r=l;
		}else break;
	}
}
function heapify(ar,lw,h,m,t=0){
	let le=h-lw;
	for(let i=le/2;i>=1;i--)
		siftDown(ar,i,le,lw,m,t)
}
/*end*/
function iterativeBitonicSort(){
	let array=[...arr];
	let i,j,k;
	for(k=2;k<len*2;k=2*k){
		let m=(((len+(k-1))/k)%2)!=0;
		for(j=k>>1;j>0;j=j>>1)
			for(i=0;i<len;i++){
				let ij=i^j;
				if(ij>i&&ij<len){
					if((((i&k)==0)==m)&&compareIndices(array,i,ij)>0)rswap(array,i,ij);
					if((((i&k)!=0)==m)&&compareIndices(array,i,ij)<0)rswap(array,i,ij);
				}
			}
	}
	return[5,1];
}
function batcherBitonicSort(){
	let array=[...arr];
	const bm=(a,l,n,dir)=>{
		if(n<=1)return;
		let m=1
		while(m<<1<n)m<<=1;
		for(let i=l;i<l+n-m;i++)
			if(dir==(compareIndices(array,i,i+m)==1))
				rswap(a,i,i+m);
		bm(a,l,m,dir);
		bm(a,l+m,n-m,dir);
	}
	const bs=(a,l,n,dir)=>{
		if(n<=1)return;
		let m=n/2;
		bs(a,l,m,!dir);
		bs(a,l+m,n-m,dir);
		bm(a,l,n,dir);
	}
	bs(array,0,len,1)
	return[5,1];
}
function iterativeBoseNelsonSort(){
	let array=[...arr];
	let clen=1<<ceil(log(len)/log(2));
	for(let a=2;a<=clen;a*=2){
		for(let b=0;b<a/2;b++){
			for(let c=0;c+b<len;c+=a){
				let g=c
				let half=(c+a-g)/2,m=g+half;
				g+=b;
				for(let d=0;d<half-b;d++){
					if((d&~b)==d){
						let e=g+d,f=m+d
						if(f<len&&compareIndices(array,e,f)==1)
							rswap(array,e,f);
					}
				}
			}
		}
	}
	return[5,1]
}
function recursiveBoseNelsonSort(){
	let array=[...arr];
	const cs=(a,s,e)=>{
		if(compareIndices(a,s,e)==1)
			rswap(a,s,e);
	}
	const bn=(a,s,l)=>{
		if(l<=1)return;
		let m=l/2|0;
		bn(a,s,m);
		bn(a,s+m,l-m);
		bnm(a,s,m,s+m,l-m);
	}
	
	const bnm=(a,s1,l1,s2,l2)=>{
		if(l1==1&&l2==1){
			cs(a,s1,s2);
		}else if(l1==1&&l2==2){
			cs(a,s1,s2+1);
			cs(a,s1,s2);
		}else if(l1==2&&l2==1){
			cs(a,s1,s2);
			cs(a,s1+1,s2);
		}else{
			let m1=l1/2|0;
			let m2=(l1%2==1?l2/2:(l2+1)/2)|0;
			bnm(a,s1,m1,s2,m2);
			bnm(a,s1+m1,l1-m1,s2+m2,l2-m2);
			bnm(a,s1+m1,l1-m1,s2,m2);
		}
	}
	bn(array,0,len);
	return[5,1]
}
function creaseSort(){
	let array=[...arr];
	let max=1;
	for(;max*2<len;max*=2);
	let next=max;
	while(next>0){
		for(let i=0;i+1<len;i+=2)
			if(compareIndices(array,i,i+1)==1)
				rswap(array,i,i+1);
		for(let j=max;j>=next&&j>1;j/=2)
			for(let i=1;i+j-1<len;i+=2)
				if(compareIndices(array,i,i+j-1)==1)
					rswap(array,i,i+j-1);
		next/=2;
	}
	return[5,1]
}
function iterativeDiamondSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	let m=4;
	for(;m<=n;m*=2){
		for(let k=0;k<m/2;k++){
			let cnt=k<=m/4?k:m/2-k;
			for(let j=0;j<len;j+=m)
				if(j+cnt+1<len)
					for(let i=j+cnt;i+1<minVal(len,j+m-cnt);i+=2)
						if(compareIndices(array,i,i+1)==1)
							rswap(array,i,i+1);
		}
	}
	m/=2;
	for(let k=0;k<=m/2;k++)
		for(let i=k;i+1<minVal(len,m-k);i+=2)
			if(compareIndices(array,i,i+1)==1)
				rswap(array,i,i+1);
	return[0,0]
}
function recursiveDiamondSort(){
	let array=[...arr];
	const sort=(array,start,stop,merge)=>{
		if(stop-start==2){
			if(compareIndices(array,start,stop-1)==1)
				rswap(array,start,stop-1);
		}else if(stop-start>=3){
			let div=(stop-start)/4;
			let mid=(stop-start)/2+start;
			if(merge){
				sort(array,start,mid,1);
				sort(array,mid,stop,1);
			}
			sort(array,div+start|0,div*3+start|0,0);
			sort(array,start,mid,0);
			sort(array,mid,stop,0);
			sort(array,div+start|0,div*3+start|0,0);
		}
	}
	sort(array,0,len,true);
	return[5,1]
}
function foldSort(){
	let array=[...arr];
	let ceilLog=1;
	for(;1<<ceilLog<len;ceilLog++);
	let size=1<<ceilLog;
	for(let k=size>>1;k>0;k>>=1){
		for(let i=size;i>=k;i>>=1){
			for(let j=0;j<len;j+=i){
				let low=j-1,high=j+i
				while(++low<--high)
					if(high<len&&compareIndices(array,low,high)==1)
						rswap(array,low,high);
			}
		}
	}
	return[5,1]
}
function batcherMergeExchangeSort(){
	let array=[...arr];
	let t=log(len-1)/log(2)+1|0;
	let p0=1<<(t-1);
	for(let p=p0;p>0;p>>=1){
		let q=p0;
		let r=0;
		let d=p;
		while(1){
			for(let i=0;i<len-d;i++)
				if((i&p)==r&&compareIndices(array,i,i+d)==1)
					rswap(array,i,i+d);
			if(q==p)break;
			d=q-p;
			q>>=1;
			r=p;
		}
	}
	return[5,1]
}
function recursiveOddEvenMergeSort(){
	let array=[...arr];
	const oemc=(a,i,j)=>{
		if(compareIndices(a,i,j)>0)
			rswap(a,i,j);
	}
	const oem=(a,lo,m2,n,r)=>{
		let m=r*2;
		if(m<n){
			if((n/r|0)%2!=0){
				oem(a,lo,(m2+1)/2,n+r,m);
				oem(a,lo+r,m2/2,n-r,m);
			}else{
				oem(a,lo,(m2+1)/2,n,m);
				oem(a,lo+r,m2/2,n,m);
			}
			if(m2%2|0!=0){
				for(let i=lo;i+r<lo+n;i+=m)
					oemc(a,i,i+r);
			}else
				for(let i=lo+r;i+r<lo+n;i+=m)
					oemc(a,i,i+r);
		}else
			if(n>r)
				oemc(a,lo,lo+r);
	}
	const oems=(a,lo,n)=>{
		if(n>1){
			let m=n/2;
			oems(a,lo,m);
			oems(a,lo+m,n-m);
			oem(a,lo,m,n,1);
		}
	}
	oems(array,0,len);
	return[5,1]
}
function iterativePairwiseMergeSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n<<=1);
	for(let k=n>>1;k>0;k>>=1)
		for(let j=0;j<len;j+=k<<1)
			for(let i=0;i<k;i++)
				if(j+k+i<len&&compareIndices(array,j+i,j+k+i)==1)
					rswap(array,j+i,j+k+i);
	for(let k=2;k<n;k<<=1)
		for(let m=k>>1;m>0;m>>=1)
			for(let j=0;j<len;j+=k<<1)
				for(let p=m;p<((k-m)<<1);p+=m<<1)
					for(let i=0;i<m;i++)
						if(j+p+m+i<len&&compareIndices(array,j+p+i,j+p+m+i)==1)
							rswap(array,j+p+i,j+p+m+i);
	return[5,1]
}
function recursivePairwiseMergeSort(){
	let array=[...arr];
	const pm=(array,a,b)=>{
		let m=(a+b)/2,m1=(a+m)/2,g=m-m1;
		for(let i=0;m1+i<m;i++)
			for(let j=m1,k=g;k>0;k>>=1,j-=k-(i&k))
				if(j+i+k<len&&compareIndices(array,j+i,j+i+k)==1)
					rswap(array,j+i+k,j+i);
		if(b-a>4)pm(array,m,b);
	}
	const pms=(array,a,b)=>{
		let m=(a+b)/2;
		for(let i=a,j=m;i<m;i++,j++)
			if(j<len&&compareIndices(array,i,j)==1)
				rswap(array,i,j);
		if(b-a>2){
			pms(array,a,m);
			pms(array,m,b);
			pm(array,a,b);
		}
	}
	let n=1;
	for(;n<len;n<<=1);
	pms(array,0,n);
	return[5,1]
}
function iterativeWeaveSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	for(let i=1;i<n;i*=2)
		for(let j=1;j<=i;j*=2)
			for(let k=0;k<n;k+=n/j)
				for(let d=n/i/2,m=0,l=n/j-d;l>=n/j/2;l-=d)
					for(let p=0;p<d;p++,m++)
						if(k+l+p<len&&compareIndices(array,k+m,k+l+p)==1)
							rswap(array,k+m,k+l+p);
	return[5,1]
}
function recursiveWeaveSort(){
	let array=[...arr];
	const cr=(array,pos,length,gap)=>{
		if(length<2)return;
		for(let i=0;2*i<(length-1)*gap;i+=gap)
			if(pos+(length-1)*gap-i<len&&compareIndices(array,pos+i,pos+(length-1)*gap-i)==1)
				rswap(array,pos+i,pos+(length-1)*gap-i);
		cr(array,pos,length/2,gap);
		if(pos+length*gap/2<len)cr(array,pos+length*gap/2,length/2,gap);
	}
	const wc=(array,pos,length,gap)=>{
		if(length<2)return;
		wc(array,pos,length/2,2*gap);
		wc(array,pos+gap,length/2,2*gap);
		cr(array,pos,length,gap);
	}
	let n=1;
	for(;n<len;n*=2);
	wc(array,0,n,1);
	return[5,1]
}
function LSDRadixSort(){
	let array=[...arr];
	let base=10
	let c=2,
		min=getMin(array,len),
		max=getMax(array,len),
		exp=1;
	while((max-min)/exp>=1){
		let n,b=new Array(base).fill(0),output=new Array(len);
		for(n=0;n<len;n++)b[((array[n]-min)/exp)%base|0]++;
		for(n=1;n<base;n++)b[n]+=b[n-1];
		for(n=len-1;n>=0;n--)output[--b[((array[n]-min)/exp)%base|0]]=array[n];
		for(n=0;n<len;n++)rset(array,n,output[n]);
		exp*=10;
	}
	return[0,1]
}
function indexSort(){
	let array=[...arr];
	let min=getMin(array,len)
	for(let i=0;i<len;i++){
		let cmpCount=0;
		while(compareValues(i,array[i]-min)!=0&&cmpCount<len)
			rswap(array,i,array[i]-min,cmpCount++);
		if(cmpCount>=len-1)break;
	}
	return[5,1]
}
function bubbleSort(){
	let array=[...arr];
	for(let i=len-1;i>0;i--){
		let s=1;
		for(let j=0;j<i;j++){
			if(compareIndices(array,j,j+1)==1){
				rswap(array,j,j+1);
				s=0;
			}
		}
		if(s)break;
	}
	return[-.2,1]
}
function circloidSort(){
	let array=[...arr];
	const c=(a,l,r)=>{
		let s=0;
		while(l<r){
			if(compareIndices(a,l,r)==1){
				rswap(a,l,r);
				s=1;
			}
			l++;
			r--;
			if(l==r)r++;
		}
		return s;
	}
	const cp=(a,l,r)=>{
		if(l>=r)return false;
		let mid=(l+r)/2|0;
		let lf=cp(a,l,mid);
		let rt=cp(a,mid+1,r);
		return c(a,l,r)||lf||rt;
	}
	while(cp(array,0,len-1));
	return[5,1]
}
function combSort(){
	let array=[...arr];
	for(let i=0;!isSorted(array);i++,i%=len){
		let n=len;
		let d=1;
		while(n!=1||d){
			n=(n*10)/13|0
			if(n<1)n=1;
			d=0;
			if(i>n-len&&compareIndices(array,i,i+n)==1){
				rswap(array,i,i+n)
				d=1
			}
		}
		
	}
	return[5,1]
}
function completeGraphSort(){
	let array=[...arr];
	const cs=(array,a,b)=>{
		if(compareIndices(array,a,b)>0)
			rswap(array,a,b);
	}
	const split=(array,a,m,b)=>{
		if(b-a<2)return;
		let c=0,len1=(b-a)/2;
		let odd=(b-a)%2==1;
		if(odd){
			if(m-a>b-m)c=a++;
			else c=--b;
		}
		for(let s=0;s<len1;s++){
			let i=a;
			for(let j=s;j<len1;j++)
				cs(array,i++,m+j);
			for(let j=0;j<s;j++)
				cs(array,i++,m+j);
		}
		if(odd){
			if(c<m)
				for(let j=0;j<len1;j++)
					cs(array,c,m+j);
			else
				for(let j=0; j<len1;j++)
					cs(array,a+j,c);
		}
	}
	let n=len;
	let d=2,end=1<<(log(n-1)/log(2)|0+1);
	while(d<=end){
		let i=0,dec=0;
		while(i<n){
			let j=i;
			dec+=n;
			while(dec>=d){
				dec-=d;
				j++;
			}
			let k=j;
			dec+=n;
			while(dec>=d){
				dec-=d;
				k++;
			}
			split(array,i,j,k);
			i=k;
		}
		d*=2;
	}
	return[5,1]
}
function funSort(){
	let array=[...arr];
	function bs(array,start,end,value){
		while(start<end){
			let mid=(start+end)>>>1;
			if(compareValues(array[mid],value)<0)start=mid+1;
			else end=mid;
		}
		return start;
	}
	for(let i=1;i<len;i++){
		let done=false;
		do{
			done=true;
			let pos=bs(array,0,len-1,array[i]);
			if(compareIndices(array,pos,i)!=0){
				if(i<pos-1)
					rswap(array,i,pos-1);
				else if(i>pos)
					rswap(array,i,pos);
				done=false;
			}
		}while(!done);
	}
	return[-.05,1]
}
function cocktailShakerSort(){
	let array=[...arr];
	let i=0;
	while(i<len/2){
		let s=true;
		for(let j=i;j<len-i-1;j++){
			if(compareIndices(array,j,j+1)==1){
				rswap(array,j,j+1);
				s=false;
			}
		}
		for(let j=len-i-1;j>i;j--){
			if(compareIndices(array,j,j-1)==-1){
				rswap(array,j,j-1);
				s=false;
			}	
		}
		if(s)break;
		else i++;
	}
	return[-.05,1]
}
function gnomeSort(){
	let array=[...arr];
	for(let i=1;i<len;){
		if(compareIndices(array,i,i-1)>=0)i++;
		else{
			rswap(array,i,i-1);
			if(i>1)i--;
		}
	}
	return[5,1]
}
function LLQuickSort(){
	let array=[...arr];
	function partition(array,lo,hi){
		let pivot=array[hi];
		let i=lo;
		for(let j=lo;j<hi;j++)
			if(compareValues(array[j],pivot)<0)
				rswap(array,i++,j);
		rswap(array,i,hi);
		return i;
	}	
	function quickSort(array,lo,hi){
		if(lo<hi){
			let p=partition(array,lo,hi);
			quickSort(array,lo,p-1);
			quickSort(array,p+1,hi);
		}
	}
	quickSort(array,0,len-1)
	return[5,1]
}
function LRQuickSort(){
	let array=[...arr];
	function quickSort(a,p,r){
		let pivot=p+(r-p+1)/2|0;
		let x=a[pivot];
		let i=p;
		let j=r;
		while(i<=j){
			while(compareValues(a[i],x)==-1)i++;
			while(compareValues(a[j],x)==1)j--;
			if(i<=j)rswap(a,i++,j--);
		}
		if(p<j)quickSort(a,p,j);
		if(i<r)quickSort(a,i,r);
	}
	quickSort(array,0,len-1);
	return[5,1]
}
function oddEvenSort(){
	let array=[...arr];
	while(!isSorted(array)){
		for(let n=0;n<=len-2;n+=2)
			if(compareIndices(array,n,n+1)==1)
				rswap(array,n,n+1);
		for(let n=1;n<=len-2;n+=2)
			if(compareIndices(array,n,n+1)==1)
				rswap(array,n,n+1);
	}
	return[-.05,1]
}
function stoogeSort(){
	let array=[...arr];
	const ss=(a,i,j)=>{
		if(compareIndices(a,i,j)==1)
			rswap(a,i,j);
		if(j-i+1>=3){
			let t=(j-i+1)/3|0;
			ss(a,i,j-t);
			ss(a,i+t,j);
			ss(a,i,j-t);
		}
	}
	ss(array,0,len-1)
	return[4,1]
}
function slopeSort(){
	let array=[...arr];
	for(let i=1,j=1;i<len;i=j,j++)
		for(let k=i-1;k>=0;k--,i--)
			if(compareIndices(array,i,k)<0)
				rswap(array,i,k);
	return[5,1]
}
function shellSort(){
	let array=[...arr];
	for(let i=0;!isSorted(array);i++,i%=len){
		for(let n=len/2|0;n>0;n=n/2|0){
			let j,o=array[i];
			for(j=i;j>=n&&compareValues(array[j-n],o)==1;j-=n)
				rswap(array,j,j-n,1);
			rset(array,j,o);
		}
	}
	return[-.1,1]
}
function recursiveShellSort(){
	let array=[...arr];
	function gis(a,b,c,g){
		for(let i=b+g;i<c;i+=g){
			let k=a[i]
			let j=i-g;
			while(j>=b&&compareValues(k,a[j])<0){
				rset(a,j+g,a[j]);
				j-=g;
			}
			rset(a,j+g,k);
		}
	}
	function rss(a,s,e,g){
		if(s+g<=e){
			rss(a,s,e,3*g);
			rss(a,s+g,e,3*g);
			rss(a,s+2*g,e,3*g);
			gis(a,s,e,g);
		}
	}
	rss(array,0,len,1);
	return[5,1]
}
function andreySort(){
	let array=[...arr];
	function sort(a,b,c){
		while(c>1){
			let k=0;
			for(let i=1;i<c;i++)
				if(compareIndices(a,b+k,b+i)>0)
					k=i;
			rswap(a,b,b+k);
			b++;c--;
		}
	}
	function aswap(a,a1,a2,l){
		while(l-->0)rswap(a,a1++,a2++);
	}
	function backmerge(a,a1,l1,a2,l2){
		let a0=a2+l1;
		for(;;){
			if(compareIndices(a,a1,a2)>0){
				rswap(a,a1--,a0--);
				if(--l1==0)return 0;
			}else{
				rswap(a,a2--,a0--);
				if(--l2==0)break;
			}
		}
		let res=l1;
		do rswap(a,a1--,a0--);while(--l1!=0);
		return res;
	}
	function rmerge(array,a,l,r){
		for(let i=0;i<l;i+=r){
			let q=i;
			for(let j=i+r;j<l;j+=r)
				if(compareIndices(array,a+q,a+j)>0)
					q=j;
			if(q!=i)
				aswap(array,a+i,a+q,r);
			if(i!=0){
				aswap(array,a+l,a+i,r);
				backmerge(array,a+(l+r-1),r,a+(i-1),r);
			}
		}
	}
	function rbnd(l){
		l/=2;
		let k=0;
		for(let i=1;i<l|0;i*=2)
			k++;
		l/=k;
		for(k=1;k<=l|0;k*=2);
		return k;
	}
	function msort(array,a,l){
		if(l<12){
			sort(array,a,l);
			return;
		}
		let r=rbnd(l);
		let lr=(l/r-1)*r;
		for(let p=2;p<=lr;p+=2){
			if(compareIndices(array,a+(p-2),a+(p-1))>0)
				rswap(array,a+(p-2),a+(p-1));
			if((p&2)!=0)continue;
			aswap(array,a+(p-2),a+p,2);
			let m=l-p;
			let q=2;
			for(;;){
				let q0=q*2;
				if(q0>m||(p&q0)!=0)break;
				backmerge(array,a+(p-q-1),q,a+(p+q-1),q);
				q=q0;
			}
			backmerge(array,a+(p+q-1),q,a+(p-q-1),q);
			let q1=q;
			q*=2;
			while((q&p)==0){
				q*=2;
				rmerge(array,a+(p-q),q,q1);
			}
		}
		let q1=0;
		for(let q=r;q<lr;q*=2){
			if((lr&q)!=0){
				q1+=q;
				if(q1!=q)
					rmerge(array,a+(lr-q1),q1,r);
			}
		}
		let s=l-lr;
		msort(array,a+lr,s);
		aswap(array,a,a+lr,s);
		s+=backmerge(array,a+s-1,s,a+lr-1,lr-s)
		msort(array,a,s);
	}
	msort(array,0,len);
	let n=1;
	for(;n*2<=len;n*=2);
	insertSort(array,0,n*.23|0);
	return[5,1]
}
function blockSwapMergeSort(){
	let array=[...arr];
	const bin=(ar,s,md,e)=>{
		let a=0,
			b=minVal(md-s,e-md),
			m=a+(b-a)/2|0;
		while(b>a){
			if(compareIndices(ar,md-m-1,md+m)==1)a=m+1;
			else b=m;
			m=a+(b-a)/2|0;
		}
		return m;
	}
	const msm=(a,s,md,e)=>{
		let m=bin(a,s,md,e);
		while(m>0){
			for(let i=0;i<m;i++)
				rswap(a,md-m+i,md+i);
			msm(a,md,md+m,e);
			e=md;
			md-=m;
			m=bin(a,s,md,e);
		}
	}
	const msms=(a,b,c)=>{
		let len=c-b,i;
		for(let j=1;j<len;j*=2){
			for(i=b;i+2*j<=c;i+=j*2)
				msm(a,i,i+j,i+j*2);
			if(i+j<c)
				msm(a,i,i+j,c);
		}
	}
	msms(array,0,len);
	return[5,1]
}
function inPlaceMergeSort(){
	let array=[...arr];
	const push=(array,p,a,b)=>{
		if(a==b)return;
		let tmp=array[p];
		rset(array,p,array[a]);
		for(let i=a+1;i<b;i++)
			rset(array,i-1,array[i]);
		rset(array,b-1,tmp);
	}
	const M=(a,b,m,c)=>{
		let i=b,j=m;
		while(i<m&&j<c)
			if(compareIndices(a,i,j)==1)j++;
			else push(a,i++,m,j);
		while(i<m)push(a,i++,m,c);
	}
	const ms=(a,b,c)=>{
		let m=b+(c-b)/2|0;
		if(c-b>2){
			if(c-b>3)
				ms(a,b,m);
			ms(a,m,c);
		}
		M(a,b,m,c);
	}
	ms(array,0,len);
	return[-.05,1]
}
function rotateMergeSort(){
	let array=[...arr];
	function rotate(array,a,m,b){
		IndexRots.griesMills(array,a,m,b,1);
	}
	function bs(array,a,b,value,left){
		while(a<b){
			let m=a+(b-a)/2|0;
			let comp=left?compareValues(value,array[m])<=0:compareValues(value,array[m])<0;
			if(comp)b=m;
			else a=m+1;
		}
		return a;
	}
	function rotateMerge(array,a,m,b){
		let m1,m2,m3;
		if(m-a>=b-m){
			m1=a+(m-a)/2|0;
			m2=bs(array,m,b,array[m1],true);
			m3=m1+(m2-m);
		}else{
			m2=m+(b-m)/2|0;
			m1=bs(array,a,m,array[m2],false);
			m3=(m2++)-(m-m1);
		}
		rotate(array,m1,m,m2);
		if(m2-m3+1>0&&b-m2>0)rotateMerge(array,m3+1,m2,b);
		if(m1-a>0&&m3-m1>0)rotateMerge(array,a,m1,m3);
	}
	function rotateMergeSort(array,a,b){
		let len=b-a,i;
		for(let j=1;j<len;j*=2){
			for(i=a;i+2*j<=b;i+=2*j)
				rotateMerge(array,i,i+j,i+2*j);
			if(i+j<b)
				rotateMerge(array,i,i+j,b);
		}
	}
	rotateMergeSort(array,0,len);
	return[5,1]
}
function strandSort(){
	let array=[...arr];
	function mergeTo(array,subList,a,m,b){
		let i=0,s=m-a;
		while(i<s&&m<b)
			if(compareValues(subList[i],array[m])<0)rset(array,a++,subList[i++]);
			else rset(array,a++,array[m++]);
		while(i<s)rset(array,a++,subList[i++]);
	}
	let subList=new Array(len);
	let j=len,k=j;
	while(j>0){
		write(subList,0,array[0]);
		for(let i=0,p=0,m=1;m<j;m++){
			if(compareValues(array[m],subList[i])>=0){
				write(subList,++i,array[m]);
				k--;
			}else rset(array,p++,array[m]);
		}
		mergeTo(array,subList,--k,j,len);
		j=k;
	}
	return[-.01,1]
}
function weavedMergeSort(){
	let array=[...arr];
	function merge(array,tmp,length,residue,modulus){
		if(residue+modulus>=length)return;
		let low=residue;
		let high=residue+modulus;
		let dmodulus=modulus<<1;
		merge(array,tmp,length,low,dmodulus);
		merge(array,tmp,length,high,dmodulus);
		let nxt=residue;
		for(;low<length&&high<length;nxt+=modulus){
			let cmp=compareIndices(array,low,high);
			if(cmp==1||cmp==0&&low>high){
				write(tmp,nxt,array[high]);
				high+=dmodulus;
			}else{
				write(tmp,nxt,array[low]);
				low+=dmodulus;
			}
		}
		if(low>=length){
			while(high<length){
				write(tmp,nxt,array[high]);
				nxt+=modulus;
				high+=dmodulus;
			}
		}else{
			while(low<length){
				write(tmp,nxt,array[low]);
				nxt+=modulus;
				low+=dmodulus;
			}
		}
		for(let i=residue;i<length;i+=modulus)
			rset(array,i,tmp[i]);
	}
	let tmp=new Array(len);
	merge(array,tmp,len,0,1);
	return[-.01,1]
}
function pancakeSort(){
	let array=[...arr];
	let i=len
	while(i>=0&&!isSorted(array)){
		let c=getMaxIndex(array,i);
		if(c!=--i){
			reversal(array,0,c)
			reversal(array,0,i)
		}
	}
	return[5,1]
}
function maxHeapSort(){
	let array=[...arr];
	heapify(array,0,len,1)
	for(let i=len;i>1;i--){
		rswap(array,0,i-1);
		siftDown(array,1,i-1,0,1);
	}
	return[-.01,1]
}
function minHeapSort(){
	let array=[...arr];
	heapify(array,0,len,0)
	for(let i=len;i>1;i--){
		rswap(array,0,i-1);
		siftDown(array,1,i-1,0,0);
	}
	reversal(array,0,len-1)
	return[-.01,1]
}
function cycleSort(){
	let array=[...arr];
	let i=0
	while(i<len){
		let c=array[i]-1;
		if(compareIndices(array,i,c)!=0)
			rswap(array,i--,c)
		i++
	}
	return[5,1]
}
function inPlaceMSDRadixSort(){
	let array=[...arr];
	const radixMSD=(a,l,min,max,r,p)=>{
		if(min>=max||p<0)return;
		let b=new Array(r);
		for(let i=0;i<r;i++)b[i]=min;
		for(let i=min;i<max;i++){
			let t=a[i];
			let d=getDigit(t,p,r);
			for(let j=r-1;j>d;j--){
				if(b[j]!=b[j-1])
					rset(a,b[j],a[b[j-1]]);
				write(b,j,b[j]+1);
			}
			rset(a,b[d],t);
			write(b,d,b[d]+1);
		}
		for(let i=0;i<r;i++)radixMSD(a,l,i==0?min:b[i-1],b[i],r,p-1);
	}
	let base=4
	let hp=maxLog(array,len,base);
	radixMSD(array,len,0,len,base,hp);
	return[5,1]
}
function asteraceaeSort(){
	let array=[...arr];
	let i=1;
	let fs=2;
	let as=1;
	let ls=0;
	while(as){
		if(fs-1==0)i=1;
		else i=fs-1;
		as=0;ls=0;
		while(i<len){
			if(compareIndices(array,i-1,i)>0){
				rswap(array,i-1,i++);
				if(!as)fs=i-1;
				as=ls=1;
			}else{
				if(ls)i+=floor(sqrt(len));
				else i++;
				ls=0;
			}
		}
	}
	return[5,0]
}
function LMSDRadixSort(){
	let array=[...arr];
	function radixSort(a,s,e,p){
		let regs=new Array(base);
		for(let i=0;i<base;i++)regs[i]=[];
		for(let i=s;i<e;i++){
			let digit=getDigit(a[i],p,base);
			regs[digit]=regs[digit].concat([a[i]]);
		}
		let c=s;
		for(let i=0;i<base;i++)
			for(let j=0;j<regs[i].length;j++)
				rset(a,c++,regs[i][j])
		return regs;
	}
	function lmsdRadixSort(array,mina,maxa,place,maxPlace){
		if(maxPlace<place||maxa-mina<=1)return;
		let regs=radixSort(array,mina,maxa,place);
		if(place!=maxPlace){
			regs=radixSort(array,mina,maxa,maxPlace);
			let sum=0;
			for(let i=0;i<regs.length;i++){
				lmsdRadixSort(array,sum+mina,sum+mina+regs[i].length,place+1,maxPlace-1);
				sum+=regs[i].length;
			}
		}
	}
	let base=4;
	let hp=maxLog(array,len,base);
	lmsdRadixSort(array,0,len,0,hp);
	return[0,1]
}
function awkwardSort(){
	let array=[...arr];
	const awkward=(arr,l,p)=>{
		if(l==1)return;
		l|=0
		p|=0
		awkward(arr,l/2,p);
		awkward(arr,l/2+l%2,p+l/2);
		for(let i=0;i<l/2;i++){
			let a=p+i;
			let b=p+l/2+l%2+i;
			if(compareIndices(arr,a,b)==1)
				rswap(arr,a,b);
		}
		awkward(arr,l/2+l%2,p+l/4);
		awkward(arr,l/2,p);
		awkward(arr,l/2+l%2,p+l/2);
	}
	awkward(array,len,0);
	return[5,1]
}
function chinottoSort(){
	let array=[...arr];
	let d=0;
	let gap=1;
	while(!d){
		let i=0;
		d=1;
		for(;i+gap<len;i++){
			if(compareIndices(array,i,i+gap)==1){
				d=0;
				rmultiSwap(array,i,i+gap);
				gap++;
			}else if(gap>=2)
				gap--;
		}
		for(;i-gap>0;i--){
			if(compareIndices(array,i-gap,i)==1){
				d=0;
				rmultiSwap(array,i,i-gap);
				gap++;
			}else if(gap>=2)gap--;
		}
	}
	return[5,1]
}
function circleMergeSort(){
	let array=[...arr];
	const csr=(a,l)=>{
		let sc=0;
		for(let g=l/2;g>circleDepth;g/=2){
			for(let s=0;s+g<len;s+=2*g){
				let h=s+2*g-1|0;
				let lw=s|0;
				for(;lw<h;){
					if(h<len&&compareIndices(a,lw,h)>0)
						rswap(a,lw,h,sc++);
					lw++;
					h--;
				}
			}
		}
		return sc;
	}
	for(let n=1;n<=len;n*=2)
		while(csr(array,n));
	return[5,1]
}
function clamberSort(){
	let array=[...arr];
	for(let i=1;i<len;i++)
		for(let j=0;j<i;j++)
			if(compareIndices(array,i,j)<0)
				rswap(array,i,j);
	return[5,1]
}
function cocktailGrateSort(){
	let array=[...arr];
	let n=1;
	while(n){
		n=0;
		let i,j;
		for(i=0;i<len-1;i++){
			for(j=len-1;j>i;j--){
				if(compareIndices(array,i,j)>0){
					n=1;
					rswap(array,i,j);
					break;
				}
			}
		}
		if(!n)break;
		for(i=0;i<len-1;i++){
			for(j=i+1;j<len;j++){
				if(compareIndices(array,i,j)>0){
					rswap(array,i,j);
					break;
				}
			}
		}
	}
	return[5,1]
}
function cocktailPushSort(){
	let array=[...arr];
	let as=1;
	function cf(ar,a,b,s,g){
		for(let j=1;j<=g;j++)
			swap(ar,a,b+j*s);
	}
	while(as){
		as=0;
		let i=1,g=1;
		while(i+g<=len){
			if(compareIndices(array,i-1,i-1+g)>0){
				cf(array,i-1,i-1,1,g)
				customFunc(cf,[i-1,i-1,1,g])
				as=1
				g++;
			}else i++;
		}
		i=len;
		g=1;
		while(i-g>0){
			if(compareIndices(array,i-1-g,i-1)>0){
				cf(array,i-1,i-1,-1,g)
				customFunc(cf,[i-1,i-1,-1,g])
				as=1
				g++;
			}else i--;
		}
	}
	return[0,0]
}
function dandelionSort(){
	let array=[...arr];
	for(let b=0;b<len;){
		let pointer=b;
		let as=0;
		while(pointer<len-1&&compareIndices(array,pointer+1,pointer)<0){
			rswap(array,pointer,pointer+1);
			as=1;
			pointer++;
		}
		if(as){
			if(b>0)b--;
			continue;
		}
		b++;
	}
	return[5,0]
}
function floatSort(){
	let array=[...arr];
	let n=1;
	while(n){
		let h=0;
		n=0;
		for(let g=len-1;g>0;g--){
			let i=h;
			let j=h+1;
			while(i>=0&&compareIndices(array,i,j)>0){
				rswap(array,i--,j--);
				n=1;
			}
			if(i>=0){
				i++;
				j++;
				while(j<len&&compareIndices(array,i,j)>0){
					rswap(array,i++,j++);
					n=1;
				}
			}
			h++;
		}
	}
	return[5,1]
}
function iterativeQuickSort(){
	let array=[...arr];
	let s=0,e=len-1
	let st=new Array(len);
	let top=-1;
	write(st,++top,s);
	write(st,++top,e);
	while(top>=0){
		e=st[top--];
		s=st[top--];
		let pv=array[e];
		let i=s-1;
		for(let j=s;j<e;j++)
			if(compareValues(array[j],pv)<=0)
				rswap(array,++i,j);
		rswap(array,++i,e);
		let p=i
		if(compareValues(p-1,s)==1){
			write(st,++top,s);
			write(st,++top,p-1);
		}
		if(compareValues(e,p+1)==1){
			write(st,++top,p+1);
			write(st,++top,e);
		}
	}
	return[5,1]
}
function indexQuickSort(){
	let array=[...arr];
	const iqs=(array,idx,a,b)=>{
		while(a<b){
			if(compareValues(a,idx[a])!=0){
				let t=array[a];
				let i=a,nxt=idx[a];
				do{
					rset(array,i,array[nxt]);
					write(idx,i,i);
					i=nxt;
					nxt=idx[nxt];
				}while(compareValues(nxt,a)!=0);
				rset(array,i,t);
				write(idx,i,i);
			}
			a++;
		}
	}
	const sort=(array,idx,a,b)=>{
		if(b-a<2)return;
		let c0=a,c1=c0,i;
		let m=a+random()*(b-a)|0;
		for(i=a;i<m;i++)
			if(compareIndices(array,i,m)<=0)
				c1++;
		i++;
		c1++;
		for(;i<b;i++)
			if(compareIndices(array,i,m)<0)
				c1++;
		let p=c1-1;
		for(i=a;i<m;i++){
			if(compareIndices(array,i,m)<=0)
				write(idx,c0++,i);
			else write(idx,c1++,i);
		}
		write(idx,p,i++);
		for(;i<b;i++){
			if(compareIndices(array,i,m)<0)
				write(idx,c0++,i);
			else write(idx,c1++,i);
		}
		iqs(array,idx,a,b);
		sort(array,idx,a,p);
		sort(array,idx,p+1,b);
	}
	let idx=new Array(len);
	sort(array,idx,0,len);
	return[5,1]
}
function pseudoHeapSort(){
	let array=[...arr];
	function sift_down(array,start,length,root){
		let swapped=0;
		let j=root;
		while(2*j<length){
			let k=2*j;
			if(k<length&&compareIndices(array,start+k-1,start+k)==1)
				k++;
			if(compareIndices(array,start+j-1,start+k-1)==1){
				rswap(array,start+j-1,start+k-1);
				j=k;
				swapped=1;
				continue;
			}
			break;
		}
		return swapped;
	}
	let s=1
	while(s--)
		for(let i=len-2;i>=0;i--)sift_down(array,i,len-i+1,1)&&(s=1)
	return[1,1]
}
function iterativeCircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(icsr(array,n));
	return[5,1]
}
function recursiveCircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rcsr(array,0,n-1,0,len));
	return[5,1]
}
function LLQuickSortMiddlePivotSort(){
	let array=[...arr];
	function partition(array,a,b){
		let i=a,j=i,m=(a+b)/2|0;
		while(j<m){
			if(compareIndices(array,j,m)<=0)
				rswap(array,i++,j);
			j++;
		}
		rswap(array,i,m);
		j=m+1;
		m=i++;
		while(j<b){
			if(compareIndices(array,j,m)<0)
				rswap(array,i++,j);
			j++;
		}
		rswap(array,--i,m);
		return i;
	}
	function quickSort(array,a,b){
		if(b-a>1){
			let p=partition(array,a,b);
			quickSort(array,a,p);
			quickSort(array,p+1,b);
		}
	}
	quickSort(array,0,len);
	return[5,1]
}
function pushSort(){
	let array=[...arr];
	let as=1;
	let i=1;
	let gap=1;
	function cf(a,g,i){
		for(let j=1;j<=g;j++)
			swap(a,i-1,i-1+j);
	}
	while(as){
		as=0;
		i=1;
		gap=1;
		while(i+gap<=len){
			if(compareIndices(array,i-1,i-1+gap)>0){
				cf(array,gap,i);
				customFunc(cf,[gap,i]);
				as=1;
				gap++;
			}else i++;
		}
	}
	return[5,0]
}
function reflectionSort(){
	let array=[...arr];
	let as=1;
	let i=0;
	while(as){
		i=0;
		as=0;
		while(i<len){
			if(compareIndices(array,i,i+1)>0){
				rswap(array,i,i+1);
				i=(len-1)-i;
				as=1;
			}else i++;
		}
		i=len;
		as=0;
		while(i>1){
			if(compareIndices(array,i-1,i)>0){
				rswap(array,i-1,i);
				i=(len-1)-i;
				as=1;
			}else i--;
		}
	}
	return[5,1]
}
function splitCenterSort(){
	let array=[...arr];
	let way=1;
	let i=1;
	for(let r=1;r<len;r++){
		i=len/2|0;
		while(i<len&&i>0){
			if(compareIndices(array,i-1,i)>0)rswap(array,i-1,i);
			i+=way;
		}
		way*=-1;
	}
	return[5,1]
}
function wiggleSort(){
	let array=[...arr];
	const ws=(a,l,s,e)=>{
		if(e-s<2)return;
		let lp=s;
		let rp=e;
		let mp=(lp+rp)/2|0;
		let sl=1;
		let j=mp;
		for(let i=lp;i<mp;i++){
			for(let k=mp;k<e;k++){
				if(compareIndices(a,i,j)>=0)rswap(a,i,j);
				if(sl)j++;
				else j--;
			}
			if(sl)j--;
			else j++;
			sl=!sl
		}
		ws(a,l,s,mp);
		ws(a,l,mp,e);
	}
	ws(array,len,0,len);
	return[5,1]
}
function zipperSort(){
	let array=[...arr];
	let i=0;
	let gap=2;
	let f=0;
	while(gap>1){
		gap=1;
		i=f>1?f-1:0;
		while(i+gap<len){
			if(compareIndices(array,i,i+gap)>0){
				rswap(array,i,i+gap);
				if(gap==1)f=i;
				gap++;
			}else i++;
		}
	}
	return[5,1]
}
function pairwiseCircleSort(){
	let array=[...arr];
	const pairs=(ar,l,r,g)=>{
		if(l+g>=r)return;
		let a=l;
		while(a+g<=r){
			if(compareIndices(ar,a,a+g)==1)
				rswap(ar,a,a+g);
			a+=g*2;
		}
		pairs(ar,l,r,g*2);
		pairs(ar,l+g,r,g*2);
	}
	const circle=(ar,l,r)=>{
		let a=l;
		let b=r;
		while(l<r){
			if(compareIndices(ar,l,r)==1)
				rswap(ar,l,r);
			l++;
			r--;
		}
	}
	const pairCircle=(a,l,r)=>{
		if(l>=r)return;
		let m=(l+r)/2|0;
		pairs(a,l,r,1);
		circle(a,l,r);
		pairCircle(a,l,m);
		pairCircle(a,m+1,r);
	}
	pairCircle(array,0,len-1);
	insertSort(array,0,len);
	return[5,1]
}
function iterativeSinkingMergeSort(){
	let array=[...arr];
	const bs=(a,s,e)=>{
		let cs=1;
		for(let i=e-1;i>s;i-=cs){
			cs=1;
			for(let j=s;j<i;j++){
				if(compareIndices(a,j,j+1)>0){
					rswap(a,j,j+1);
					cs=1;
				}else cs++;
			}
		}
	}
	let mRun=len;
	for(;mRun>=32;mRun=(mRun+1)/2);
	let i;
	for(i=0;i+mRun<len;i+=mRun)
		bs(array,i,i+mRun);
	bs(array,i,len);
	for(let j=mRun;j<len;j*=2){
		for(i=0;i+2*j<=len;i+=2*j)
			bs(array,i,i+2*j);
		if(i+j<len)
			bs(array,i,len);
	}
	return[5,0]
}
function recursiveSinkingMergeSort(){
	let array=[...arr];
	const bs=(a,s,e)=>{
		let cs=1;
		for(let i=e-1;i>s;i-=cs){
			cs=1;
			for(let j=s;j<i;j++){
				if(compareIndices(a,j,j+1)>0){
					rswap(a,j,j+1);
					cs=1;
				}else cs++;
			}
		}
	}
	function sort(a,s,e){
		if(e-s>16){
			let m=s+(e-s)/2|0;
			sort(a,s,m);
			sort(a,m,e);
			bs(a,s,e);
		} else
			bs(a,s,e);
	}
	sort(array,0,len);
	return[5,0]
}
function cocktailShellSort(){
	let array=[...arr];
	let g=len/2;
	let dir=1;
	while(g>=1){
		if(dir){
			for(let i=g;i<len;i++){
				let tmp=array[i],j=i;
				while(j>=g&&compareValues(array[j-g],tmp)==1){
					rset(array,j,array[j-g]);
					j-=g;
				}
				rset(array,j,tmp);
			}
		}else{
			for(let i=len-g;i>=0;i--){
				let tmp=array[i],j=i;
				while(j<len-g&&compareValues(array[j+g],tmp)==-1){
					rset(array,j,array[j+g]);
					j+=g;
				}
				rset(array,j,tmp);
			}
		}
		g/=2;
		dir=!dir;
	}
	return[5,1]
}
function indexMergeSort(){
	let array=[...arr];
	function sort(ar,idx,a,b){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		sort(ar,idx,a,m);
		sort(ar,idx,m,b);
		let i=a,j=m,c=a;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<=0)write(idx,c++,i++);
			else write(idx,c++,j++);
		}
		while(i<m)write(idx,c++,i++);
		while(j<b)write(idx,c++,j++);
		while(a<b){
			if(compareValues(a,idx[a])!=0){
				let t=array[a];
				let i=a,nxt=idx[a];
				do{
					rset(array,i,array[nxt]);
					write(idx,i,i);
					i=nxt;
					nxt=idx[nxt];
				}while(compareValues(nxt,a)!=0);
				rset(array,i,t);
				write(idx,i,i);
			}
			a++;
		}
	}
	let idx=new Array(len);
	sort(array,idx,0,len);
	return[5,1]
}
function mobMergeSort(){
	let array=[...arr];
	const bubble=(array,start,end)=>{
		let c=1;
		let s;
		let f=start+((end-start)/2)|0;
		let a=false;
		for(let j=end-1;j>0;j-=c){
			if(f-1<start)s=start;
			else s=f-1;
			a=false;
			c=1;
			for(let i=s;i<j;i++){
				if(compareIndices(array,i,i+1)>0){
					rswap(array,i,i+1);
					if(!a)f=i;
					a=true;
					c=1;
				}else c++;
			}
		}
	}
	let l=2;
	let index=0;
	while(l<=len){
		index=0;
		while(index+l<=len){
			if(l==2){
				if(compareIndices(array,index,index+1)>0)rswap(array,index,index+1);
			}else bubble(array,index,index+l);
			index+=l;
		}
		if(index!=len)bubble(array,index,len);
		l*=2;
	}
	bubble(array,0,len);
	return[5,0]
}
function moduloMergeSort(){
	let array=[...arr];
	const mr=(a,s,m,e,mx)=>{
		let l=s;
		let r=m+1;
		let f=s;
		while(l<=m&&r<=e){
			if(compareValues(a[l]%mx,a[r]%mx)<=0)rset(a,f,a[f]+(a[l++]%mx)*mx);
			else rset(a,f,a[f]+(a[r++]%mx)*mx);
			f++;
		}
		while(l<=m)rset(a,f,a[f++]+(a[l++]%mx)*mx);
		while(r<=e)rset(a,f,a[f++]+(a[r++]%mx)*mx);
		for(let i=s;i<=e;i++)rset(a,i,a[i]/mx|0);
	}
	const ms=(a,s,e,mx)=>{
		if(s<e){
			let m=s+((e-s)/2)|0;
			ms(a,s,m,mx);
			ms(a,m+1,e,mx);
			mr(a,s,m,e,mx);
		}
	}
	ms(array,0,len-1,getMax(array,len)+1);
	return[5,1]
}
function split16MergeSort(){
	let array=[...arr];
	let moss=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16,1,5,9,13,2,6,10,14,3,7,11,15,4,8,12,16,1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16,6,11,7,10,4,13,14,15,8,12,2,3,5,9,2,5,8,14,3,9,12,15,6,7,10,11,3,5,12,14,4,9,8,13,7,9,11,13,4,6,8,10,4,5,6,7,8,9,10,11,12,13,7,8,9,10];
	const cs1=(a,b,c)=>{
		if(compareIndices(a,b,c)>0)
			rswap(a,b,c);
	}
	const cs2=(a,b,c,g,s)=>{
		if(compareIndices(a,s+b*g,s+c*g)>0)
			rswap(a,s+b*g,s+c*g);
	}
	const mos=(a,b,g)=>{
		for(let i=0;i<moss.length;i+=2)
			cs2(a,moss[i]-1,moss[i+1]-1,g,b);
	}
	const merge=(a,st,sz)=>{
		let gap=sz/16;
		for(let i=0;i<gap;i++)
			mos(a,st+i,gap);
		for(let s=gap/2;s>0;s/=2)
			for(let i=0;i<sz-s;i++)
				cs1(a,st+i,st+i+s);
	}
	for(let i=0;i<len-15;i+=16)
		mos(array,i,1);
	for(let gap=32;gap<=len;gap*=2)
		for(let i=0;i+gap<=len;i+=gap)
			merge(array,i,gap);
	return[5,1]
}
function cbrtQuickSort(){
	let array=[...arr];
	const sort=(a,start,stop)=>{
		let l=stop-start;
		if(l>=2){
			let root=cbrt(l)|0;
			let newStart=start+root;
			sort(a,start,newStart);
			let pivots=new Array(root);
			for(let i=0;i<root;i++)
				write(pivots,i,i+start);
			for(let i=newStart;i<stop;i++){
				let left=0,right=root;
				while(left<right){
					let mid=(right-left)/2+left|0;
					if(compareIndices(a,pivots[mid],i)==1)right=mid;
					else left=mid+1;
				}
				let pos=i;
				for(let j=root-1;j>=left;j--){
					rswap(a,pivots[j]+1,pos);
					rswap(a,pos=pivots[j],pivots[j]+1);
					write(pivots,j,pivots[j]+1);
				}
			}
			sort(a,start,pivots[0]);
			for(let i=1;i<root;i++)
				sort(a,pivots[i-1]+1,pivots[i]);
			sort(a,pivots[root-1]+1,stop);
		}
	}
	sort(array,0,len)
	return[5,1]
}
function apollyonSort(){
	let array=[...arr];
	const apm=(A,lo,n,d)=>{
		if(n<=1)return;
		let m=1;
		while(m<<1<n)m<<=1;
		for(let i=lo;i<lo+n-m;i++)
			if(d==(compareIndices(A,i,i+m)==1))
				rswap(A,i,i+m)
		apm(A,lo,m,d);
		apm(A,lo+m,n-m,d);
	}
	const aps=(A,lo,n,d)=>{
		if(n<=1)return;
		let m=n/2|0;
		aps(A,lo,m,!d);
		apm(A,lo,n,d);
	}
	aps(array,0,len,1);
	while(rcsr(array,0,len-1,0));
	return[5,1]
}
function optimizedPancakeSort(){
	let array=[...arr];
	function cursedRotate(a,b,m,c){
		reversal(a,0,b-1);
		reversal(a,0,m-1);
		reversal(a,0,c-1);
		reversal(a,0,c-m+b-1);
	}
	function bs(array,a,b,value,left){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(left?compareValues(value,array[m])<=0:compareValues(value,array[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function pm(array,m,b){
		let m1,m2,m3;
		if(m>=b-m){
			m1=m/2|0;
			m2=bs(array,m,b,array[m1],0);
			m3=m1+(m2-m);
		}else{
			m2=m+(b-m)/2|0;
			m1=bs(array,0,m,array[m2],1);
			m3=(m2++)-(m-m1);
		}
		cursedRotate(array,m1,m,m2);
		if(m1>0&&m3>m1)pm(array,m1,m3);
		m3++;
		if(m2>m3&&b>m2){
			cursedRotate(array,0,m3,b);
			pm(array,m2-m3,b-m3);
			cursedRotate(array,0,b-m3,b);
		}
	}
	function pms(array,n){
		if(n<=1)return;
		if(compareIndices(array,0,1)<=0){
			let i=2;
			for(;i<n&&compareIndices(array,i-1,i)<=0;i++);
			if(i==n)return;
		}else{
			let i=2;
			for(;i<n&&compareIndices(array,i-1,i)>0;i++);
			if(i==n){
				reversal(array,0,n-1);
				return;
			}
		}
		let m=n/2|0;
		pms(array,m);
		cursedRotate(array,0,m,n);
		m=n-m;
		pms(array,m);
		pm(array,m,n);
	}
	pms(array,len);
	return[5,1]
}
function magneticaQuickSort(){
	let array=[...arr];
	let left=0,right=len-1,threshold=17,i,j,pl,pr,entries=right-left+1,stack=new Array(entries),stackptr=2,p,lback=left,rback=right,midmid,gear=0,cmp;
	write(stack,1,left);
	write(stack,2,right);
	do{
		right=stack[stackptr];
		left=stack[stackptr-1];
		stackptr-=2;
		for(;left+threshold<right;){
			j=right;
			pl=left;
			pr=left;
			if(right-left>31){
				midmid=left+((right-left)>>2);
				if(gear==0){
					insertSort(array,midmid,midmid+3);
					rswap(array,midmid+1,pr);
				}else{
					insertSort(array,midmid,midmid+7);
					rswap(array,midmid+3,pr);
				}
			}
			p=array[pr];
			for(;pr<j;){
				pr++;
				cmp=compareValues(p,array[pr]);
				if(cmp>0){
					rswap(array,pl,pr);
					pl++;
				}else if(cmp<0){
					for(;compareValues(p,array[j])<0;)j--;
					if(pr<j)rswap(array,pr,j);
					j--;
					pr--;
				}
			}
			j=pl-1;
			i=pr+1;
			gear=(maxVal(right-i,j-left)>(minVal(right-i,j-left)<<6)?1:0);
			if(i+threshold<right){
				stackptr+=2;
				write(stack,stackptr-1,i);
				write(stack,stackptr,right);
				stackptr*=(stackptr+2<=entries-1?1:0);
				right*=(stackptr+2<=entries-1?1:0);
			}
			right=j;
		}
	}while(stackptr!=0);
	insertSort(array,lback,rback+1);
	return[5,1]
}
function cocktailPeelSort(){
	let array=[...arr];
	for(let l=0;l<len;l++){
		let s=0;
		for(let r=len-1;r>l;r--){
			if(compareIndices(array,l,r+s)>0){
				let i=array[r+s];
				for(let p=r+s;p>l;p--)rset(array,p,array[p-1]);
				rset(array,l,i);
				s++;
			}
		}
		l++;
		for(let r=l+1;r<len;r++){
			if(compareIndices(array,l,r)>0){
				let i=array[r];
				for(let p=r;p>l;p--)rset(array,p,array[p-1]);
				rset(array,l,i);
			}
		}
	}
	return[5,1]
}
function ecoloSort(){
	let array=[...arr];
	let l=1;
	let r=len;
	let w=1;
	let i=1;
	while(l<=r){
		if(w==1)i=l;
		else i=r;
		while((w==1&&i<r)||(w==-1&&i>l)){
			if(compareIndices(array,l-1,i-1)>0)rswap(array,l-1,i-1);
			if(compareIndices(array,i-1,r-1)>0)rswap(array,i-1,r-1);
			i+=w;
		}
		l++;
		r--;
		w*=-1;
	}
	return[5,1]
}
function fallSort(){
	let array=[...arr];
	let l=1;
	let r=2;
	let hl=0;
	while(l<=len){
		r=l+1;
		hl=0;
		while(r<=len){
			if(compareIndices(array,l-1,r-1)>0){
				if(hl==0)hl=r;
				else if(compareIndices(array,hl-1,r-1)<0)hl=r;
			}
			r++;
		}
		if(hl==0)l++;
		else rswap(array,l-1,hl-1);
	}
	return[5,1]
}
function heavyHeapSort(){
	let array=[...arr];
	function bitReversal(ar,a,b){
		let len=b-a,m=0;
		let d1=len>>1,d2=d1+(d1>>1);
		for(let i=1;i<len-1;i++){
			let j=d1;
			for(let k=i,n=d2;(k&1)==0;j-=n,k>>=1,n>>=1);
			m+=j;
			if(m>i)rswap(ar,a+i,a+m);
		}
	}
	let dir=0;
	for(let i=0;i<len;i++){
		heapify(array,i,len,dir,1);
		customFunc(heapify,[i,len,dir,1])
		dir=dir==0?1:0;
		
	}
	let n=1;
	while(n<=len)n+=2;
	while(n>=0){
		if(compareIndices(array,n,n-2)>0)rswap(array,n,n-2,n+=2)
		else n-=2
	}
	for(let i=1,j=len-1;i<j;i+=2,j-=2)
		rswap(array,i,j);
	bitReversal(array,0,len);
	bitReversal(array,0,len/2|0);
	bitReversal(array,len/2|0,len);
	return[15,1]
}
function sandPaperSort(){
	let array=[...arr];
	for(let i=0;i<len-1;i++)
		for(let j=i+1;j<len;j++)
			if(compareIndices(array,i,j)>0)
				rswap(array,i,j);
	return[5,1]
}
function recursiveBurningSort(){
	let array=[...arr];
	function sort(array,start,end){
		if(start==end)return;
		let mid=(start+end)/2|0,g0=mid-start;
		if (start==mid)return;
		sort(array,start,mid);
		sort(array,mid,end);
		for(let i=0;i<g0;i++)
			if(i+start!=end-i-1&&compareIndices(array,i+start,end-i-1)==1)
				rswap(array,i+start,end-i-1);
		sort(array,start,mid);
		sort(array,mid,end);
	}
	sort(array,0,len,0);
	return[5,1]
}
function corruptSort(){
	let array=[...arr];
	const comp=(a,s,e)=>{
		if(compareIndices(a,s,e)==1)
			rswap(a,s,e);
	}
	const pass=(a,s,e,l,g,t)=>{
		for(let i=s;i<e;i++)
			for(let g2=g;g2>t;g2/=2)
				if(i+g2<l)
					comp(a,i,i+g2);
	}
	const merge=(a,s,e,b)=>{
		if(e<=s)return;
		let m=(s+e)/2|0,g0=m-s,g1=g0/2|0;
		if(!b)
			for(let i=s;i<m;i++)
				if(i+g0<e)
					comp(a,i,i+g0);
		if(s==m)return;
		if(e-s>4)
			pass(a,s+g1,m,e,g1,1);
		merge(a,s,m,1);
		merge(a,m,e,1);
	}
	const sort=(a,s,e)=>{
		if(e<=s)return;
		let m=(s+e)/2|0;
		if(s==m)merge(a,s,e,0);
		else{
			sort(a,s,m);
			sort(a,m,e);
			merge(a,s,e,0);
		}
	}
	let n=1;
	while(n*2<=len)n*=2;
	sort(array,0,len);
	pass(array,0,len,len,n-1,0);
	return[5,1]
}
function circleHalverSort(){
	let array=[...arr];
	let end;
	const cs=(a,b,c)=>{
		let m=b<c&&c<len&&compareIndices(a,b,c)>0
		m&&rswap(a,b,c);
		return m;
	}
	const bc=(a,b,c)=>{
		let d=0
		for(let i=b,j=c-1;i<j;i++,j--)
			d=cs(a,i,j);
		return d;
	}
	const halver=(a,b,c)=>{
		let n=c-b,e=-1;
		while(1){
			for(let j=1;j<n/2;j*=2)
				for(let i=b;i<minVal(len,c);i+=2*j)
					for(let k=0;k<j;k++)
						cs(a,i+k,i+j+k);
			if(!bc(a,b,c))break;
			e++;
		}
	}
	let l=1<<(log(len-1)/log(2))+1|0;
	halver(array,0,l);
	for(let j=l/2;j>4;j/=2)
		for(let i=0;i+j/2<len;i+=j)
			if(bc(array,i,i+j))
				halver(array,i,i+j);
	for(let i=2;i<len;i+=4)
		cs(array,i-1,i);
	return[5,1]
}
function iterativePairwiseSort(){
	let array=[...arr];
	const sort=(ar,l)=>{
		let a=1,b=0,c=0,d=0,e=0;
		while(a<l){
			b=a;
			c=0;
			while(b<l){
				if(compareIndices(ar,b-a,b)==1)
					rswap(ar,b-a,b);
				c=(c+1)%a;
				b++;
				if(c==0)b+=a;
			}
			a*=2;
		}
		a/=4;
		e=1;
		while(a>circleDepth){
			d=++e;
			while(d>0){
				b=(d+1)*a;
				c=0;
				while(b<l){
					if(compareIndices(ar,b-d*a,b)==1)
						rswap(ar,b-d*a,b);
					c=(c+1)%a;
					b++;
					if(c==0)b+=a;
				}
				d/=2;
			}
			a/=2;
			e*=2;
		}
	}
	sort(array,len);
	return[5,1]
}
function iterativeVanVoorhisSort(){
	let array=[...arr];
	const cs=(a,b,c)=>{
		if(compareIndices(array,b,c)>0)rswap(a,b,c);
	}
	const cr=(a,b,c,s)=>{
		while(s-->0)cs(a,b++,c++);
	}
	for(let k=4;k/4<=len;k*=4){
		let f=k/4;
		for(let i=0;i<len;i+=k){
			cr(array,i,i+f,f);
			cr(array,i+f+f,i+f+f+f,f);
		}
		for(let i=0;i<len;i+=k){
			cr(array,i,i+f+f,f);
			cr(array,i+f,i+f+f+f,f);
		}
		for(let i=0;i<len;i+=k)
			cr(array,i+f,i+f+f,f);
		for(let m=16;m<=k;m*=4){
			let s=k/m;
			for(let i=0;i<len;i+=k){
				for(let j=2;j+7<m;j+=4){
					cr(array,i+j*s,i+(j+6)*s,s);
					cr(array,i+(j+1)*s,i+(j+7)*s,s);
				}
			}
			for(let i=0;i<len;i+=k){
				for(let j=1;j+5<m;j+=4){
					cr(array,i+j*s,i+(j+3)*s,s);
					cr(array,i+(j+2)*s,i+(j+5)*s,s);
				}
			}
			for(let i=0;i<len;i+=k){
				for(let j=2;j+3<m;j+=4){
					cr(array,i+j*s,i+(j+2)*s,s);
					cr(array,i+(j+1)*s,i+(j+3)*s,s);
				}
			}
			for(let i=0;i<len;i+=k)
				for(let j=3;j+3<m;j+=2)
					cr(array,i+j*s,i+(j+1)*s,s);
		}
	}
	return[5,1]
}
function rotateLSDRadixSort(){
	let array=[...arr];
	const msw=(a,b,c,l)=>{
		for(let i=0;i<l;i++)rswap(a,b+i,c+i);
	}
	function rotate(a,b,c,m){
		let l=m-b,r=c-m;
		while(l>0&&r>0){
			if(r<l){
				msw(a,m-r,m,r);
				c-=r;m-=r;l-=r;
			}else{
				msw(a,b,m,l);
				b+=l;m+=l;r-=l;
			}
		}
	}
	function bs(ar,a,b,d,p){
		while(a<b){
			let m=(a+b)/2|0;
			if(getDigit(ar[m],p,base)>=d)b=m;
			else a=m+1;
		}
		return a;
	}
	function merge(array,a,m,b,da,db,p){
		if(b-a<2||db-da<2)return;
		let dm=(da+db)/2|0;
		let m1=bs(array,a,m,dm,p);
		let m2=bs(array,m,b,dm,p);
		rotate(array,m1,m2,m);
		m=m1+(m2-m);
		merge(array,m,m2,b,dm,db,p);
		merge(array,a,m1,m,da,dm,p);
	}

	function ms(ar,a,b,p){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		ms(ar,a,m,p);
		ms(ar,m,b,p);
		merge(ar,a,m,b,0,base,p);
	}
	let base=10;
	let max=maxLog(array,len,base);
	for(let i=0;i<=max;i++)
		ms(array,0,len,i);
	return[5,1]
}
function digSort(){
	let array=[...arr];
	function par(ar,a,b){
		let mx=new Array(b-a),
			max=ar[a];
		for(let i=1;i<b-a;i++){
			if(ar[a+i]>max){
				max=ar[a+i];
				mx[i]=1;
			}
		}
		let p=1;
		for(let i=b-a-1,j=b-a-1;j>=0&&i>=p;j--){
			while(!mx[j]&&j>0)j--;
			max=array[a+j];
			while(max<=ar[a+i]&&i>=p)i--;
			if(compareIndices(ar,a+j,a+i)==1&&p<i-j)p=i-j;
		}
		return p;
	}
	let ls=0,le=0,ms=len-2,sw=1;
	for(let i=0;i<len&&sw;i=ls){
		le=par(array,0,len);
		sw=0;
		let msed=0;
		for(let j=ms;j>=i;j--){
			if(compareIndices(array,j,j+1)>0){
				rswap(array,ls=j,j+1);
				sw=1
				if(msed){
					msed=1;
					ms=j+1<len-1?j+1:len-2;
				}
			}
		}
		for(let l=ls+1;l<=ms&&sw;l++){
			if(compareIndices(array,l,l+1)>0){
				let bl=l+le<len-1?l+le:len-2;
				for(let r=l+1;r<=bl;r++){
					if(compareIndices(array,l,r)>0){
						rswap(array,l++,r);
						if(r>ms)ms=r;
					}
				}
			}
		}
	}
	return[5,1]
}
function cityscapeSort(){
	let array=[...arr];
	function csdep(a,i,j){
		if(i==j)return;
		let b=math.min(i,j),c=math.max(i,j);
		if(compareIndices(a,b,c)>0)rswap(a,b,c);
	}
	function sp(a,s,e,g){
		for(let h=g,i=h+s;i<e;i++){
			let v=a[i],j=i,w=0;
			for(;j>=h&&j-h>=s&&compareValues(a[j-h],v)==1;j-=h)rset(a,j,a[j-h],w=1);
			if(w)rset(a,j,v);
		}
	}
	function sh(a,s,e){
		for(let g=((e-s)/2.25)|0;g>=2;g/=2.25)sp(a,s,e,g|0);
		sp(a,s,e,1);
	}
	function mxs(ar,st,e){
		let a=e-1,b=e-1,sg=1;
		while(sg){
			if(b-1<st)return st;
			if(compareIndices(ar,b-1,b)>0)sg=0;
			else b--;
		}
		let sel=b-1;
		for(let s=b-2;s>=st;s--)
			if(compareIndices(ar,sel,s)<0)sel=s;
		while(compareIndices(ar,sel,a)<=0)
			if(--a<st)break;
		return a+1;
	}
	function shuffle(a,s,e){
		for(let i=s;i<e;i++){
			let r=random()*(e-i)+i|0;
			if(r!=i)rswap(array,i,r);
		}
	}
	let i=len;
	while(i>0){
		let h=i,j=0;
		for(;j<i;j++){
			csdep(array,j,j+1);
			for(h=i-1;h>i-j-2;h--){
				csdep(array,j,h);
				if(h<=j)break;
			}
			if(h<=j)break;
		}
		sh(array,j,i);
		i=mxs(array,0,i);
		shuffle(array,0,i);
	}
	return[5,1]
}
function iterativeClericSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(iclsr(array,n,len));
	return[5,1]
}
function recursiveClericSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rclsr(array,0,n-1,0));
	return[5,1]
}
function debrisSort(){
	let array=[...arr];
	let i=0;
	let f=1;
	let l=len-1;
	let nl=len-1;
	let ar=true;
	while(ar){
		ar=false;
		let ff=false;
		if(f>0)i=f-1;
		else i=0;
		for(;i<l;i++){
			let s=i;
			for(;compareIndices(array,i,i+1)>0&&i<l;i++){
				if(!ff){
					f=i;
					ff=true;
				}
				nl=i+1;
			}
			let e=i;
			if(s!=e){
				if(e-s<3)rswap(array,s,e,1,ar=true);
				else reversal(array,s,e,1,ar=true);
			}
		}
		if(nl+1<len)l=nl+1;
		else l=len-1;
	}
	return[5,1]
}
function californiumSort(){
	let array=[...arr];
	function sqrtrnd(v){
		let p=0;
		while(++p*p<v);
		return p;
	}
	function cal(ar,a,b,d,d2){
		if(b-a==2&&compareIndices(ar,a,a+1)>0)rswap(ar,a,a+1);
		if(--d2<1){
			for(let i=a;++i<b;)
				if(compareIndices(ar,i-1,i)>0)
					rswap(ar,i-1,i,i=a);
			return;
		}
		if(a>=b-2)
			return;
		let recurse=new Array(),maxstack=new Array();
		let i=b,j,k,m,me=0,b0=b;
		let shd=0;
		bndchk:while(i>a+1){
			recurse.unshift(i=b0)
			maxstack=[];
			for(k=sqrtrnd(i-a);k-->0;){
				shd=maxstack.length&&compareValues(ar[a],maxstack[0])>=0;
				me=0;
				for(j=(m=a)+1;j<i;j++){
					let p=compareIndices(ar,m,j);
					if(p==0)me++;
					if(p<0||shd)
						if(!maxstack.length||compareValues(ar[j],maxstack[0])<0){
							m=j;
							shd=0;
							me=0;
						}
				}
				if(shd)
					break bndchk;
				maxstack.unshift(ar[m])
				k-=me;
			}
			cnt:for(j=b0=a;j<i;j++){
				for(let i=0;i<maxstack.length;i++){
					let v=maxstack[i]
					if(compareValues(ar[j],v)==0){
						reversal(ar,b0,j-1,1);
						continue cnt;
					}
				}
				reversal(ar,b0,j-1,2);
				reversal(ar,a,b0-1,2);
				rmultiSwap(ar,j,b0++);
			}
		}
		if(me==b-a-1)
			return;
		j=a;
		for(k=0;k<recurse.length;k++)
			cal(ar,j,j=recurse[k],d,d2);
	}
	cal(array,0,len,0,(32-clz32(len-1))/2|0);
	return[5,1]
}
function evubSort(){
	let array=[...arr];
	function cs(a,z){
		if(compareIndices(a,z,z+1)>0)
			rswap(a,z,z+1);
	}
	function sort(a,b,bs){
		if(bs==1)
			for(let c=0;c<=b;c++)
				cs(a,c);
		else
			for(let c=0;c<=b;c++)
				sort(a,c,bs-1);
	}
	let base=3;
	for(let a=len-1;a>0;a--)
		for(let b=0;b+1<=a;b++)
			if(base==2)cs(array,b);
			else sort(array,b,base-2);
	return[5,0]
}
function iterativeFiringSquadSort(){
	let array=[...arr];
	function fs(array,start,end,dir){
		if(dir){
			let left=start;
			let right=start+1;
			let lcycle=1;
			let rcycle=true;
			while(left<right){
				if(compareIndices(array,left,right)>0)rswap(array,left,right,swaps=1);
				if(++lcycle>2){
					left++;
					lcycle=0;
				}
				if(rcycle){
					if(++right>end-1){
						right--;
						rcycle=0;
					}
				}else right--;
			}
		}else{
			let right=end-1;
			let left=end-2;
			let rcycle=1;
			let lcycle=true;
			while(left<right){
				if(compareIndices(array,left,right)>0)rswap(array,left,right,swaps=1);
				if(++rcycle>2){
					right--;
					rcycle=0;
				}
				if(lcycle){
					if(--left<start){
						left++;
						lcycle=false;
					}
				}else left++;
			}
		}
	}
	function init(array,start,end,firstdir){
		fs(array,start,end,firstdir);
		let dir=true;
		for(let l=(end-start)/2;l>1;l/=2)
			for(let i=start;i+l<=end;i+=l)
				fs(array,i,i+l,dir=!dir);
	}
	let swaps=1;
	let l=2;
	for(;l*2<=len;l*=2);
	let cdir=0;
	while(swaps){
		swaps=false;
		if(l==len)init(array,0,len,cdir=!cdir);
		else{
			init(array,0,l,true);
			if(len-l>=l/2)init(array,(len-l)/2|0,(len+l)/2|0,true);
			init(array,len-l,len,false);
		}
	}
	return[5,1]
}
function recursiveFiringSquadSort(){
	let array=[...arr];
	function fs(array,start,end,dir){
		if (dir) {
			let left=start;
			let right=start+1;
			let lcycle=1;
			let rcycle=true;
			while(left<right){
				if(compareIndices(array,left,right)>0)rswap(array,left,right,swaps=1);
				if(++lcycle>2){
					left++;
					lcycle=0;
				}
				if(rcycle){
					if(++right>end-1){
						right--;
						rcycle=0;
					}
				}else right--;
			}
		}else{
			let right=end-1;
			let left=end-2;
			let rcycle=1;
			let lcycle=1;
			while(left<right){
				if(compareIndices(array,left,right)>0)rswap(array,left,right,swaps=1);
				if(++rcycle>2){
					right--;
					rcycle=0;
				}
				if(lcycle){
					if(--left<start){
						left++;
						lcycle=0;
					}
				}else left++;
			}
		}
		if(end-start>2){
			fs(array,start,end-(end-start)/2|0,false);
			fs(array,end-(end-start)/2|0,end,true);
		}
	}
	let swaps=1;
	let l=2;
	for(;l*2<=len;l*=2);
	let cdir=0;
	while(swaps){
		swaps=false;
		if(l==len)fs(array,0,len,cdir=!cdir);
		else{
			fs(array,0,l,true);
			if(len-l>=l/2)init(array,(len-l)/2|0,(len+l)/2|0,true);
			fs(array,len-l,len,false);
		}
	}
	return[5,1]
}
function fordSort(){
	let array=[...arr];
	let q=0;
	while(!rangeSorted(array,len)){
		for(let k=len/2;k>0;k--){
			for(let i=q;i<len;i+=2*k){
				let l=i;
				let change=0;
				while(l>0&&compareIndices(array,l,l-1)==-1){
					rswap(array,l,l-1);
					l-=2;
					if(i>0)i--;
					change=1;
				}
				if(change)i++;
				else i--;
			}
		}
		q=(q+1)&1;
	}
	return[5,1]
}
function futureSort(){
	let array=[...arr];
	let as=1;
	let tl=2;
	for(;tl*2<=len;tl*=2);
	let l=len;
	while(as){
		as=0;
		let ls=0;
		for(let o=0,m=1;o!=l-1;o++){
			if(tl>1){
				while(o+m*2<l)m*=2;
				while(m>=tl)m/=2;
			}
			for(;m>=1;m/=2)
				if(compareIndices(array,o,o+m)>0)
					rswap(array,ls=o,o+m,as=1);
		}
		l=ls+2<l?ls+1:l-1;
		if(tl>1)tl/=2;
	}
	return[5,1]
}
function iterativePopSort(){
	let array=[...arr];
	const bubble=(a,st,e,d)=>{
		let c=1;
		let s;
		let f=1;
		for(let j=e-1;j>0;j-=c){
			if(f-1<st)s=st;
			else s=f-1;
			let b=0;
			c=1;
			for(let i=s;i<j;i++){
				if(compareIndices(array,i,i+1)==d){
					rswap(array,i,i+1);
					if(!b)f=i;
					b=1;
					c=1;
				}else c++;
			}
		}
	}
	for(let l=2;l<len;l*=2){
		let i=0;
		let d=-1;
		for(;i+l<=len;i+=l,d*=-1)bubble(array,i,i+l,d);
		if(i!=len)bubble(array,i,len,d);
	}
	bubble(array,0,len,1);
	return[5,1]
}
function jumpDownSort(){
	let array=[...arr];
	for(let i=len-1;i>0;i--)
		for(let j=0;j<i;j++)
			if(compareIndices(array,i,j)<0)
				rswap(array,i,j);
	return[5,1]
}
function monolithicClurgeSort(){
	let array=[...arr];
	const mc=(a,s,m,e,b)=>{
		if(m<=s||e<=m)return;
		if(b==0){
			mc(a,s,s+(m-s)/2|0,m,0);
			mc(a,m,m+(e-m)/2|0,e,0);
			mc(a,s,m,e,1);
		}else{
			let c=0;
			if((c=compareIndices(a,s,m))==1)
				rswap(a,s,m);
			mc(a,s+1,m,e,2);
			if(b!=2)
				mc(a,s+(c==-1?2:1),m+1,e,1);
		}
	}
	mc(array,0,len/2|0,len,0);
	return[5,1]
}
function pairwiseCombSort(){
	let array=[...arr];
	const i3s=n=>{
		while((n&1)==0)n>>=1;
		return(n&++n)==0;
	}
	for(let g=len/2;g>0;g--)
		if(i3s(g))
			for(let i=g;i<len;i++)
				if(compareIndices(array,i-g,i)==1)
					rswap(array,i-g,i);
	return[5,1]
}
function pancakeQuickSort(){
	let array=[...arr];
	const flip=(a,i)=>{
		reversal(a,0,i,1);
	}
	const rot=(a,c1,c2)=>{
		flip(a,c1-1);
		flip(a,c2-1);
		flip(a,c2-c1-1);
	}
	const medOf3=(a,p1,p2,p3)=>{
		if(p1==p2)return p1;
		if(p2==p3)return p2;
		if(compareIndices(a,p1,p2)<=0){
			if(compareIndices(a,p2,p3)<=0)return p2;
			if(compareIndices(a,p1,p3)<=0)return p3;
			return p1;
		}
		if(compareIndices(a,p2,p3)<=0)return p2;
		if(compareIndices(a,p1,p3)<=0)return p1;
		return p3;
	}
	function pancakeLLQS(a,l){
		if(l==2){
			if(compareIndices(a,0,l-1)>0)
				flip(a,l-1);
			return;
		}else if(l<2)return;
		let j=0,m=(l-1)/2|0,piv=a[medOf3(a,0,m,l-1)];
		for(let i=0;i<l;i++){
			let k=i;
			while(k<l&&compareValues(piv,a[k])>=0){
				k++;j++;
			}
			if(k>i){
				flip(a,i-1);
				flip(a,k-1);
				i=k-1;
			}
		}
		pancakeLLQS(a,j);
		rot(a,j,l);
		pancakeLLQS(a,l-j);
		rot(a,l-j,l);

	}
	pancakeLLQS(array,len);
	return[5,1]
}
function popPopSort(){
	let array=[...arr];
	const bb=(a,s,e,d)=>{
		let ls=e-1;
		while(ls>=s+1){
			let j=s;
			for(let i=s;i<=ls;i++)
				if(compareIndices(a,i-1,i)==d)
					rswap(array,i-1,j=i);
			ls=j;
		}
	}
	const p=(a,s,e,d)=>{
		bb(a,s,s+(e-s)/4|0,0-d);
		bb(a,s+(e-s)/4+1|0,(s+e)/2|0,d);
		bb(a,(s+e)/2+1|0,s+(e-s)*3/4|0,0-s);
		bb(a,s+(e-s)*3/4+1|0,e,d);
		bb(a,s,(s+e)/2|0,0-d);
		bb(a,(s+e)/2+1|0,e,d);
		bb(a,s,e,d);
	}
	p(array,1,(len+1)/4|0,-1);
	p(array,(len+1)/4+1|0,(len+1)/2|0, 1);
	p(array,(len+1)/2+1|0,(len+1)*3/4|0,-1);
	p(array,(len+1)*3/4+1|0,len,1);
	p(array,1,(len+1)/2|0,-1);
	p(array,(len+1)/2+1|0,len,1);
	p(array,1,len,1);
	return[5,0]
}
function inPlaceLSDRadixSort(){
	let array=[...arr];
	let pos=0;
	let base=10;
	let vregs=new Array(base-1);
	let maxpower=maxLog(array,len,base);
	for(let p=0;p<=maxpower;p++){
		for(let i=0;i<vregs.length;i++)
			write(vregs,i,len-1);
		pos=0;
		for(let i=0;i<len;i++){
			let digit=getDigit(array[pos],p,base);
			if(digit==0)
				pos++;
			else{
				for(let j=0;j<vregs.length;j++)
					rswap(array,vregs[j],vregs[j]);
				rmultiSwap(array,pos,vregs[digit-1]);
				for(let j=digit-1;j>0;j--)
					write(vregs,j-1,vregs[j-1]-1);
			}
		}
	}
	return[5,1]
}
function swaplessPushSort(){
	let array=[...arr];
	let as=1,i,f=1;
	while(as){
		as=0;
		if(f>1)i=f-1;
		else i=1;
		let g=1;
		while(i+g<=len){
			if(compareIndices(array,i-1,i-1+g)>0){
				if(!as)f=i;
				insertTo(array,i-1+g,i-1,2,as=1);
				g++;
			}else i++;
		}
	}
	return[5,1]
}
function reboundSort(){
	let array=[...arr];
	let st=0;
	let s=0;
	for(let d=1;!s;d*=-1){
		let i=d==1||!st?0:len-2;
		st=1;
		s=1;
		for(;i>=0&&i<len-1;i+=d)
			if(compareIndices(array,i,i+1)>0){
				rswap(array,i,i+1,s=0);
				d=-d;
			}
	}
	return[5,1]
}
function rubbleSort(){
	let array=[...arr];
	const sig=(a,b,d)=>((a+d)+d*abs(a-b))/2|0;
	function run(a,s,e){
		if(s>=e-1)return s+1;
		let c=-compareIndices(a,s++,s)|1,k=s-1,d;
		do d=compareIndices(a,s++,s);while(s<e&&d!=c);
		let m=(s-k)/2|0,q=sig(k,s-1,-c);
		for(let i=0;i<m;i++)rswap(a,k+i,q+c*i);
		return s;
	}
	let runs=new Array(len/2|0);
	let rf=0,r=0;
	while(r<len)write(runs,rf++,(r=run(array,r,len))-1);
	while(rf>1){
		for(let i=1;i<rf;i++){
			if(compareIndices(array,runs[i-1],runs[i])>0){
				let t=array[runs[i-1]],temp=runs[i-1]-1;
				while(temp>=(i-2<0?0:runs[i-2]+1)){
					if(compareIndices(array,temp,runs[i])<=0)break;
					rset(array,temp+1,array[temp--]);
				}
				rset(array,temp+1,array[runs[i]]);
				rset(array,runs[i],t);
			}
		}
		if(runs[rf-1]==runs[rf-2])write(runs,--rf,0);
		else write(runs,rf-1,runs[rf-1]-1);
	}
	insertSort(array,0,len)
	return[5,1]
}
function searchSort(){
	let array=[...arr];
	const bs=(a,b,c,v)=>{
		while(b<c){
			let m=b+((c-b)/2)|0;
			if(compareValues(v,a[m])<0)c=m;
			else b=m+1;
		}
		return b;
	}
	let i=0;
	while(i+1<len){
		let ver=1;
		while(i+1<len&&ver){
			if(compareIndices(array,i,i+1)<=0)i++;
			else ver=0;
		}
		if(i+1<len)rswap(array,i+1,bs(array,0,i,array[i+1]));
	}
	return[5,1]
}
function selectionSort(){
	let array=[...arr];
	for(let i=0;i<len-1;i++){
		let l=i;
		for(let j=i+1;j<len;j++)
			if(compareIndices(array,j,l)==-1)
				l=j;
		rswap(array,i,l);
	}
	return[5,1]
}
function iterativeShircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(ishsr(array,n));
	return[5,1]
}
function recursiveShircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rshsr(array,0,n-1,0));
	return[5,1]
}
function merryGoRoundSort(){
	let array=[...arr];
	let i=1,v=1,d=1,c=0,s=0;
	function cf(arr,i,l,c,d){
		if(compareIndices(arr,i-1,i)>0){
			for(c=1,d=i;d+1<=l;d+=2)
				swap(arr,d-1,d);
			if(i>1)i--;
		}else i+=2;
		return i
	}
	while(!s){
		for(i=v,c=0;i+1<=len;){
			customFunc(cf,[i,len])
			i=cf(array,i,len)
		}
		if(!c){
			for(v=1,s=1;v!=len&&s;){
				if(compareIndices(array,v-1,v)<=0)v++;
				else s=0;
			}
		}
	}
	return[5,1]
}
function XSort(){
	let array=[...arr];
	let gap=len;
	function cf(ar,g,l){
		let as=0
		for(let i=1;i-1+g<l;i++){
			if(compareIndices(ar,i-1,i-1+g)>0){
				swap(ar,i-1,i-1+g);
				as=true;
				let xleft=i+1;
				let xright=i+g-1;
				if(g!=1){
					for(let r=0;r<g-1;r++){
						if(compareIndices(ar,xleft-1,xright-1)>0)
							swap(ar,xleft-1,xright-1);
						xleft++;
						xright--;
					}
				}
			}
		}
		return[g,as]
	}
	let as=0;
	while(1){
		[gap,as]=cf(array,gap,len)
		customFunc(cf,[gap,len])
		if(!as){
			if(gap==1)break;
			else gap--;
		}
	}
	return[5,1]
}
function blockShellSort(){
	let array=[...arr];
	function gappedBinary(A,P,l,K,G,i){
		let L=-1,R=l,C,M;
		while(L<R-1){
			M=L+((R-L)>>1);
			C=compareIndices(A,P+M*G,K);
			if(C==1||(i&&C==0))R=M;
			else L=M;
		}
		return R;
	}
	function GSFW(A,P,L,G){
		let t=A[P];
		for(let i=0;i<L;i++)rset(A,P+i*G,A[P+(i+1)*G]);
		rset(A,P+L*G,t);
	}
	function GSBW(A,P,L,G){
		let t=A[P+L*G];
		for(let i=L;i>0;i--)rset(A,P+i*G,A[P+(i-1)*G]);
		rset(A,P,t);
	}
	function GMSFW(A,lA,lB,L,G){
		for(let i=0;i<L;i++)rswap(A,lA+i*G,lB+i*G);
	}
	function GMSBW(A,lA,lB,L,G){
		for(let i=0;i<L;i++)rswap(A,lA+i*G,lB+i*G);
	}
	function rotate(A,P,L,R,G){
		while(L>1&&R>1){
			if(L<=R){
				GMSFW(A,P,P+L*G,L,G);
				P+=L*G;
				R-=L;
			}else{
				GMSBW(A,P+(L-R)*G,P+L*G,R,G);
				L-=R;
			}
		}
		if(L>0&&R>0){
			if(L==1)GSFW(A,P,R,G);
			else if(R==1)GSBW(A,P,L,G);
		}
	}
	function merge(array,P,L0,L1,G){
		let S;
		if(L0<L1){
			while(L0!=0){
				S=gappedBinary(array,P+L0*G,L1,P,G,true);
				if(S!=0){
					rotate(array,P,L0,S,G);
					P+=S*G;
					L1-=S;
				}
				if(L1==0)break;
				do{P+=G;L0--;}while(L0!=0&&compareIndices(array,P,P+L0*G)<=0);
			}
		}else{
			while(L1!=0){
				S=gappedBinary(array,P,L0,P+(L0+L1-1)*G,G,false);
				if(S!=L0){
					rotate(array,P+S*G,L0-S,L1,G);
					L0=S;
				}
				if(L0==0)break;
				do L1--;while(L1!=0&&compareIndices(array,P+(L0-1)*G,P+(L0+L1-1)*G)<=0);
			}
		}
	}
	function gappedReverse(a,s,e,g){
		for(;s<=e-g;s+=g,e-=g)rswap(a,s,e);
	}
	function getRun(array,start,end,gap){
		let t=start,iD=-compareIndices(array,start,start+gap),len=1;
		if(end-start<gap)return 1;
		if(iD==0)iD=1;
		do{len++;start+=gap;}while(start<=end-gap&&compareIndices(array,start,start+gap)!=iD);
		if(iD==-1)gappedReverse(array,t,start,gap);
		return len;
	}
	let gaps=[1,4,10,23,57,132,301,701];
	function ciura(n){
		if(n<=gaps.length)return gaps[n-1];
		return pow(2.25,n)|0;
	}
	function shellPass(array,start,end,gap){
		if(end-start<gap)return;
		let done,starts=new Array(gap),lens=new Array(gap),ends=new Array(gap);
		for(let i=0;i<gap;i++){
			starts[i]=start+i;
			lens[i]=0;
			ends[i]=(end-(end%gap))+i;
			if(ends[i]>=end)
				ends[i]-=gap;
		}
		do{
			done=true;
			for(let i=0;i<gap;i++){
				let v=starts[i]+lens[i]*gap;
				if(v>ends[i]||ends[i]==-1)continue;
				done=false;
				let r=getRun(array,v,ends[i],gap);
				merge(array,starts[i],lens[i],r,gap);
				write(lens,i,lens[i]+r);
			}
		}while(!done);
	}
	let k=1;
	while(ciura(k++)<len);
	while(--k>1)shellPass(array,0,len,ciura(k-1));
	return[5,1]
}
function testSort(){
	let array=[...arr];
	function shift(n,q){
		while(q>0){
			n/=base;
			q--;
		}
		return n|0;
	}
	function ms(ar,a,b,l){
		for(let i=0;i<l;i++)
			rswap(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				ms(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				ms(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function bs(ar,a,b,d,p){
		while(a<b){
			let m=(a+b)/2|0;
			if(getDigit(ar[m],p,base)>=d)b=m;
			else a=m+1;
		}
		return a;
	}
	function merge(ar,a,m,b,da,db,p){
		if(b-a<2||db-da<2)return;
		let dm=(da+db)/2|0;
		let m1=bs(ar,a,m,dm,p);
		let m2=bs(ar,m,b,dm,p);
		rot(ar,m1,m,m2);
		m=m1+(m2-m);
		merge(ar,m,m2,b,dm,db,p);
		merge(ar,a,m1,m,da,dm,p);
	}
	function mergeSort(ar,a,b,p){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		mergeSort(ar,a,m,p);
		mergeSort(ar,m,b,p);
		merge(ar,a,m,b,0,base,p);
	}
	function dist(ar,a,b,p){
		mergeSort(ar,a,b,p);
		return bs(ar,a,b,1,p);
	}
	let base=4;
	let q=maxLog(array,len,base);
	let m=0,i=0,b=len;
	while(i<len){
		let p=b-i<1?i:dist(array,i,b,q);
		if(q==0){
			m+=base;
			let t=m/base;
			while(t%base==0){
				t/=base;
				q++;
			}
			i=b;
			while(b<len&&shift(array[b],q+1)==shift(m,q+1))
				b++;
		}else{
			b=p;
			q--;
		}
	}
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function s(m=0,i=0){
	arr=create(count).sort((a,b)=>a-b);
	let start=0,end=len-1,done=0,d=1,ticks=0;
	let shuffling=setInterval(()=>{
		if(++ticks%4==0)display(arr)
		if(!done){
			canskip=0
			names.innerText="Shuffling...";
			inputdisplay.innerText=""
			if(i==0){
				for(let fv=0;fv<len*.01&&start<count;fv++,done=start>=count)swap(arr,start++,random()*len|0,1);
			}else if(i==1){
				for(let fv=0;fv<len/100;fv++){
					d=start>=end
					if(!d)swap(arr,start++,end--,1)
				}
				done=d
			}else if(i==2){
				for(let fv=0;fv<len/100;fv++){
					d=start>=len/4|0
					if(!d)swap(arr,start,len-1-start++,1)
				}
				done=d
			}else if(i==3){
				for(let fv=0;fv<len*.01&&start<count;fv++,++start,done=start>=count)random()>.8&&swap(arr,start-1,random()*start|0,1);
			}else if(i==4&&d){
				d=0
				let tmp=0,s1=1,shuf=setInterval(()=>{
					if(tmp<len/5|0&&s1){
						s1=0
						if(random()>.8){
							let j=tmp+maxVal(random()*len-tmp|0,0),k=setInterval(()=>{
								for(let x=0;x<=len*.25|0;x++){
									if(j<len-1-random()*tmp|0)swap(arr,j,++j,1)
									else{
										clearInterval(k)
										tmp++
										s1=1
										break;
									}
								}
							})
						}else s1=1;
					}else if(s1){
						clearInterval(shuf)
						done=1
					}
				})
			}else if(i==5&&d){
				d=0
				let tmp=0,s1=1,shuf=setInterval(()=>{
					if(tmp<len/5|0&&s1){
						s1=0
						if(random()>.8){
							let j=minVal(random()*len+tmp|0,len-1)-tmp,k=setInterval(()=>{
								for(let x=0;x<=len*.25|0;x++){
									if(j>random()*tmp|0)swap(arr,j,--j,1)
									else{
										clearInterval(k)
										tmp++
										s1=1
										break;
									}
								}
							})
						}else s1=1;
					}else if(s1){
						clearInterval(shuf)
						done=1
					}
				})
			}else if(i==6){
				let tmp=[]
				for(let fv=len-1;fv>1;fv-=2)tmp[tmp.length]=arr.splice(fv,1)[0]
				arr=tmp.reverse().concat(arr)
				done=1
			}else if(i==7){
				let half=len/2|0,tmp=arr.splice(half,len)
				arr=tmp.concat(arr)
				done=1
			}else if(i==8){
				let tmp=[]
				for(let fv=len-1;fv>1;fv-=2)tmp[tmp.length]=arr.splice(fv,1)[0]
				arr=arr.concat(tmp)
				done=1
			}else if(i==9){
				let e=0
				while(e+2<len)e+=2;
				for(let start=0,end=e;start<end;start+=2,end-=2)swap(arr,start,end)
				done=1
			}else if(i==10){
				let rm=(sqrt(len)/4|0),temp=[...arr],c=len-1;
				arr=arr.filter((e,i)=>!(++i%rm))
				for(let i=0;i<rm;i++)arr=arr.concat(temp)
				arr=arr.sort((a,b)=>a-b).splice(0,len)
				while(c)swap(arr,c,random()*c--|0)
				done=1
			}else if(i==11){
				swap(arr,random()*len|0,random()*len|0,1)
				done=1
			}else if(i==12&&d){
				d=0
				let k1,n=len/2
				k1=setInterval(()=>{
					if(n>=1){
						for(let x=0;x<=len|0;x++){
							let b=1
							while(n<=len/2&&b){
								let leaf=2*n;
								if(leaf<len&&arr[leaf-1]<arr[leaf])leaf++;
								if(arr[n-1]<arr[leaf-1]){
									swap(arr,n-1,leaf-1,1);
									n=leaf;
								}else b=0;
							}
							n--
						}
					}else{
						clearInterval(k1)
						done=1
					}
				})
			}else if(i==13&&d){
				d=0
				let c=2,min=arr[0],max=arr[0],exp=1,pass=0,k1,w1=1,k2;
				for(let n=1;n<len;n++){
					if(arr[n]<min)min=arr[n];
					if(arr[n]>max)max=arr[n];
				}
				k1=setInterval(()=>{
					if(w1){
						w1=0;
						pass++
						if((max-min)/exp>=1){
							let n,b=new Array(10).fill(0),output=new Array(len);
							for(n=0;n<len;n++)b[((arr[n]-min)/exp)%10|0]++;
							for(n=1;n<10;n++)b[n]+=b[n-1];
							for(n=len-1;n>=0;n--)output[--b[((arr[n]-min)/exp)%10|0]]=arr[n];
							n=-1;
							while(n<len){
								if(++n<len)
									arr[n]=output[n];
								else if(pass<2){
									clearInterval(k2);
									w1=1;
									exp*=10;
									break;
								}else{
									clearInterval(k2);
									clearInterval(k1);
									done=1
									d=1
									break;
								}
							}
						}
					}
				});
			}else if(i==14&&d){
				d=0
				done=1
			}
		}else{
			clearInterval(shuffling);
			canskip=1
			names.innerText="currently frozen/crashed";
			setTimeout(()=>{
				names.innerText=sn[m][0]+" ("+(m+1)+"/"+Object.keys(sn).length+")";
				inputdisplay.innerText=inputs[i]
				rdisp([...sn[m][1](),function(){
					didskip=0
					display(arr)
					let z=-1,y=setInterval(()=>{
						if(z>=len){
							clearInterval(y);
							setTimeout(()=>{
								if(!loopsort.checked){
									let snl=Object.keys(sn).length
									if(++m==snl){
										i++
										i%=inputs.length
										m%=snl
									}
								}
								if(queue==null){
									s(m,i)
								}else{
									s(queue,i)
									queue=null;
									nextsort.innerText="Next: ...";
								}
							},3e2)
						}
						for(let n=0;n<len*.04;n++){
							mark(++z+1,"lime")
							ctx.fillRect(z*bw,count-arr[z],bw,arr[z])
						}
					},1e3/50)
				}])
			});
			display(arr)
		}
	})
}
function set(v){
	sn.push(v)
}
function get(n,cs=0){
	if(n.trim().length==0)return 0;
	n=cs?n:n.toLowerCase();
	let offset=[];
	for(let i=0;i<sn.length;i++){
		let v=cs?sn[i][0]:sn[i][0].toLowerCase();
		offset[i]=[0,i];
		if(n.match(v))return i
		for(let j=0;j<n.length;j++)
			if(n[j]==v[j])
				offset[i][0]++
		offset[i][0]/=n.length
		offset[i][0]*=100;
	}
	return offset.sort((a,b)=>b[0]-a[0])[0][1]
}
set(["Iterative Bitonic Sort",iterativeBitonicSort])
set(["Batcher's Bitonic Sort",batcherBitonicSort])
set(["Iterative Bose-Nelson Sort",iterativeBoseNelsonSort])
set(["Recursive Bose-Nelson Sort",recursiveBoseNelsonSort])
set(["Crease Sort",creaseSort])
set(["Iterative Diamond Sort",iterativeDiamondSort])
set(["Recursive Diamond Sort",recursiveDiamondSort])
set(["Fold",foldSort])
set(["Batcher's Merge-Exchange Sort",batcherMergeExchangeSort])
set(["Recursive Odd-Even Merge Sort",recursiveOddEvenMergeSort])
set(["Iterative Pairwise Merge Sort",iterativePairwiseMergeSort])
set(["Recursive Pairwise Merge Sort",recursivePairwiseMergeSort])
set(["Iterative Weave Sort",iterativeWeaveSort])
set(["Recursive Weave Sort",recursiveWeaveSort])
set(["LSD Radix Sort",LSDRadixSort])
set(["In-Place LSD Radix Sort",inPlaceLSDRadixSort])
set(["In-Place MSD Radix Sort",inPlaceMSDRadixSort])
set(["L/MSD Radix Sort",LMSDRadixSort])
set(["Index Sort",indexSort])
set(["Bubble Sort",bubbleSort])
set(["Circloid Sort",circloidSort])
set(["Comb Sort",combSort])
set(["Complete Graph Sort",completeGraphSort])
set(["Cocktail Shaker Sort",cocktailShakerSort])
set(["Gnome Sort",gnomeSort])
set(["Left/Left Quick Sort",LLQuickSort])
set(["Left/Right Quick Sort",LRQuickSort])
set(["Odd-Even Sort",oddEvenSort])
set(["Stooge Sort",stoogeSort])
set(["Slope Sort",slopeSort])
set(["Shell Sort",shellSort])
set(["Recursive Shell Sort",recursiveShellSort])
set(["Andrey Astrelin's In-Place Merge Sort",andreySort])
set(["Block-Swap Merge Sort",blockSwapMergeSort])
set(["In-Place Merge Sort",inPlaceMergeSort])
set(["Rotate Merge Sort",rotateMergeSort])
set(["Strand Sort",strandSort])
set(["Weaved Merge Sort",weavedMergeSort])
set(["Pancake Sort",pancakeSort])
set(["Max Heap Sort",maxHeapSort])
set(["Min Heap Sort",minHeapSort])
set(["Cycle Sort",cycleSort])
set(["Fun Sort",funSort])
set(["Asteraceae Sort",asteraceaeSort])
set(["Awkward Sort",awkwardSort])
set(["Chinotto Sort",chinottoSort])
set(["Circle Merge Sort",circleMergeSort])
set(["Clamber Sort",clamberSort])
set(["Cocktail Grate Sort",cocktailGrateSort])
set(["Cocktail Push Sort",cocktailPushSort])
set(["Dandelion Sort",dandelionSort])
set(["Float Sort",floatSort])
set(["Iterative Quick Sort",iterativeQuickSort])
set(["Index Quick Sort",indexQuickSort])
set(["Pseudo Heap Sort",pseudoHeapSort])
set(["Iterative Circle Sort",iterativeCircleSort])
set(["Recursive Circle Sort",recursiveCircleSort])
set(["Left/Left Quick Sort (Middle Pivot)",LLQuickSortMiddlePivotSort])
set(["Push Sort",pushSort])
set(["Reflection Sort",reflectionSort])
set(["Split Center Sort",splitCenterSort])
set(["Wiggle Sort",wiggleSort])
set(["Zipper Sort",zipperSort])
set(["Pairwise Circle Sort",pairwiseCircleSort])
set(["Iterative Sinking Merge Sort",iterativeSinkingMergeSort])
set(["Recursive Sinking Merge Sort",recursiveSinkingMergeSort])
set(["Cocktail Shell Sort",cocktailShellSort])
set(["Index Merge Sort",indexMergeSort])
set(["Mob Merge Sort",mobMergeSort])
set(["Modulo Merge Sort",moduloMergeSort])
set(["Split-16 Merge Sort",split16MergeSort])
set(["Cube Root Quick Sort",cbrtQuickSort])
set(["Apollyon Sort",apollyonSort])
set(["Optimized Pancake Sort",optimizedPancakeSort])
set(["Magnetica Quick Sort",magneticaQuickSort])
set(["Cocktail Peel Sort",cocktailPeelSort])
set(["Ecolo Sort",ecoloSort])
set(["Fall Sort",fallSort])
set(["Heavy Heap Sort",heavyHeapSort])
set(["Sandpaper Sort",sandPaperSort])
set(["Recursive Burning Sort",recursiveBurningSort])
set(["Corrupt Sort",corruptSort])
set(["Circle Halver Sort",circleHalverSort])
set(["Iterative Pairwise Sort",iterativePairwiseSort])
set(["Iterative [4,4] Van Voorhis Sort",iterativeVanVoorhisSort])
set(["Rotate LSD Radix Sort",rotateLSDRadixSort])
set(["Dig Sort",digSort])
set(["Cityscape Sort",cityscapeSort])
set(["Iterative Cleric Sort",iterativeClericSort])
set(["Recursive Cleric Sort",recursiveClericSort])
set(["Debris Sort",debrisSort])
set(["Californium Sort",californiumSort])
set(["Evub Sort",evubSort])
set(["Iterative Firing Squad Sort",iterativeFiringSquadSort])
set(["Recursive Firing Squad Sort",recursiveFiringSquadSort])
set(["Ford Sort",fordSort])
set(["Future Sort",futureSort])
set(["Iterative Pop Sort",iterativePopSort])
set(["Jump Down Sort",jumpDownSort])
set(["Monolithic Clurge Sort",monolithicClurgeSort])
set(["Pairwise Comb Sort",pairwiseCombSort])
set(["Pancake Quick Sort",pancakeQuickSort])
set(["Pop Pop Sort",popPopSort])
set(["Swapless Push Sort",swaplessPushSort])
set(["Rebound Sort",reboundSort])
set(["Rubble Sort",rubbleSort])
set(["Search Sort",searchSort])
set(["Selection Sort",selectionSort])
set(["Iterative Shircle Sort",iterativeShircleSort])
set(["Recursive Shircle Sort",recursiveShircleSort])
set(["Merry-Go-Round Sort",merryGoRoundSort])
set(["X Pattern Sort",XSort])
set(["Block Shell Sort",blockShellSort])
set(["test Sort",testSort])
//set(["test Sort",testSort])
sn.sort((a,b)=>a[0].localeCompare(b[0]))
const inputs=[
	"Random",
	"Reversed",
	"Half-Reversed",
	"Slightly Scrambled",
	"Scrambled Tail",
	"Scrambled Head",
	"Final Merge",
	"Reversed Array Final Merge",
	"Pipe Organ",
	"Reversed Evens",
	"Many Similar",
	"Almost Sorted",
	"Heapified Input",
	"Final Radix Pass",
	"Sorted",
]
let req=get("test")
s(req,13)
function hold(e){
	e.addEventListener("touchstart",v=>e.style.opacity=.5);
	e.addEventListener("touchend",v=>e.style.opacity=1);
	e.addEventListener("mousedown",v=>e.style.opacity=.5);
	e.addEventListener("mouseup",v=>e.style.opacity=1);
	e.addEventListener("mouseout",v=>e.style.opacity=1);
}
function appendTo(parent,text,func){
	let a=document.createElement("div");
	a.className="selectbtn";
	a.textContent=text;
	hold(a)
	a.onclick=function(){
		queue=get(text)
		nextsort.innerText="Next: "+text;
	}
	parent.appendChild(a)
}
sn.forEach(e=>{
	let name=e[0].toLowerCase();
	appendTo(sortsholder,e[0]);
	if(name.match("merge"))appendTo(mergesortsholder,e[0]);
	if(name.match("quick"))appendTo(quicksortsholder,e[0]);
	if(name.match("recur"))appendTo(recursortsholder,e[0]);
	if(name.match("itera"))appendTo(itersortsholder,e[0]);
	if(name.match("cocktail"))appendTo(cocktailsortsholder,e[0]);
})
Array.from(document.querySelectorAll("div.topicname")).map((e,i)=>{
	let ch=document.querySelectorAll("div.btnholder")[i]
	e.onclick=function(){
		let h=parseFloat(window.getComputedStyle(ch).getPropertyValue("height"))==300
		ch.style.height=(h?0:300)+"px";
		ch.style.opacity=h?0:1;
		ch.style.padding=(h?0:3)+"px 0px";
		document.querySelectorAll("div.space")[i].style.display=h?"none":"block";
	}
})
		</script>
	</body>
</html>