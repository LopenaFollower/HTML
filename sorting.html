<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport"content="width=device-width,initial-scale=1">
		<style>
			body{
				overflow-y:scroll;
				padding:0;
				margin:0 auto;
				zoom:.6;
				user-select:none;
			}
			div.holder{display:flex}
			#cvs{
				background:#000;
				aspect-ratio:auto;
			}
			td.lfa{text-align:right}
			td,#names,.topicname,#nextsort{
				font-family:monospace;
				color:#fff;
			}
			td{
				white-space:nowrap;
				overflow:none;
				text-overflow:clip;
			}
			legend{
				color:#fff;
				font:5px;
			}
			fieldset{width:fit-content}
			div.btnholder{
				transition-timing-function:linear;
				transition-duration:.2s;
				border-radius:4px;
				background:#1d2a35;
				border:3px black solid;
				height:0px;
				opacity:0;
				margin:0 5;
				overflow:scroll;
				width:fit-content;
			}
			div.selectbtn{
				color:#fff;
				background:#04aa6d;
				border-radius:10px;
				padding:3px;
				margin:3px;
				border:1px black solid;
			}
			div.topicname{
				margin:5px;
				border:2px dashed grey;
				padding:2px;
				text-align:center;
			}
			div.space{display:none;}
		</style>
	</head>
	<body bgcolor=#0e151a>
		<br>
		<span id=names></span>
		<div class=holder>
			<fieldset>
				<legend>Options</legend>
				<table>
					<tr>
						<td id=m0>bar</td>
						<td><input type=checkbox oninput='m0.innerText=dtype.checked?"bar":"pixel"'id=dtype checked/></td>
					</tr>
					<tr>
						<td>loop</td>
						<td><input type=checkbox id=loopsort /></td>
					</tr>
					<tr>
						<td>mark</td>
						<td><input type=checkbox id=markarray checked/></td>
					</tr>
					<tr>
						<td>pause</td>
						<td><input type=checkbox id=pause /></td>
					</tr>
					<tr>
						<td>zoom (25-200)</td>
						<td><input style='width:40px'value=60 type=number oninput='if(this["value"]>=25&&this["value"]<=200)document.body.style.zoom=this["value"]/100'/></td>
					</tr>
					<tr>
						<td>skip</td>
						<td><button style='width:40px'onclick='canskip&&arr.sort((a,b)=>a-b)&&(didskip=true)'>btn</button></td>
					</tr>
				</table>
			</fieldset>
			<fieldset>
				<legend>Info</legend>
				<table>
					<tr>
						<td>Elements</td>
						<td class=lfa id=elementcount></td>
					</tr>
					<tr>
						<td>FPS</td>
						<td class=lfa id=fpsdisplay>60</td>
					</tr>
					<tr>
						<td>Swaps</td>
						<td class=lfa id=swapdisplay>0</td>
					</tr>
					<tr>
						<td>Writes</td>
						<td class=lfa id=writedisplay>0</td>
					</tr>
					<tr>
						<td>Input</td>
						<td id=inputdisplay></td>
					</tr>
				</table>
			</fieldset>
			<fieldset>
				<legend>Debug</legend>
				<table>
					<tr>
						<td>Frame</td>
						<td class=lfa id=framecount></td>
					</tr>
					<tr>
						<td>Rate</td>
						<td class=lfa id=framerate></td>
					</tr>
					<tr>
						<td>Sorted</td>
						<td class=lfa id=finalresult></td>
					</tr>
					<tr>
						<td>Duration</td>
						<td class=lfa id=duration></td>
					</tr>
					<tr>
						<td>Estim Finish</td>
						<td class=lfa id=estimated></td>
					</tr>
					<tr>
						<td>Rate</td>
						<td class=lfa><input type=number value=1 id=rate style='width:60px'oninput='if(this["value"]>0&&this["value"]<=1000)atr=this["value"]'/></td>
					</tr>
				</table>
			</fieldset>
		</div>
		<div class=holder>
			<div>
				<canvas id=cvs></canvas>
				<div id=nextsort>Next: ...</div>
			</div>
			<div>
				<div class=topicname>Sorts<div class=space>&nbsp;</div><div class=holder><div id=sortsholder class=btnholder></div></div></div>
				<div class=topicname>Merge<div class=space>&nbsp;</div><div class=holder><div id=mergesortsholder class=btnholder></div></div></div>
				<div class=topicname>Quick<div class=space>&nbsp;</div><div class=holder><div id=quicksortsholder class=btnholder></div></div></div>
				<div class=topicname>Cocktail<div class=space>&nbsp;</div><div class=holder><div id=cocktailsortsholder class=btnholder></div></div></div>
				<div class=topicname>Recursive<div class=space>&nbsp;</div><div class=holder><div id=recursortsholder class=btnholder></div></div></div>
				<div class=topicname>Iterative<div class=space>&nbsp;</div><div class=holder><div id=itersortsholder class=btnholder></div></div></div>
			</div>
		</div>
		<br>
		<script>
window.onresize=resize;window.onblur=function(){pause.checked=true};window.onfocus=function(){pause.checked=false}
const ctx=cvs.getContext("2d"),count=512,len=count,{random,ceil,floor,round,sqrt,cbrt,log,abs,pow,clz32}=Math,math=Math;
let swaps=0,writes=0,queue,atr,curDur=Date.now(),dcd=false,cancel=0,bw=(maxVal(window.innerWidth,window.innerHeight)/minVal(window.innerWidth,window.innerHeight)).toFixed(2),arr,canskip=1,didskip=0;
const logs=[],sn=[];
function resize(){bw=(maxVal(window.innerWidth,window.innerHeight)/minVal(window.innerWidth,window.innerHeight)).toFixed(2);let horizontal=maxVal(window.innerWidth,window.innerHeight),vertical=minVal(window.innerWidth,window.innerHeight);Array.from(document.querySelectorAll("td,legend")).map(e=>e.style.fontSize=horizontal/50+"px");names.style.fontSize=horizontal/50+"px";cvs.width=count*bw;cvs.height=count;cvs.style.width=horizontal*.75+"px";cvs.style.height=vertical*.75+"px";elementcount.innerText=count;}
resize()
const fps=(()=>{
	let elapsed=Date.now(),el2=Date.now(),frame=0,fps=60;
	let update=()=>{
		let rate=1;
		if(Date.now()-elapsed<=1e3/rate)frame+=rate
		else{
			elapsed=Date.now()
			fps=frame
			if(fps<30)markarray.checked=0;
			if(fps>=55)markarray.checked=1;
			fpsdisplay.innerText=frame
			frame=0
		}
		if(Date.now()-el2>=1e3/16){
			el2=Date.now()
			swapdisplay.innerText=swaps.toLocaleString()
			writedisplay.innerText=writes.toLocaleString()
			dcd&&(duration.innerText=((Date.now()-curDur)/1000).toFixed(1)+"s");
		}
		requestAnimationFrame(update)
	}
	requestAnimationFrame(update)
	return{g:()=>fps}
})();
const isSorted=a=>a.every((e,i)=>!i||a[i-1]<=e);
const rangeSorted=(a,s,e)=>a.every((v,i)=>!i||a[i-1]<=v||i>=e);
function display(a){
	ctx.clearRect(0,0,cvs.width,cvs.height)
	ctx.fillStyle="#fff";
	for(let i=0;i<len;i++)ctx.fillRect(i*bw,count-a[i],bw,dtype.checked?a[i]:bw)
}
function mark(i,after){
	if(fps.g()>=30&&markarray.checked){
		ctx.fillStyle="#f00";
		ctx.fillRect(i*bw,count-arr[i],bw,dtype.checked?arr[i]:bw)
	}
	if(after)ctx.fillStyle=after;
}
function format(e){
	if(typeof e!="object"&&parseFloat(e)+""!=="NaN")
		return parseFloat(e);
	else return e
}
const joinSymbol="@";
function rdisp(args){
	if(args.length==3){var[interval,m,onfinish]=args,refresh=24
	}else if(args.length==4){var[interval,m,refresh,onfinish]=args}else return;
	let elapsed=Date.now();
	let updts=0,avrge=0,ticks=0,frames=0,clen=logs.length,tr=maxVal(len*.001,clen*.0005)|0,tmp=[...arr],orlen=clen
	if(interval<0){tr=len*abs(interval)|0;interval=10}
	logs.forEach(e=>{
		let c=e.map(format)
		switch(c[0]){
			case"swap":swap(tmp,c[1],c[2]);break;
			case"set":tmp[c[1]]=c[2];break;
			case"multiSwap":multiSwap(tmp,c[1],c[2],0);break;
			case"reversal":reversal(tmp,c[1],c[2],0);break;
			case"insert":insertTo(tmp,c[1],c[2],0);break;
			case"custom":eval(atob(c[1]))(tmp,...c.splice(2,1/0));break;
		}
	})
	atr=rate.value
	finalresult.innerText=isSorted(tmp);finalresult.style.color=isSorted(tmp)?"#fff":"#f00";
	swaps=0;writes=0;dcd=true;curDur=Date.now();
	(tmp.splice(0,1/0))
	markarray.checked=1;
	let n=setInterval(()=>{
		if(pause.checked)return;
		if(Date.now()-elapsed>1e3/refresh){
			elapsed=Date.now()
			display(arr)
			perms=0
			framecount.innerText=(orlen-clen).toLocaleString()+" / "+orlen.toLocaleString();
			framerate.innerText=frames+"/s"
			if(ticks++%5==0)
				estimated.innerText=(avrge/updts-3.5).toFixed(1)+"s";
		}
		for(let rate=0;rate<=atr;rate++){
			updts++;frames++
			setTimeout(()=>frames--,1e3)
			avrge+=orlen/frames
			if(clen--&&!didskip){
				let c=logs.shift().map(format)
				switch(c[0]){
					case"swap":swap(arr,c[1],c[2],1);break;
					case"set":write(arr,c[1],c[2]);mark(c[1]);break;
					case"multiSwap":multiSwap(arr,c[1],c[2],0);break;
					case"reversal":reversal(arr,c[1],c[2],0);break;
					case"insert":insertTo(arr,c[1],c[2],0);break;
					case"custom":eval(atob(c[1]))(arr,...c.splice(2,1/0));break;
				}
			}else{
				clearArr(logs)
				arr.sort((a,b)=>a-b);
				clearInterval(n)
				onfinish()
				dcd=false
				setTimeout(()=>{
					finalresult.innerText=framecount.innerText=framerate.innerText="...";
				},5)
				break;
			}
		}
	},interval)
	let ratio=(orlen/count).toFixed(2);
	if(ratio>=75)
		console.log(names.innerText,ratio)
}
function create(c){
	return Array(c).fill().map((e,i)=>++i)
}
/* Sauces: 
* https://github.com/Gaming32/ArrayV/blob/main/src/main/java/io/github/arrayv/sorts/
* https://github.com/Gaming32/ArrayV-Extra-Sorts/blob/main/src/main/java/io/github/arrayv/sorts/
* https://github.com/Gaming32/ArrayV/tree/main/src/main/java/io/github/arrayv/utils
* https://github.com/PCBoyGames/ArrayV-v4.0/tree/ad703423641022a396437e2025405916f2435b13/src/sorts
* https://github.com/PCBoyGames/ArrayV-v4.0/tree/ad703423641022a396437e2025405916f2435b13/src/utils
*/
const Rots={
	swapBlocksBackwards:function(ar,a,b,l,r=1){
		let func=r?rswap:swap;
		for(let i=0;i<l;i++)
			func(ar,a+l-i-1,b+l-i-1);
	},
	blockSwap:function(ar,a,b,l,r=1){
		let func=r?rswap:swap;
		for(let i=0;i<l;i++)
			func(ar,a+i,b+i);
	},
	shiftForwards:function(a,s,l,r=1){
		let func=r?rset:write;
		let t=a[s];
		for(let i=0;i<l;i++)
			func(a,s+i,a[s+i+1]);
		func(a,s+l,t);
	},
	shiftBackwards:function(a,s,l,r=1){
		let func=r?rset:write;
		let t=a[s+l];
		for(let i=l;i>0;i--)
			func(a,s+i,a[s+i-1]);
		func(a,s,t);
	},
	mapIndex:function(i,n,l){
		return(i-n+l)%l;
	},
	swap:function(ar,a,v,r=1){
		let func=r?rset:write;
		let old=ar[a];
		func(ar,a,v);
		return old;
	},
	griesMills:function(a,p,A,B,r=1){
		while(A!=0&&B!=0){
			if(A<=B){
				this.blockSwap(a,p,p+A,A,r);
				p+=A;
				B-=A;
			}else{
				this.blockSwap(a,p+(A-B),p+A,B,r);
				A-=B;
			}
		}
	},
	threeReversal:function(a,p,A,B,r=1){
		reversal(a,p,p+A-1,r);
		reversal(a,p+A,p+A+B-1,r);
		reversal(a,p,p+A+B-1,r);
	},
	holyGriesMills:function(a,p,A,B,r=1){
		while(A>1&&B>1){
			while(A<=B){
				this.blockSwap(a,p,p+A,A,r);
				p+=A;
				B-=A;
			}
			if(A<=1||B<=1)break;
			while(A>B){
				this.swapBlocksBackwards(a,p+A-B,p+A,B,r);
				A-=B;
			}
		}
		if(A==1)
			this.shiftForwards(a,p,B,r);
		else if(B==1)
			this.shiftBackwards(a,p,A,r);
	},
	helium:function(a,p,A,B,r=1){
		while(B>1&&A>1)
			if(B<A){
				this.blockSwap(a,p,p+A,B,r);
				p+=B;
				A-=B;
			}else{
				this.swapBlocksBackwards(a,p,p+B,A,r);
				B-=A;
			}
		if(B==1)this.shiftBackwards(a,p,A,r);
		else if(A==1)this.shiftForwards(a,p,B,r);
	},
	cycleReverse:function(ar,p,A,B,r=1){
		if(A<1||B<1)return;
		let a=p,b=p+A-1,c=p+A,d=p+A+B-1;
		let s;
		let func=r?rset:write;
		let func2=r?rswap:swap;
		while(a<b&&c<d){
			s=ar[b];
			func(ar,b--,ar[a]);
			func(ar,a++,ar[c]);
			func(ar,c++,ar[d]);
			func(ar,d--,s);
		}
		while(a<b){
			s=ar[b];
			func(ar,b--,ar[a]);
			func(ar,a++,ar[d]);
			func(ar,d--,s);
		}
		while(c<d){
			s=ar[c];
			func(ar,c++,ar[d]);
			func(ar,d--,ar[a]);
			func(ar,a++,s);
		}
		if(a<d){
			if(d-a>2)reversal(ar,a,d,r);
			else func2(ar,a,d);
		}
	},
	juggling:function(a,p,A,B,r=1){
		let l=A+B;
		A%=l;
		if(A==0)return;
		let func=r?rswap:swap;
		for(let c=0,i=0,v=a[p+i],s=i;c<l;c++){
			let n=this.mapIndex(i,A,l);
			v=func(a,p+n,v);
			if(n==s){
				s=i=this.mapIndex(i,1,l);
				v=a[p+i];
			}else
				i=n;
		}
	},
	bridge:function(a,p,l,b,r=1){
		if(l<1||b<1)return;
		let pta=p,ptb=p+l,ptc=p+b,ptd=ptb+b;
		let func=r?rset:write;
		if(l<b){
			let bridge=b-l;
			if(bridge<l){
				let loop=l;
				let swap=new Array(bridge);
				arraycopy(a,ptb,swap,0,bridge,r);
				while(loop-->0){
					func(a,--ptc,a[--ptd]);
					func(a,ptd,a[--ptb]);
				}
				arraycopy(swap,0,a,pta,bridge);
			}else{
				let swap=new Array(l);
				arraycopy(a,pta,swap,0,l,r);
				arraycopy(a,ptb,a,pta,b,r);
				arraycopy(swap,0,a,ptc,l);
			}
		}else if(b<l){
			let bridge=l-b;
			if(bridge<b){
				let loop=b;
				let swap=new Array(bridge);
				arraycopy(a,ptc,swap,0,bridge,r);
				while(loop-->0){
					func(a,ptc++,a[pta]);
					func(a,pta++,a[ptb++]);
				}
				arraycopy(swap,0,a,ptd-bridge,bridge);
			}else{
				let swap=new Array(b);
				arraycopy(a,ptb,swap,0,b,r);
				while(l-->0)
					func(a,--ptd,a[--ptb]);
				arraycopy(swap,0,a,pta,b);
			}
		}else
			while(left-->0)
				(r?rswap:swap)(a,pta++,ptb++);
	},
	neon:function(a,p,A,B,r=1){
		let end=p+A+B;
		let func=r?rset:write;
		while(A>0&&B>0){
			if(A<B){
				for(let i=0;i<A;i++){
					let t=a[p+i],j=p+i+A;
					for(;j<end;j+=A)
						func(a,j-A,a[j]);
					func(a,j-A,t);
				}
				p+=B;
				B%=A;
				A-=B;
			}else{
				for(let i=0;i<B;i++){
					let t=a[p+i+A],j=p+i+A-B;
					for(;j>=p;j-=B)
						func(a,j+B,a[j]);
					func(a,j+B,t);
				}
				end=p+B;
				A%=B;
				B-=A;
			}
		}
	},
	foolish:function(a,p,A,B,r=1){
		if(A<B)
			for(let i=0;i<A;i++)
				insertTo(a,p,p+A+B-1,r);
		else
			for(let i=0;i<B;i++)
				insertTo(a,p+A+B-1,p,r);
	},
	morefoolish:function(a,p,A,B,r=1){
		if(A>B)
			for(let i=0;i<A;i++)
				insertTo(a,p,p+A+B-1,r);
		else
			for(let i=0;i<B;i++)
				insertTo(a,p+A+B-1,p,r);
	},
	radon:function(a,p,A,B,r=1){
		let func=r?rswap:swap;
		let min=Math.min(A,B),max=Math.max(A,B),bridge=max-min;
		if(min<1)return;
		if(bridge<=min)reversal(a,p+min,p+max-1);
		for(let i=0;i<min;i++)func(a,p+i,p+max+i);
		if(bridge==0)return;
		if(A>B){
			if(bridge>min)
				this.cycleReverse(a,p+min,bridge,min,r);
			else{
				let swap,a1=p+min,b=p+max,c=b+min-1;
				while(b<c){
					swap=a[c];
					func(a,c--,a[a1]);
					func(a,a1++,a[b]);
					func(a,b++,swap);
				}
				reversal(a,a1,c);
			}
		}else{
			if(bridge>min){
				this.cycleReverse(a,p,min,bridge,r);
			}else{
				let swap,a1=p,b=a+min-1,c=a+max-1;
				while(a<b){
					swap=a[a1];
					func(a,a1++,a[c]);
					func(a,c--,a[b]);
					func(a,b--,swap);
				}
				reversal(a,a1,c);
			}
		}
	},
	centered:function(a,p,A,B,r=1){
		if(A<1||B<1)return;
		if(A<B){
			let h=(B-A)/2|0;
			this.blockSwap(a,p,p+A+h,A,r);
			this.centered(a,p+A+h,A,B-A-h,r);
			this.centered(a,p,A,h,r);
		}else if(A==B){
			this.blockSwap(a,p,p+A,A,r);
		}else{
			let h=(A-B)/2|0;
			this.blockSwap(a,p+h,p+A,B,r);
			this.centered(a,p,h,B,r);
			this.centered(a,p+h+B,A-B-h,B,r);
		}
	},
	adaptable:function(a,p,A,B,r=1){
		if(A==0||B==0)return;
		if(A%B==0||B%A==0)this.holyGriesMills(a,p,A,B,r);
		else this.cycleReverse(a,p,A,B,r);
	}
}
const IndexRots={
	griesMills:function(a,s,m,e){Rots.griesMills(a,s,m-s,e-m)},
	threeReversal:function(a,s,m,e){Rots.threeReversal(a,s,m-s,e-m)},
	juggling:function(a,s,m,e){Rots.juggling(a,s,m-s,e-m)},
	holyGriesMills:function(a,s,m,e){Rots.holyGriesMills(a,s,m-s,e-m)},
	helium:function(a,s,m,e){Rots.helium(a,s,m-s,e-m)},
	cycleReverse:function(a,s,m,e){Rots.cycleReverse(a,s,m-s,e-m)},
	bridge:function(a,s,m,e){Rots.bridge(a,s,m-s,e-m)},
	neon:function(a,s,m,e){Rots.neon(a,s,m-s,e-m)},
	foolish:function(a,s,m,e){Rots.foolish(a,s,m-s,e-m)},
	morefoolish:function(a,s,m,e){Rots.morefoolish(a,s,m-s,e-m)},
	radon:function(a,s,m,e){Rots.radon(a,s,m-s,e-m)},
	centered:function(a,s,m,e){Rots.centered(a,s,m-s,e-m)},
	adaptable:function(a,s,m,e){Rots.adaptable(a,s,m-s,e-m)}
}
function getDigit(a,p,r){
	return(a/pow(r,p))%r|0;
}
function minVal(a){
	if(typeof a=="object"){
		return math.min(...a)
	}else return math.min(...arguments)
}
function maxVal(a){
	if(typeof a=="object"){
		return math.max(...a)
	}else return math.max(...arguments)
}
function maxLog(a,l,b){
	let m=i=0;
	for(;i<l;i++){
		let v=a[i];
		if(v>m)m=v;
	}
	return log(m)/log(b)|0;
}
function compareValues(a,b){
	a|=0;b|=0
	return a==b?0:a>b?1:-1
}
function compareIndices(a,b,c){
	b|=0;c|=0
	return a[b]==a[c]?0:a[b]>a[c]?1:-1
}
function swap(a,f,t,m=0){
	f|=0;t|=0;
	if(m&&markarray.checked){
		mark(f);
		mark(t);
	}
	let o=a[f];
	a[f]=a[t];
	a[t]=o;
	swaps++
	writes+=2
}
function customFunc(f,args){
	logs.push(["custom",btoa("("+f+")"),...args])
}
function rmultiSwap(a,p,t){
	multiSwap(a,p,t,1)
}
function rswap(arr,f,t){
	logs.push(["swap",f,t])
	swap(arr,f,t)
	swaps--
	writes-=2
}
function rset(arr,i,val){
	logs.push(["set",i,val])
	arr[i]=val
}
function insertTo(a,p,t,m=1){
	let tp=a[p];
	switch(m){
		case 0:
			if(t-p>0)
				for(let i=p;i<t;i++)write(a,i,a[i+1]);
			else if(t-p<0)
				for(let i=p;i>t;i--)write(a,i,a[i-1]);
			if(p!=t)rset(a,t,tp);
			break;
		case 1:
			if(t-p>0)
				for(let i=p;i<t;i++)rset(a,i,a[i+1]);
			else if(t-p<0)
				for(let i=p;i>t;i--)rset(a,i,a[i-1]);
			if(p!=t)rset(a,t,tp);
			break;
		case 2:
			logs.push(["insert",p,t])
			insertTo(a,p,t,0)
			break;
	}
}
function multiSwap(a,p,t,r){
	if(r)
		logs.push(["multiSwap",p,t])
	if(t-p>0)
		for(let i=p;i<t;i++)
			swap(a,i,i+1);
	else
		for(let i=p;i>t;i--)
			swap(a,i,i-1);
}
function transcribe(a,g,s,r){
	let t=s;
	for(let i=0;i<g.length;i++)
		for(let j=0;j<g[i].length;j++)
			(r?rset:write)(a,t++,g[i][j]);
}
function reversal(a,s,l,m=1){
	if(l-s<=0)return;
	switch(m){
		case 0:
			for(let i=s;i<s+((l-s+1)/2);i++)
				swap(a,i,s+l-i);
			break;
		case 1:
			for(let i=s;i<s+((l-s+1)/2);i++)
				rswap(a,i,s+l-i);
			break;
		case 2:
			logs.push(["reversal",s,l])
			reversal(a,s,l,0)
			break;
	}
}
function customBinaryInsert(a,s,e,r=1){
	for(let i=s;i<e;i++){
		let num=a[i];
		let lo=s,hi=i;
		while(lo<hi){
			let mid=lo+((hi-lo)/2)|0;
			if(compareValues(num,a[mid])<0)hi=mid;
			else lo=mid+1;
		}
		let j=i-1;
		let change=false;
		let func=r?rset:write
		while(j>=lo){
			func(a,j+1,a[j]);
			j--;
			change=true;
		}
		if(change)func(a,lo,num);
	}
}
function write(a,t,v){
	a[t]=v|0;
	writes++
}
function clearArr(a){
	a.splice(0,1/0)
}
function arraycopy(s,sp,d,dp,l,r){
	let b=s!=d||dp<sp;
	let st=b?0:l-1,
		e=b?l:-1,
		dr=b?1:-1;
	for(let i=st;i!=e;i+=dr)
		if(r)rset(d,dp+i,s[sp+i]);
		else write(d,dp+i,s[sp+i]);
}
function getMax(a,l){
	let m=-1/0;
	for(let i=0;i<l;i++)
		if(a[i]>m)m=a[i];
	return m;
}
function getMaxIndex(a,l){
	let i=-1/0;
	for(let n=0;n<l;++n)
		if(a[n]>a[i])i=n;
	return i;
}
function getMin(a,l){
	let m=1/0;
	for(let i=0;i<l;i++)
		if(a[i]<m)m=a[i];
	return m;
}
const circleDepth=parseFloat("1e-"+(len*.9|0).toString().length)
/*templates*/
function icsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)
		for(let s=0;s+g<len;s+=2*g)
			for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)
				if(h<len&&compareIndices(a,lw,h)>0)
					rswap(a,lw,h,sc++);
	return sc;
}
function rcsr(a,l,h,s){
	if(l==h)return s;
	let hi=h,lo=l,m=(h-l)/2|0;
	for(;l<h;l++,h--)
		if(h<len&&compareIndices(a,l,h)>0)
			rswap(a,l,h,s++);
	s=rcsr(a,lo,lo+m,s);
	if(lo+m+1<len)s=rcsr(a,lo+m+1,hi,s);
	return s;
}
function iclsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)
		for(let s=0;s+g<len;s+=2*g)
			for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)
				if(h<len&&compareIndices(a,lw,h)>0)
					reversal(a,lw,h,1,sc++);
	return sc;
}
function rclsr(a,lo,hi,s){
	if(lo==hi)return s;
	let h=hi,l=lo,m=(hi-lo)/2|0;
	for(;lo<hi;lo++,hi--)
		if(hi<len&&compareIndices(a,lo,hi)>0)
			reversal(a,lo,hi,1,s++);
	s=rclsr(a,l,l+m,s);
	if(l+m+1<len)
		s=rclsr(a,l+m+1,h,s);
	return s;
}
function ishsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)
		for(let s=0;s+g<len;s+=2*g)
			for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)
				if(h<len&&compareIndices(a,lw,h)>0)
					insertTo(a,lw,h,2,sc++);
	return sc;
}
function rshsr(a,lo,hi,s){
	if(lo==hi)return s;
	let h=hi,l=lo,m=(hi-lo)/2|0;
	for(;lo<hi;lo++,hi--)
		if(hi<len&&compareIndices(a,lo,hi)>0)
			insertTo(a,lo,hi,2,s++);
	s=rshsr(a,l,l+m,s);
	if(l+m+1<len)
		s=rshsr(a,l+m+1,h,s);
	return s;
}
function insertSort(a,s,e){
	for(let i=s;i<e;i++){
		let p=i-1,c=a[i];
		while(p>=s&&compareValues(a[p],c)>0)
			rset(a,p+1,a[p--]);
		rset(a,p+1,c);
	}
}
function siftDown(a,r,d,s,m,t){
	let cv=m?-1:1;
	while(r<=d/2){
		let l=2*r;
		if(l<d&&compareIndices(a,s+l-1,s+l)==cv)l++;
		if(compareIndices(a,s+r-1,s+l-1)==cv){
			(!t)?swap(a,s+r-1,s+l-1):rswap(a,s+r-1,s+l-1);
			r=l;
		}else break;
	}
}
function heapify(ar,lw,h,m,t=1){
	let le=h-lw;
	for(let i=le/2;i>=1;i--)
		siftDown(ar,i,le,lw,m,t)
}
function heapSort(a,s,l,mx,r=1){
	heapify(a,s,l,mx,r);
	let func=r?rswap:swap;
	for(let i=l-s;i>1;i--){
		func(a,s,s+i-1);
		siftDown(a,1,i-1,s,mx,r);
	}
	if(!mx)reversal(a,s,s+l-1,r?1:0);
}
function doubleInsert(ar,a,b,r=1){
	let sw=r?rswap:swap;
	let wr=r?rset:write;
	const lbs=(ar,a,b,v)=>{
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<=0)b=m;
			else a=m+1;
		}
		return a;
	}
	const rbs=(ar,a,b,v)=>{
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function itl(ar,a,b,t){
		while(a>b)wr(ar,a,ar[--a]);
		wr(ar,b,t);
	}
	function itr(ar,a,b,t){
		while(a<b)wr(ar,a,ar[++a]);
		wr(ar,a,t);
	}
	function dbi(ar,a,b){
		if(b-a<2)return;
		let j=a+(b-a-2)/2+1|0,i=a+(b-a-1)/2|0;
		if(j>i&&compareIndices(ar,i,j)>0)
			sw(ar,i,j);
		i--;
		j++;
		while(j<b){
			if(compareIndices(ar,i,j)>0){
				let l=ar[j];
				let r=ar[i];
				let m=rbs(ar,i+1,j,l);
				itr(ar,i,m-1,l);
				itl(ar,j,lbs(ar,m,j,r),r);
			}else{
				let l=ar[i];
				let r=ar[j];
				let m=lbs(ar,i+1,j,l);
				itr(ar,i,m-1,l);
				itl(ar,j,rbs(ar,m,j,r),r);
			}
			i--;
			j++;
		}
	}
	dbi(ar,a,b);
}
/*end*/
function iterativeBitonicSort(){
	let array=[...arr];
	let i,j,k;
	for(k=2;k<len*2;k=2*k){
		let m=(((len+(k-1))/k)%2)!=0;
		for(j=k>>1;j>0;j=j>>1)
			for(i=0;i<len;i++){
				let ij=i^j;
				if(ij>i&&ij<len){
					if((((i&k)==0)==m)&&compareIndices(array,i,ij)>0)rswap(array,i,ij);
					if((((i&k)!=0)==m)&&compareIndices(array,i,ij)<0)rswap(array,i,ij);
				}
			}
	}
	return[5,1];
}
function batcherBitonicSort(){
	let array=[...arr];
	const bm=(a,l,n,dir)=>{
		if(n<=1)return;
		let m=1
		while(m<<1<n)m<<=1;
		for(let i=l;i<l+n-m;i++)
			if(dir==(compareIndices(array,i,i+m)==1))
				rswap(a,i,i+m);
		bm(a,l,m,dir);
		bm(a,l+m,n-m,dir);
	}
	const bs=(a,l,n,dir)=>{
		if(n<=1)return;
		let m=n/2;
		bs(a,l,m,!dir);
		bs(a,l+m,n-m,dir);
		bm(a,l,n,dir);
	}
	bs(array,0,len,1)
	return[5,1];
}
function iterativeBoseNelsonSort(){
	let array=[...arr];
	let clen=1<<ceil(log(len)/log(2));
	for(let a=2;a<=clen;a*=2){
		for(let b=0;b<a/2;b++){
			for(let c=0;c+b<len;c+=a){
				let g=c
				let half=(c+a-g)/2,m=g+half;
				g+=b;
				for(let d=0;d<half-b;d++){
					if((d&~b)==d){
						let e=g+d,f=m+d
						if(f<len&&compareIndices(array,e,f)==1)
							rswap(array,e,f);
					}
				}
			}
		}
	}
	return[5,1]
}
function recursiveBoseNelsonSort(){
	let array=[...arr];
	const cs=(a,s,e)=>{
		if(compareIndices(a,s,e)==1)
			rswap(a,s,e);
	}
	const bn=(a,s,l)=>{
		if(l<=1)return;
		let m=l/2|0;
		bn(a,s,m);
		bn(a,s+m,l-m);
		bnm(a,s,m,s+m,l-m);
	}
	
	const bnm=(a,s1,l1,s2,l2)=>{
		if(l1==1&&l2==1){
			cs(a,s1,s2);
		}else if(l1==1&&l2==2){
			cs(a,s1,s2+1);
			cs(a,s1,s2);
		}else if(l1==2&&l2==1){
			cs(a,s1,s2);
			cs(a,s1+1,s2);
		}else{
			let m1=l1/2|0;
			let m2=(l1%2==1?l2/2:(l2+1)/2)|0;
			bnm(a,s1,m1,s2,m2);
			bnm(a,s1+m1,l1-m1,s2+m2,l2-m2);
			bnm(a,s1+m1,l1-m1,s2,m2);
		}
	}
	bn(array,0,len);
	return[5,1]
}
function creaseSort(){
	let array=[...arr];
	let max=1;
	for(;max*2<len;max*=2);
	let next=max;
	while(next>0){
		for(let i=0;i+1<len;i+=2)
			if(compareIndices(array,i,i+1)==1)
				rswap(array,i,i+1);
		for(let j=max;j>=next&&j>1;j/=2)
			for(let i=1;i+j-1<len;i+=2)
				if(compareIndices(array,i,i+j-1)==1)
					rswap(array,i,i+j-1);
		next/=2;
	}
	return[5,1]
}
function iterativeDiamondSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	let m=4;
	for(;m<=n;m*=2){
		for(let k=0;k<m/2;k++){
			let cnt=k<=m/4?k:m/2-k;
			for(let j=0;j<len;j+=m)
				if(j+cnt+1<len)
					for(let i=j+cnt;i+1<minVal(len,j+m-cnt);i+=2)
						if(compareIndices(array,i,i+1)==1)
							rswap(array,i,i+1);
		}
	}
	m/=2;
	for(let k=0;k<=m/2;k++)
		for(let i=k;i+1<minVal(len,m-k);i+=2)
			if(compareIndices(array,i,i+1)==1)
				rswap(array,i,i+1);
	return[0,0]
}
function recursiveDiamondSort(){
	let array=[...arr];
	const sort=(array,start,stop,merge)=>{
		if(stop-start==2){
			if(compareIndices(array,start,stop-1)==1)
				rswap(array,start,stop-1);
		}else if(stop-start>=3){
			let div=(stop-start)/4;
			let mid=(stop-start)/2+start;
			if(merge){
				sort(array,start,mid,1);
				sort(array,mid,stop,1);
			}
			sort(array,div+start|0,div*3+start|0,0);
			sort(array,start,mid,0);
			sort(array,mid,stop,0);
			sort(array,div+start|0,div*3+start|0,0);
		}
	}
	sort(array,0,len,true);
	return[5,1]
}
function foldSort(){
	let array=[...arr];
	let ceilLog=1;
	for(;1<<ceilLog<len;ceilLog++);
	let size=1<<ceilLog;
	for(let k=size>>1;k>0;k>>=1){
		for(let i=size;i>=k;i>>=1){
			for(let j=0;j<len;j+=i){
				let low=j-1,high=j+i
				while(++low<--high)
					if(high<len&&compareIndices(array,low,high)==1)
						rswap(array,low,high);
			}
		}
	}
	return[5,1]
}
function batcherMergeExchangeSort(){
	let array=[...arr];
	let t=log(len-1)/log(2)+1|0;
	let p0=1<<(t-1);
	for(let p=p0;p>0;p>>=1){
		let q=p0;
		let r=0;
		let d=p;
		while(1){
			for(let i=0;i<len-d;i++)
				if((i&p)==r&&compareIndices(array,i,i+d)==1)
					rswap(array,i,i+d);
			if(q==p)break;
			d=q-p;
			q>>=1;
			r=p;
		}
	}
	return[5,1]
}
function recursiveOddEvenMergeSort(){
	let array=[...arr];
	const oemc=(a,i,j)=>{
		if(compareIndices(a,i,j)>0)
			rswap(a,i,j);
	}
	const oem=(a,lo,m2,n,r)=>{
		let m=r*2;
		if(m<n){
			if((n/r|0)%2!=0){
				oem(a,lo,(m2+1)/2,n+r,m);
				oem(a,lo+r,m2/2,n-r,m);
			}else{
				oem(a,lo,(m2+1)/2,n,m);
				oem(a,lo+r,m2/2,n,m);
			}
			if(m2%2|0!=0){
				for(let i=lo;i+r<lo+n;i+=m)
					oemc(a,i,i+r);
			}else
				for(let i=lo+r;i+r<lo+n;i+=m)
					oemc(a,i,i+r);
		}else
			if(n>r)
				oemc(a,lo,lo+r);
	}
	const oems=(a,lo,n)=>{
		if(n>1){
			let m=n/2;
			oems(a,lo,m);
			oems(a,lo+m,n-m);
			oem(a,lo,m,n,1);
		}
	}
	oems(array,0,len);
	return[5,1]
}
function iterativePairwiseMergeSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n<<=1);
	for(let k=n>>1;k>0;k>>=1)
		for(let j=0;j<len;j+=k<<1)
			for(let i=0;i<k;i++)
				if(j+k+i<len&&compareIndices(array,j+i,j+k+i)==1)
					rswap(array,j+i,j+k+i);
	for(let k=2;k<n;k<<=1)
		for(let m=k>>1;m>0;m>>=1)
			for(let j=0;j<len;j+=k<<1)
				for(let p=m;p<((k-m)<<1);p+=m<<1)
					for(let i=0;i<m;i++)
						if(j+p+m+i<len&&compareIndices(array,j+p+i,j+p+m+i)==1)
							rswap(array,j+p+i,j+p+m+i);
	return[5,1]
}
function recursivePairwiseMergeSort(){
	let array=[...arr];
	const pm=(array,a,b)=>{
		let m=(a+b)/2,m1=(a+m)/2,g=m-m1;
		for(let i=0;m1+i<m;i++)
			for(let j=m1,k=g;k>0;k>>=1,j-=k-(i&k))
				if(j+i+k<len&&compareIndices(array,j+i,j+i+k)==1)
					rswap(array,j+i+k,j+i);
		if(b-a>4)pm(array,m,b);
	}
	const pms=(array,a,b)=>{
		let m=(a+b)/2;
		for(let i=a,j=m;i<m;i++,j++)
			if(j<len&&compareIndices(array,i,j)==1)
				rswap(array,i,j);
		if(b-a>2){
			pms(array,a,m);
			pms(array,m,b);
			pm(array,a,b);
		}
	}
	let n=1;
	for(;n<len;n<<=1);
	pms(array,0,n);
	return[5,1]
}
function iterativeWeaveSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	for(let i=1;i<n;i*=2)
		for(let j=1;j<=i;j*=2)
			for(let k=0;k<n;k+=n/j)
				for(let d=n/i/2,m=0,l=n/j-d;l>=n/j/2;l-=d)
					for(let p=0;p<d;p++,m++)
						if(k+l+p<len&&compareIndices(array,k+m,k+l+p)==1)
							rswap(array,k+m,k+l+p);
	return[5,1]
}
function recursiveWeaveSort(){
	let array=[...arr];
	const cr=(array,pos,length,gap)=>{
		if(length<2)return;
		for(let i=0;2*i<(length-1)*gap;i+=gap)
			if(pos+(length-1)*gap-i<len&&compareIndices(array,pos+i,pos+(length-1)*gap-i)==1)
				rswap(array,pos+i,pos+(length-1)*gap-i);
		cr(array,pos,length/2,gap);
		if(pos+length*gap/2<len)cr(array,pos+length*gap/2,length/2,gap);
	}
	const wc=(array,pos,length,gap)=>{
		if(length<2)return;
		wc(array,pos,length/2,2*gap);
		wc(array,pos+gap,length/2,2*gap);
		cr(array,pos,length,gap);
	}
	let n=1;
	for(;n<len;n*=2);
	wc(array,0,n,1);
	return[5,1]
}
function LSDRadixSort(){
	let array=[...arr];
	let base=10
	let c=2,
		min=minVal(array),
		max=maxVal(array),
		exp=1;
	while((max-min)/exp>=1){
		let n,b=new Array(base).fill(0),output=new Array(len);
		for(n=0;n<len;n++)b[((array[n]-min)/exp)%base|0]++;
		for(n=1;n<base;n++)b[n]+=b[n-1];
		for(n=len-1;n>=0;n--)output[--b[((array[n]-min)/exp)%base|0]]=array[n];
		for(n=0;n<len;n++)rset(array,n,output[n]);
		exp*=10;
	}
	return[0,1]
}
function indexSort(){
	let array=[...arr];
	let min=minVal(array)
	for(let i=0;i<len;i++){
		let cmpCount=0;
		while(compareValues(i,array[i]-min)!=0&&cmpCount<len)
			rswap(array,i,array[i]-min,cmpCount++);
		if(cmpCount>=len-1)break;
	}
	return[5,1]
}
function bubbleSort(){
	let array=[...arr];
	function cf(ar,i){
		let s=1
		for(let j=0;j<i;j++)
			if(compareIndices(ar,j,j+1)==1){
				swap(ar,j,j+1,1);
				s=0;
			}
		return s;
	}
	for(let i=len-1;i>0;i--){
		customFunc(cf,[i])
		if(cf(array,i))break;
	}
	return[10,1]
}
function circloidSort(){
	let array=[...arr];
	const c=(a,l,r)=>{
		let s=0;
		while(l<r){
			if(compareIndices(a,l,r)==1){
				rswap(a,l,r);
				s=1;
			}
			l++;
			r--;
			if(l==r)r++;
		}
		return s;
	}
	const cp=(a,l,r)=>{
		if(l>=r)return false;
		let mid=(l+r)/2|0;
		let lf=cp(a,l,mid);
		let rt=cp(a,mid+1,r);
		return c(a,l,r)||lf||rt;
	}
	while(cp(array,0,len-1));
	return[5,1]
}
function combSort(){
	let array=[...arr];
	for(let i=0;!isSorted(array);i++,i%=len){
		let n=len;
		let d=1;
		while(n!=1||d){
			n=(n*10)/13|0
			if(n<1)n=1;
			d=0;
			if(i>n-len&&compareIndices(array,i,i+n)==1){
				rswap(array,i,i+n)
				d=1
			}
		}
		
	}
	return[5,1]
}
function completeGraphSort(){
	let array=[...arr];
	const cs=(array,a,b)=>{
		if(compareIndices(array,a,b)>0)
			rswap(array,a,b);
	}
	const split=(array,a,m,b)=>{
		if(b-a<2)return;
		let c=0,len1=(b-a)/2;
		let odd=(b-a)%2==1;
		if(odd){
			if(m-a>b-m)c=a++;
			else c=--b;
		}
		for(let s=0;s<len1;s++){
			let i=a;
			for(let j=s;j<len1;j++)
				cs(array,i++,m+j);
			for(let j=0;j<s;j++)
				cs(array,i++,m+j);
		}
		if(odd){
			if(c<m)
				for(let j=0;j<len1;j++)
					cs(array,c,m+j);
			else
				for(let j=0; j<len1;j++)
					cs(array,a+j,c);
		}
	}
	let n=len;
	let d=2,end=1<<(log(n-1)/log(2)|0+1);
	while(d<=end){
		let i=0,dec=0;
		while(i<n){
			let j=i;
			dec+=n;
			while(dec>=d){
				dec-=d;
				j++;
			}
			let k=j;
			dec+=n;
			while(dec>=d){
				dec-=d;
				k++;
			}
			split(array,i,j,k);
			i=k;
		}
		d*=2;
	}
	return[5,1]
}
function funSort(){
	let array=[...arr];
	function bs(array,start,end,value){
		while(start<end){
			let mid=(start+end)>>>1;
			if(compareValues(array[mid],value)<0)start=mid+1;
			else end=mid;
		}
		return start;
	}
	for(let i=1;i<len;i++){
		let done=false;
		do{
			done=true;
			let pos=bs(array,0,len-1,array[i]);
			if(compareIndices(array,pos,i)!=0){
				if(i<pos-1)
					rswap(array,i,pos-1);
				else if(i>pos)
					rswap(array,i,pos);
				done=false;
			}
		}while(!done);
	}
	return[-.05,1]
}
function cocktailShakerSort(){
	let array=[...arr];
	let i=0;
	while(i<len/2){
		let s=true;
		for(let j=i;j<len-i-1;j++){
			if(compareIndices(array,j,j+1)==1){
				rswap(array,j,j+1);
				s=false;
			}
		}
		for(let j=len-i-1;j>i;j--){
			if(compareIndices(array,j,j-1)==-1){
				rswap(array,j,j-1);
				s=false;
			}	
		}
		if(s)break;
		else i++;
	}
	return[-.05,1]
}
function gnomeSort(){
	let array=[...arr];
	for(let i=1;i<len;){
		if(compareIndices(array,i,i-1)>=0)i++;
		else{
			rswap(array,i,i-1);
			if(i>1)i--;
		}
	}
	return[5,1]
}
function LLQuickSort(){
	let array=[...arr];
	function partition(array,lo,hi){
		let pivot=array[hi];
		let i=lo;
		for(let j=lo;j<hi;j++)
			if(compareValues(array[j],pivot)<0)
				rswap(array,i++,j);
		rswap(array,i,hi);
		return i;
	}	
	function quickSort(array,lo,hi){
		if(lo<hi){
			let p=partition(array,lo,hi);
			quickSort(array,lo,p-1);
			quickSort(array,p+1,hi);
		}
	}
	quickSort(array,0,len-1)
	return[5,1]
}
function LRQuickSort(){
	let array=[...arr];
	function quickSort(a,p,r){
		let pivot=p+(r-p+1)/2|0;
		let x=a[pivot];
		let i=p;
		let j=r;
		while(i<=j){
			while(compareValues(a[i],x)==-1)i++;
			while(compareValues(a[j],x)==1)j--;
			if(i<=j)rswap(a,i++,j--);
		}
		if(p<j)quickSort(a,p,j);
		if(i<r)quickSort(a,i,r);
	}
	quickSort(array,0,len-1);
	return[5,1]
}
function oddEvenSort(){
	let array=[...arr];
	while(!isSorted(array)){
		for(let n=0;n<=len-2;n+=2)
			if(compareIndices(array,n,n+1)==1)
				rswap(array,n,n+1);
		for(let n=1;n<=len-2;n+=2)
			if(compareIndices(array,n,n+1)==1)
				rswap(array,n,n+1);
	}
	return[-.05,1]
}
function stoogeSort(){
	let array=[...arr];
	const ss=(a,i,j)=>{
		if(compareIndices(a,i,j)==1)
			rswap(a,i,j);
		if(j-i+1>=3){
			let t=(j-i+1)/3|0;
			ss(a,i,j-t);
			ss(a,i+t,j);
			ss(a,i,j-t);
		}
	}
	ss(array,0,len-1)
	return[4,1]
}
function slopeSort(){
	let array=[...arr];
	for(let i=1,j=1;i<len;i=j,j++)
		for(let k=i-1;k>=0;k--,i--)
			if(compareIndices(array,i,k)<0)
				rswap(array,i,k);
	return[5,1]
}
function shellSort(){
	let array=[...arr];
	for(let i=0;!isSorted(array);i++,i%=len){
		for(let n=len/2|0;n>0;n=n/2|0){
			let j,o=array[i];
			for(j=i;j>=n&&compareValues(array[j-n],o)==1;j-=n)
				rswap(array,j,j-n,1);
			rset(array,j,o);
		}
	}
	return[-.1,1]
}
function recursiveShellSort(){
	let array=[...arr];
	function gis(a,b,c,g){
		for(let i=b+g;i<c;i+=g){
			let k=a[i]
			let j=i-g;
			while(j>=b&&compareValues(k,a[j])<0){
				rset(a,j+g,a[j]);
				j-=g;
			}
			rset(a,j+g,k);
		}
	}
	function rss(a,s,e,g){
		if(s+g<=e){
			rss(a,s,e,3*g);
			rss(a,s+g,e,3*g);
			rss(a,s+2*g,e,3*g);
			gis(a,s,e,g);
		}
	}
	rss(array,0,len,1);
	return[5,1]
}
function andreySort(){
	let array=[...arr];
	function sort(a,b,c){
		while(c>1){
			let k=0;
			for(let i=1;i<c;i++)
				if(compareIndices(a,b+k,b+i)>0)
					k=i;
			rswap(a,b,b+k);
			b++;c--;
		}
	}
	function aswap(a,a1,a2,l){
		while(l-->0)rswap(a,a1++,a2++);
	}
	function backmerge(a,a1,l1,a2,l2){
		let a0=a2+l1;
		for(;;){
			if(compareIndices(a,a1,a2)>0){
				rswap(a,a1--,a0--);
				if(--l1==0)return 0;
			}else{
				rswap(a,a2--,a0--);
				if(--l2==0)break;
			}
		}
		let res=l1;
		do rswap(a,a1--,a0--);while(--l1!=0);
		return res;
	}
	function rmerge(array,a,l,r){
		for(let i=0;i<l;i+=r){
			let q=i;
			for(let j=i+r;j<l;j+=r)
				if(compareIndices(array,a+q,a+j)>0)
					q=j;
			if(q!=i)
				aswap(array,a+i,a+q,r);
			if(i!=0){
				aswap(array,a+l,a+i,r);
				backmerge(array,a+(l+r-1),r,a+(i-1),r);
			}
		}
	}
	function rbnd(l){
		l/=2;
		let k=0;
		for(let i=1;i<l|0;i*=2)
			k++;
		l/=k;
		for(k=1;k<=l|0;k*=2);
		return k;
	}
	function msort(array,a,l){
		if(l<12){
			sort(array,a,l);
			return;
		}
		let r=rbnd(l);
		let lr=(l/r-1)*r;
		for(let p=2;p<=lr;p+=2){
			if(compareIndices(array,a+(p-2),a+(p-1))>0)
				rswap(array,a+(p-2),a+(p-1));
			if((p&2)!=0)continue;
			aswap(array,a+(p-2),a+p,2);
			let m=l-p;
			let q=2;
			for(;;){
				let q0=q*2;
				if(q0>m||(p&q0)!=0)break;
				backmerge(array,a+(p-q-1),q,a+(p+q-1),q);
				q=q0;
			}
			backmerge(array,a+(p+q-1),q,a+(p-q-1),q);
			let q1=q;
			q*=2;
			while((q&p)==0){
				q*=2;
				rmerge(array,a+(p-q),q,q1);
			}
		}
		let q1=0;
		for(let q=r;q<lr;q*=2){
			if((lr&q)!=0){
				q1+=q;
				if(q1!=q)
					rmerge(array,a+(lr-q1),q1,r);
			}
		}
		let s=l-lr;
		msort(array,a+lr,s);
		aswap(array,a,a+lr,s);
		s+=backmerge(array,a+s-1,s,a+lr-1,lr-s)
		msort(array,a,s);
	}
	msort(array,0,len);
	let n=1;
	for(;n*2<=len;n*=2);
	insertSort(array,0,n*.23|0);
	return[5,1]
}
function blockSwapMergeSort(){
	let array=[...arr];
	const bin=(ar,s,md,e)=>{
		let a=0,
			b=minVal(md-s,e-md),
			m=a+(b-a)/2|0;
		while(b>a){
			if(compareIndices(ar,md-m-1,md+m)==1)a=m+1;
			else b=m;
			m=a+(b-a)/2|0;
		}
		return m;
	}
	const msm=(a,s,md,e)=>{
		let m=bin(a,s,md,e);
		while(m>0){
			for(let i=0;i<m;i++)
				rswap(a,md-m+i,md+i);
			msm(a,md,md+m,e);
			e=md;
			md-=m;
			m=bin(a,s,md,e);
		}
	}
	const msms=(a,b,c)=>{
		let len=c-b,i;
		for(let j=1;j<len;j*=2){
			for(i=b;i+2*j<=c;i+=j*2)
				msm(a,i,i+j,i+j*2);
			if(i+j<c)
				msm(a,i,i+j,c);
		}
	}
	msms(array,0,len);
	return[5,1]
}
function inPlaceMergeSort(){
	let array=[...arr];
	const push=(array,p,a,b)=>{
		if(a==b)return;
		let tmp=array[p];
		rset(array,p,array[a]);
		for(let i=a+1;i<b;i++)
			rset(array,i-1,array[i]);
		rset(array,b-1,tmp);
	}
	const M=(a,b,m,c)=>{
		let i=b,j=m;
		while(i<m&&j<c)
			if(compareIndices(a,i,j)==1)j++;
			else push(a,i++,m,j);
		while(i<m)push(a,i++,m,c);
	}
	const ms=(a,b,c)=>{
		let m=b+(c-b)/2|0;
		if(c-b>2){
			if(c-b>3)
				ms(a,b,m);
			ms(a,m,c);
		}
		M(a,b,m,c);
	}
	ms(array,0,len);
	return[-.05,1]
}
function rotateMergeSort(){
	let array=[...arr];
	function rotate(array,a,m,b){
		IndexRots.griesMills(array,a,m,b,1);
	}
	function bs(array,a,b,value,left){
		while(a<b){
			let m=a+(b-a)/2|0;
			let comp=left?compareValues(value,array[m])<=0:compareValues(value,array[m])<0;
			if(comp)b=m;
			else a=m+1;
		}
		return a;
	}
	function rotateMerge(array,a,m,b){
		let m1,m2,m3;
		if(m-a>=b-m){
			m1=a+(m-a)/2|0;
			m2=bs(array,m,b,array[m1],true);
			m3=m1+(m2-m);
		}else{
			m2=m+(b-m)/2|0;
			m1=bs(array,a,m,array[m2],false);
			m3=(m2++)-(m-m1);
		}
		rotate(array,m1,m,m2);
		if(m2-m3+1>0&&b-m2>0)rotateMerge(array,m3+1,m2,b);
		if(m1-a>0&&m3-m1>0)rotateMerge(array,a,m1,m3);
	}
	function rotateMergeSort(array,a,b){
		let len=b-a,i;
		for(let j=1;j<len;j*=2){
			for(i=a;i+2*j<=b;i+=2*j)
				rotateMerge(array,i,i+j,i+2*j);
			if(i+j<b)
				rotateMerge(array,i,i+j,b);
		}
	}
	rotateMergeSort(array,0,len);
	return[5,1]
}
function strandSort(){
	let array=[...arr];
	function mergeTo(array,subList,a,m,b){
		let i=0,s=m-a;
		while(i<s&&m<b)
			if(compareValues(subList[i],array[m])<0)rset(array,a++,subList[i++]);
			else rset(array,a++,array[m++]);
		while(i<s)rset(array,a++,subList[i++]);
	}
	let subList=new Array(len);
	let j=len,k=j;
	while(j>0){
		write(subList,0,array[0]);
		for(let i=0,p=0,m=1;m<j;m++){
			if(compareValues(array[m],subList[i])>=0){
				write(subList,++i,array[m]);
				k--;
			}else rset(array,p++,array[m]);
		}
		mergeTo(array,subList,--k,j,len);
		j=k;
	}
	return[-.01,1]
}
function weavedMergeSort(){
	let array=[...arr];
	function merge(array,tmp,length,residue,modulus){
		if(residue+modulus>=length)return;
		let low=residue;
		let high=residue+modulus;
		let dmodulus=modulus<<1;
		merge(array,tmp,length,low,dmodulus);
		merge(array,tmp,length,high,dmodulus);
		let nxt=residue;
		for(;low<length&&high<length;nxt+=modulus){
			let cmp=compareIndices(array,low,high);
			if(cmp==1||cmp==0&&low>high){
				write(tmp,nxt,array[high]);
				high+=dmodulus;
			}else{
				write(tmp,nxt,array[low]);
				low+=dmodulus;
			}
		}
		if(low>=length){
			while(high<length){
				write(tmp,nxt,array[high]);
				nxt+=modulus;
				high+=dmodulus;
			}
		}else{
			while(low<length){
				write(tmp,nxt,array[low]);
				nxt+=modulus;
				low+=dmodulus;
			}
		}
		for(let i=residue;i<length;i+=modulus)
			rset(array,i,tmp[i]);
	}
	let tmp=new Array(len);
	merge(array,tmp,len,0,1);
	return[-.01,1]
}
function pancakeSort(){
	let array=[...arr];
	let i=len
	while(i>=0&&!isSorted(array)){
		let c=getMaxIndex(array,i);
		if(c!=--i){
			reversal(array,0,c)
			reversal(array,0,i)
		}
	}
	return[5,1]
}
function maxHeapSort(){
	let array=[...arr];
	heapSort(array,0,len,true)
	return[-.01,1]
}
function minHeapSort(){
	let array=[...arr];
	heapSort(array,0,len,false)
	return[-.01,1]
}
function cycleSort(){
	let array=[...arr];
	let i=0
	while(i<len){
		let c=array[i]-1;
		if(compareIndices(array,i,c)!=0)
			rswap(array,i--,c)
		i++
	}
	return[5,1]
}
function inPlaceMSDRadixSort(){
	let array=[...arr];
	const radixMSD=(a,l,min,max,r,p)=>{
		if(min>=max||p<0)return;
		let b=new Array(r);
		for(let i=0;i<r;i++)b[i]=min;
		for(let i=min;i<max;i++){
			let t=a[i];
			let d=getDigit(t,p,r);
			for(let j=r-1;j>d;j--){
				if(b[j]!=b[j-1])
					rset(a,b[j],a[b[j-1]]);
				write(b,j,b[j]+1);
			}
			rset(a,b[d],t);
			write(b,d,b[d]+1);
		}
		for(let i=0;i<r;i++)radixMSD(a,l,i==0?min:b[i-1],b[i],r,p-1);
	}
	let base=4
	let hp=maxLog(array,len,base);
	radixMSD(array,len,0,len,base,hp);
	return[5,1]
}
function asteraceaeSort(){
	let array=[...arr];
	function cf(ar,l){
		let i=1;
		let fs=2;
		let as=1;
		let ls=0;
		if(fs-1==0)i=1;
		else i=fs-1;
		as=0;ls=0;
		while(i<len){
			if(compareIndices(ar,i-1,i)>0){
				swap(ar,i-1,i++,1);
				if(!as)fs=i-1;
				as=ls=1;
			}else{
				if(ls)i+=floor(sqrt(l));
				else i++;
				ls=0;
			}
		}
		return as
	}
	let as=1;
	while(as){
		as=cf(array,len)
		customFunc(cf,[len])
	}
	return[5,0]
}
function LMSDRadixSort(){
	let array=[...arr];
	function radixSort(a,s,e,p){
		let regs=new Array(base);
		for(let i=0;i<base;i++)regs[i]=[];
		for(let i=s;i<e;i++){
			let digit=getDigit(a[i],p,base);
			regs[digit]=regs[digit].concat([a[i]]);
		}
		let c=s;
		for(let i=0;i<base;i++)
			for(let j=0;j<regs[i].length;j++)
				rset(a,c++,regs[i][j])
		return regs;
	}
	function lmsdRadixSort(array,mina,maxa,place,maxPlace){
		if(maxPlace<place||maxa-mina<=1)return;
		let regs=radixSort(array,mina,maxa,place);
		if(place!=maxPlace){
			regs=radixSort(array,mina,maxa,maxPlace);
			let sum=0;
			for(let i=0;i<regs.length;i++){
				lmsdRadixSort(array,sum+mina,sum+mina+regs[i].length,place+1,maxPlace-1);
				sum+=regs[i].length;
			}
		}
	}
	let base=4;
	let hp=maxLog(array,len,base);
	lmsdRadixSort(array,0,len,0,hp);
	return[0,1]
}
function awkwardSort(){
	let array=[...arr];
	const awkward=(arr,l,p)=>{
		if(l==1)return;
		l|=0
		p|=0
		awkward(arr,l/2,p);
		awkward(arr,l/2+l%2,p+l/2);
		for(let i=0;i<l/2;i++){
			let a=p+i;
			let b=p+l/2+l%2+i;
			if(compareIndices(arr,a,b)==1)
				rswap(arr,a,b);
		}
		awkward(arr,l/2+l%2,p+l/4);
		awkward(arr,l/2,p);
		awkward(arr,l/2+l%2,p+l/2);
	}
	awkward(array,len,0);
	return[5,1]
}
function chinottoSort(){
	let array=[...arr];
	let d=0;
	let gap=1;
	while(!d){
		let i=0;
		d=1;
		for(;i+gap<len;i++){
			if(compareIndices(array,i,i+gap)==1){
				d=0;
				rmultiSwap(array,i,i+gap);
				gap++;
			}else if(gap>=2)
				gap--;
		}
		for(;i-gap>0;i--){
			if(compareIndices(array,i-gap,i)==1){
				d=0;
				rmultiSwap(array,i,i-gap);
				gap++;
			}else if(gap>=2)gap--;
		}
	}
	return[5,1]
}
function circleMergeSort(){
	let array=[...arr];
	const csr=(a,l)=>{
		let sc=0;
		for(let g=l/2;g>circleDepth;g/=2){
			for(let s=0;s+g<len;s+=2*g){
				let h=s+2*g-1|0;
				let lw=s|0;
				for(;lw<h;){
					if(h<len&&compareIndices(a,lw,h)>0)
						rswap(a,lw,h,sc++);
					lw++;
					h--;
				}
			}
		}
		return sc;
	}
	for(let n=1;n<=len;n*=2)
		while(csr(array,n));
	return[5,1]
}
function clamberSort(){
	let array=[...arr];
	for(let i=1;i<len;i++)
		for(let j=0;j<i;j++)
			if(compareIndices(array,i,j)<0)
				rswap(array,i,j);
	return[5,1]
}
function cocktailGrateSort(){
	let array=[...arr];
	let n=1;
	while(n){
		n=0;
		let i,j;
		for(i=0;i<len-1;i++){
			for(j=len-1;j>i;j--){
				if(compareIndices(array,i,j)>0){
					n=1;
					rswap(array,i,j);
					break;
				}
			}
		}
		if(!n)break;
		for(i=0;i<len-1;i++){
			for(j=i+1;j<len;j++){
				if(compareIndices(array,i,j)>0){
					rswap(array,i,j);
					break;
				}
			}
		}
	}
	return[5,1]
}
function cocktailPushSort(){
	let array=[...arr];
	let as=1;
	function cf(ar,a,b,s,g){
		for(let j=1;j<=g;j++)
			swap(ar,a,b+j*s,1);
	}
	while(as){
		as=0;
		let i=1,g=1;
		while(i+g<=len){
			if(compareIndices(array,i-1,i-1+g)>0){
				cf(array,i-1,i-1,1,g)
				customFunc(cf,[i-1,i-1,1,g])
				as=1
				g++;
			}else i++;
		}
		i=len;
		g=1;
		while(i-g>0){
			if(compareIndices(array,i-1-g,i-1)>0){
				cf(array,i-1,i-1,-1,g)
				customFunc(cf,[i-1,i-1,-1,g])
				as=1
				g++;
			}else i--;
		}
	}
	return[0,0]
}
function dandelionSort(){
	let array=[...arr];
	for(let b=0;b<len;){
		let pointer=b;
		let as=0;
		while(pointer<len-1&&compareIndices(array,pointer+1,pointer)<0){
			rswap(array,pointer,pointer+1);
			as=1;
			pointer++;
		}
		if(as){
			if(b>0)b--;
			continue;
		}
		b++;
	}
	return[5,0]
}
function floatSort(){
	let array=[...arr];
	let n=1;
	while(n){
		let h=0;
		n=0;
		for(let g=len-1;g>0;g--){
			let i=h;
			let j=h+1;
			while(i>=0&&compareIndices(array,i,j)>0){
				rswap(array,i--,j--);
				n=1;
			}
			if(i>=0){
				i++;
				j++;
				while(j<len&&compareIndices(array,i,j)>0){
					rswap(array,i++,j++);
					n=1;
				}
			}
			h++;
		}
	}
	return[5,1]
}
function iterativeQuickSort(){
	let array=[...arr];
	let s=0,e=len-1
	let st=new Array(len);
	let top=-1;
	write(st,++top,s);
	write(st,++top,e);
	while(top>=0){
		e=st[top--];
		s=st[top--];
		let pv=array[e];
		let i=s-1;
		for(let j=s;j<e;j++)
			if(compareValues(array[j],pv)<=0)
				rswap(array,++i,j);
		rswap(array,++i,e);
		let p=i
		if(compareValues(p-1,s)==1){
			write(st,++top,s);
			write(st,++top,p-1);
		}
		if(compareValues(e,p+1)==1){
			write(st,++top,p+1);
			write(st,++top,e);
		}
	}
	return[5,1]
}
function indexQuickSort(){
	let array=[...arr];
	const iqs=(array,idx,a,b)=>{
		while(a<b){
			if(compareValues(a,idx[a])!=0){
				let t=array[a];
				let i=a,nxt=idx[a];
				do{
					rset(array,i,array[nxt]);
					write(idx,i,i);
					i=nxt;
					nxt=idx[nxt];
				}while(compareValues(nxt,a)!=0);
				rset(array,i,t);
				write(idx,i,i);
			}
			a++;
		}
	}
	const sort=(array,idx,a,b)=>{
		if(b-a<2)return;
		let c0=a,c1=c0,i;
		let m=a+random()*(b-a)|0;
		for(i=a;i<m;i++)
			if(compareIndices(array,i,m)<=0)
				c1++;
		i++;
		c1++;
		for(;i<b;i++)
			if(compareIndices(array,i,m)<0)
				c1++;
		let p=c1-1;
		for(i=a;i<m;i++){
			if(compareIndices(array,i,m)<=0)
				write(idx,c0++,i);
			else write(idx,c1++,i);
		}
		write(idx,p,i++);
		for(;i<b;i++){
			if(compareIndices(array,i,m)<0)
				write(idx,c0++,i);
			else write(idx,c1++,i);
		}
		iqs(array,idx,a,b);
		sort(array,idx,a,p);
		sort(array,idx,p+1,b);
	}
	let idx=new Array(len);
	sort(array,idx,0,len);
	return[5,1]
}
function pseudoHeapSort(){
	let array=[...arr];
	function sift_down(array,start,length,root){
		let swapped=0;
		let j=root;
		while(2*j<length){
			let k=2*j;
			if(k<length&&compareIndices(array,start+k-1,start+k)==1)k++;
			if(compareIndices(array,start+j-1,start+k-1)==1){
				rswap(array,start+j-1,start+k-1);
				j=k;
				swapped=1;
				continue;
			}
			break;
		}
		return swapped;
	}
	let s=1
	while(s--)for(let i=len-2;i>=0;i--)sift_down(array,i,len-i+1,1)&&(s=1)
	return[1,1]
}
function iterativeCircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(icsr(array,n));
	return[5,1]
}
function recursiveCircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rcsr(array,0,n-1,0,len));
	return[5,1]
}
function LLQuickSortMiddlePivotSort(){
	let array=[...arr];
	function partition(array,a,b){
		let i=a,j=i,m=(a+b)/2|0;
		while(j<m){
			if(compareIndices(array,j,m)<=0)
				rswap(array,i++,j);
			j++;
		}
		rswap(array,i,m);
		j=m+1;
		m=i++;
		while(j<b){
			if(compareIndices(array,j,m)<0)
				rswap(array,i++,j);
			j++;
		}
		rswap(array,--i,m);
		return i;
	}
	function quickSort(array,a,b){
		if(b-a>1){
			let p=partition(array,a,b);
			quickSort(array,a,p);
			quickSort(array,p+1,b);
		}
	}
	quickSort(array,0,len);
	return[5,1]
}
function pushSort(){
	let array=[...arr];
	let as=1;
	let i=1;
	let gap=1;
	function cf(a,g,i){
		for(let j=1;j<=g;j++)
			swap(a,i-1,i-1+j,1);
	}
	while(as){
		as=0;
		i=1;
		gap=1;
		while(i+gap<=len){
			if(compareIndices(array,i-1,i-1+gap)>0){
				cf(array,gap,i);
				customFunc(cf,[gap,i]);
				as=1;
				gap++;
			}else i++;
		}
	}
	return[5,0]
}
function reflectionSort(){
	let array=[...arr];
	let as=1;
	let i=0;
	while(as){
		i=0;
		as=0;
		while(i<len){
			if(compareIndices(array,i,i+1)>0){
				rswap(array,i,i+1);
				i=(len-1)-i;
				as=1;
			}else i++;
		}
		i=len;
		as=0;
		while(i>1){
			if(compareIndices(array,i-1,i)>0){
				rswap(array,i-1,i);
				i=(len-1)-i;
				as=1;
			}else i--;
		}
	}
	return[5,1]
}
function splitCenterSort(){
	let array=[...arr];
	let way=1;
	let i=1;
	for(let r=1;r<len;r++){
		i=len/2|0;
		while(i<len&&i>0){
			if(compareIndices(array,i-1,i)>0)rswap(array,i-1,i);
			i+=way;
		}
		way*=-1;
	}
	return[5,1]
}
function wiggleSort(){
	let array=[...arr];
	const ws=(a,l,s,e)=>{
		if(e-s<2)return;
		let lp=s;
		let rp=e;
		let mp=(lp+rp)/2|0;
		let sl=1;
		let j=mp;
		for(let i=lp;i<mp;i++){
			for(let k=mp;k<e;k++){
				if(compareIndices(a,i,j)>=0)rswap(a,i,j);
				if(sl)j++;
				else j--;
			}
			if(sl)j--;
			else j++;
			sl=!sl
		}
		ws(a,l,s,mp);
		ws(a,l,mp,e);
	}
	ws(array,len,0,len);
	return[5,1]
}
function zipperSort(){
	let array=[...arr];
	let i=0;
	let gap=2;
	let f=0;
	while(gap>1){
		gap=1;
		i=f>1?f-1:0;
		while(i+gap<len){
			if(compareIndices(array,i,i+gap)>0){
				rswap(array,i,i+gap);
				if(gap==1)f=i;
				gap++;
			}else i++;
		}
	}
	return[5,1]
}
function pairwiseCircleSort(){
	let array=[...arr];
	const pairs=(ar,l,r,g)=>{
		if(l+g>=r)return;
		let a=l;
		while(a+g<=r){
			if(compareIndices(ar,a,a+g)==1)
				rswap(ar,a,a+g);
			a+=g*2;
		}
		pairs(ar,l,r,g*2);
		pairs(ar,l+g,r,g*2);
	}
	const circle=(ar,l,r)=>{
		let a=l;
		let b=r;
		while(l<r){
			if(compareIndices(ar,l,r)==1)
				rswap(ar,l,r);
			l++;
			r--;
		}
	}
	const pairCircle=(a,l,r)=>{
		if(l>=r)return;
		let m=(l+r)/2|0;
		pairs(a,l,r,1);
		circle(a,l,r);
		pairCircle(a,l,m);
		pairCircle(a,m+1,r);
	}
	pairCircle(array,0,len-1);
	insertSort(array,0,len);
	return[5,1]
}
function iterativeSinkingMergeSort(){
	let array=[...arr];
	const bs=(a,s,e)=>{
		let cs=1;
		for(let i=e-1;i>s;i-=cs){
			cs=1;
			for(let j=s;j<i;j++){
				if(compareIndices(a,j,j+1)>0){
					rswap(a,j,j+1);
					cs=1;
				}else cs++;
			}
		}
	}
	let mRun=len;
	for(;mRun>=32;mRun=(mRun+1)/2);
	let i;
	for(i=0;i+mRun<len;i+=mRun)
		bs(array,i,i+mRun);
	bs(array,i,len);
	for(let j=mRun;j<len;j*=2){
		for(i=0;i+2*j<=len;i+=2*j)
			bs(array,i,i+2*j);
		if(i+j<len)
			bs(array,i,len);
	}
	return[5,0]
}
function recursiveSinkingMergeSort(){
	let array=[...arr];
	const bs=(a,s,e)=>{
		let cs=1;
		for(let i=e-1;i>s;i-=cs){
			cs=1;
			for(let j=s;j<i;j++){
				if(compareIndices(a,j,j+1)>0){
					rswap(a,j,j+1);
					cs=1;
				}else cs++;
			}
		}
	}
	function sort(a,s,e){
		if(e-s>16){
			let m=s+(e-s)/2|0;
			sort(a,s,m);
			sort(a,m,e);
			bs(a,s,e);
		} else
			bs(a,s,e);
	}
	sort(array,0,len);
	return[5,0]
}
function cocktailShellSort(){
	let array=[...arr];
	let g=len/2;
	let dir=1;
	while(g>=1){
		if(dir){
			for(let i=g;i<len;i++){
				let tmp=array[i],j=i;
				while(j>=g&&compareValues(array[j-g],tmp)==1){
					rset(array,j,array[j-g]);
					j-=g;
				}
				rset(array,j,tmp);
			}
		}else{
			for(let i=len-g;i>=0;i--){
				let tmp=array[i],j=i;
				while(j<len-g&&compareValues(array[j+g],tmp)==-1){
					rset(array,j,array[j+g]);
					j+=g;
				}
				rset(array,j,tmp);
			}
		}
		g/=2;
		dir=!dir;
	}
	return[5,1]
}
function indexMergeSort(){
	let array=[...arr];
	function sort(ar,idx,a,b){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		sort(ar,idx,a,m);
		sort(ar,idx,m,b);
		let i=a,j=m,c=a;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<=0)write(idx,c++,i++);
			else write(idx,c++,j++);
		}
		while(i<m)write(idx,c++,i++);
		while(j<b)write(idx,c++,j++);
		while(a<b){
			if(compareValues(a,idx[a])!=0){
				let t=array[a];
				let i=a,nxt=idx[a];
				do{
					rset(array,i,array[nxt]);
					write(idx,i,i);
					i=nxt;
					nxt=idx[nxt];
				}while(compareValues(nxt,a)!=0);
				rset(array,i,t);
				write(idx,i,i);
			}
			a++;
		}
	}
	let idx=new Array(len);
	sort(array,idx,0,len);
	return[5,1]
}
function mobMergeSort(){
	let array=[...arr];
	const bubble=(array,start,end)=>{
		let c=1;
		let s;
		let f=start+((end-start)/2)|0;
		let a=false;
		for(let j=end-1;j>0;j-=c){
			if(f-1<start)s=start;
			else s=f-1;
			a=false;
			c=1;
			for(let i=s;i<j;i++){
				if(compareIndices(array,i,i+1)>0){
					rswap(array,i,i+1);
					if(!a)f=i;
					a=true;
					c=1;
				}else c++;
			}
		}
	}
	let l=2;
	let index=0;
	while(l<=len){
		index=0;
		while(index+l<=len){
			if(l==2){
				if(compareIndices(array,index,index+1)>0)rswap(array,index,index+1);
			}else bubble(array,index,index+l);
			index+=l;
		}
		if(index!=len)bubble(array,index,len);
		l*=2;
	}
	bubble(array,0,len);
	return[5,0]
}
function moduloMergeSort(){
	let array=[...arr];
	const mr=(a,s,m,e,mx)=>{
		let l=s;
		let r=m+1;
		let f=s;
		while(l<=m&&r<=e){
			if(compareValues(a[l]%mx,a[r]%mx)<=0)rset(a,f,a[f]+(a[l++]%mx)*mx);
			else rset(a,f,a[f]+(a[r++]%mx)*mx);
			f++;
		}
		while(l<=m)rset(a,f,a[f++]+(a[l++]%mx)*mx);
		while(r<=e)rset(a,f,a[f++]+(a[r++]%mx)*mx);
		for(let i=s;i<=e;i++)rset(a,i,a[i]/mx|0);
	}
	const ms=(a,s,e,mx)=>{
		if(s<e){
			let m=s+((e-s)/2)|0;
			ms(a,s,m,mx);
			ms(a,m+1,e,mx);
			mr(a,s,m,e,mx);
		}
	}
	ms(array,0,len-1,getMax(array,len)+1);
	return[5,1]
}
function split16MergeSort(){
	let array=[...arr];
	let moss=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16,1,5,9,13,2,6,10,14,3,7,11,15,4,8,12,16,1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16,6,11,7,10,4,13,14,15,8,12,2,3,5,9,2,5,8,14,3,9,12,15,6,7,10,11,3,5,12,14,4,9,8,13,7,9,11,13,4,6,8,10,4,5,6,7,8,9,10,11,12,13,7,8,9,10];
	const cs1=(a,b,c)=>{
		if(compareIndices(a,b,c)>0)
			rswap(a,b,c);
	}
	const cs2=(a,b,c,g,s)=>{
		if(compareIndices(a,s+b*g,s+c*g)>0)
			rswap(a,s+b*g,s+c*g);
	}
	const mos=(a,b,g)=>{
		for(let i=0;i<moss.length;i+=2)
			cs2(a,moss[i]-1,moss[i+1]-1,g,b);
	}
	const merge=(a,st,sz)=>{
		let gap=sz/16;
		for(let i=0;i<gap;i++)
			mos(a,st+i,gap);
		for(let s=gap/2;s>0;s/=2)
			for(let i=0;i<sz-s;i++)
				cs1(a,st+i,st+i+s);
	}
	for(let i=0;i<len-15;i+=16)
		mos(array,i,1);
	for(let gap=32;gap<=len;gap*=2)
		for(let i=0;i+gap<=len;i+=gap)
			merge(array,i,gap);
	return[5,1]
}
function cbrtQuickSort(){
	let array=[...arr];
	const sort=(a,start,stop)=>{
		let l=stop-start;
		if(l>=2){
			let root=cbrt(l)|0;
			let newStart=start+root;
			sort(a,start,newStart);
			let pivots=new Array(root);
			for(let i=0;i<root;i++)
				write(pivots,i,i+start);
			for(let i=newStart;i<stop;i++){
				let left=0,right=root;
				while(left<right){
					let mid=(right-left)/2+left|0;
					if(compareIndices(a,pivots[mid],i)==1)right=mid;
					else left=mid+1;
				}
				let pos=i;
				for(let j=root-1;j>=left;j--){
					rswap(a,pivots[j]+1,pos);
					rswap(a,pos=pivots[j],pivots[j]+1);
					write(pivots,j,pivots[j]+1);
				}
			}
			sort(a,start,pivots[0]);
			for(let i=1;i<root;i++)
				sort(a,pivots[i-1]+1,pivots[i]);
			sort(a,pivots[root-1]+1,stop);
		}
	}
	sort(array,0,len)
	return[5,1]
}
function apollyonSort(){
	let array=[...arr];
	const apm=(A,lo,n,d)=>{
		if(n<=1)return;
		let m=1;
		while(m<<1<n)m<<=1;
		for(let i=lo;i<lo+n-m;i++)
			if(d==(compareIndices(A,i,i+m)==1))
				rswap(A,i,i+m)
		apm(A,lo,m,d);
		apm(A,lo+m,n-m,d);
	}
	const aps=(A,lo,n,d)=>{
		if(n<=1)return;
		let m=n/2|0;
		aps(A,lo,m,!d);
		apm(A,lo,n,d);
	}
	aps(array,0,len,1);
	while(rcsr(array,0,len-1,0));
	return[5,1]
}
function optimizedPancakeSort(){
	let array=[...arr];
	function cursedRotate(a,b,m,c){
		reversal(a,0,b-1);
		reversal(a,0,m-1);
		reversal(a,0,c-1);
		reversal(a,0,c-m+b-1);
	}
	function bs(array,a,b,value,left){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(left?compareValues(value,array[m])<=0:compareValues(value,array[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function pm(array,m,b){
		let m1,m2,m3;
		if(m>=b-m){
			m1=m/2|0;
			m2=bs(array,m,b,array[m1],0);
			m3=m1+(m2-m);
		}else{
			m2=m+(b-m)/2|0;
			m1=bs(array,0,m,array[m2],1);
			m3=(m2++)-(m-m1);
		}
		cursedRotate(array,m1,m,m2);
		if(m1>0&&m3>m1)pm(array,m1,m3);
		m3++;
		if(m2>m3&&b>m2){
			cursedRotate(array,0,m3,b);
			pm(array,m2-m3,b-m3);
			cursedRotate(array,0,b-m3,b);
		}
	}
	function pms(array,n){
		if(n<=1)return;
		if(compareIndices(array,0,1)<=0){
			let i=2;
			for(;i<n&&compareIndices(array,i-1,i)<=0;i++);
			if(i==n)return;
		}else{
			let i=2;
			for(;i<n&&compareIndices(array,i-1,i)>0;i++);
			if(i==n){
				reversal(array,0,n-1);
				return;
			}
		}
		let m=n/2|0;
		pms(array,m);
		cursedRotate(array,0,m,n);
		m=n-m;
		pms(array,m);
		pm(array,m,n);
	}
	pms(array,len);
	return[5,1]
}
function magneticaQuickSort(){
	let array=[...arr];
	let left=0,right=len-1,threshold=17,i,j,pl,pr,entries=right-left+1,stack=new Array(entries),stackptr=2,p,lback=left,rback=right,midmid,gear=0,cmp;
	write(stack,1,left);
	write(stack,2,right);
	do{
		right=stack[stackptr];
		left=stack[stackptr-1];
		stackptr-=2;
		for(;left+threshold<right;){
			j=right;
			pl=left;
			pr=left;
			if(right-left>31){
				midmid=left+((right-left)>>2);
				if(gear==0){
					insertSort(array,midmid,midmid+3);
					rswap(array,midmid+1,pr);
				}else{
					insertSort(array,midmid,midmid+7);
					rswap(array,midmid+3,pr);
				}
			}
			p=array[pr];
			for(;pr<j;){
				pr++;
				cmp=compareValues(p,array[pr]);
				if(cmp>0){
					rswap(array,pl,pr);
					pl++;
				}else if(cmp<0){
					for(;compareValues(p,array[j])<0;)j--;
					if(pr<j)rswap(array,pr,j);
					j--;
					pr--;
				}
			}
			j=pl-1;
			i=pr+1;
			gear=(maxVal(right-i,j-left)>(minVal(right-i,j-left)<<6)?1:0);
			if(i+threshold<right){
				stackptr+=2;
				write(stack,stackptr-1,i);
				write(stack,stackptr,right);
				stackptr*=(stackptr+2<=entries-1?1:0);
				right*=(stackptr+2<=entries-1?1:0);
			}
			right=j;
		}
	}while(stackptr!=0);
	insertSort(array,lback,rback+1);
	return[5,1]
}
function cocktailPeelSort(){
	let array=[...arr];
	for(let l=0;l<len;l++){
		let s=0;
		for(let r=len-1;r>l;r--){
			if(compareIndices(array,l,r+s)>0){
				let i=array[r+s];
				for(let p=r+s;p>l;p--)rset(array,p,array[p-1]);
				rset(array,l,i);
				s++;
			}
		}
		l++;
		for(let r=l+1;r<len;r++){
			if(compareIndices(array,l,r)>0){
				let i=array[r];
				for(let p=r;p>l;p--)rset(array,p,array[p-1]);
				rset(array,l,i);
			}
		}
	}
	return[5,1]
}
function ecoloSort(){
	let array=[...arr];
	let l=1;
	let r=len;
	let w=1;
	let i=1;
	while(l<=r){
		if(w==1)i=l;
		else i=r;
		while((w==1&&i<r)||(w==-1&&i>l)){
			if(compareIndices(array,l-1,i-1)>0)rswap(array,l-1,i-1);
			if(compareIndices(array,i-1,r-1)>0)rswap(array,i-1,r-1);
			i+=w;
		}
		l++;
		r--;
		w*=-1;
	}
	return[5,1]
}
function fallSort(){
	let array=[...arr];
	let l=1;
	let r=2;
	let hl=0;
	while(l<=len){
		r=l+1;
		hl=0;
		while(r<=len){
			if(compareIndices(array,l-1,r-1)>0){
				if(hl==0)hl=r;
				else if(compareIndices(array,hl-1,r-1)<0)hl=r;
			}
			r++;
		}
		if(hl==0)l++;
		else rswap(array,l-1,hl-1);
	}
	return[5,1]
}
function heavyHeapSort(){
	let array=[...arr];
	function bitReversal(ar,a,b){
		let len=b-a,m=0;
		let d1=len>>1,d2=d1+(d1>>1);
		for(let i=1;i<len-1;i++){
			let j=d1;
			for(let k=i,n=d2;(k&1)==0;j-=n,k>>=1,n>>=1);
			m+=j;
			if(m>i)rswap(ar,a+i,a+m);
		}
	}
	let dir=0;
	for(let i=0;i<len;i++){
		heapify(array,i,len,dir,0);
		customFunc(heapify,[i,len,dir++,0])
		dir%=2
	}
	let n=1;
	while(n<=len)n+=2;
	while(n>=0){
		if(compareIndices(array,n,n-2)>0)rswap(array,n,n-2,n+=2)
		else n-=2
	}
	for(let i=1,j=len-1;i<j;i+=2,j-=2)
		rswap(array,i,j);
	bitReversal(array,0,len);
	bitReversal(array,0,len/2|0);
	bitReversal(array,len/2|0,len);
	return[15,1]
}
function sandPaperSort(){
	let array=[...arr];
	for(let i=0;i<len-1;i++)
		for(let j=i+1;j<len;j++)
			if(compareIndices(array,i,j)>0)
				rswap(array,i,j);
	return[5,1]
}
function recursiveBurningSort(){
	let array=[...arr];
	function sort(array,start,end){
		if(start==end)return;
		let mid=(start+end)/2|0,g0=mid-start;
		if (start==mid)return;
		sort(array,start,mid);
		sort(array,mid,end);
		for(let i=0;i<g0;i++)
			if(i+start!=end-i-1&&compareIndices(array,i+start,end-i-1)==1)
				rswap(array,i+start,end-i-1);
		sort(array,start,mid);
		sort(array,mid,end);
	}
	sort(array,0,len,0);
	return[5,1]
}
function corruptSort(){
	let array=[...arr];
	const comp=(a,s,e)=>{
		if(compareIndices(a,s,e)==1)
			rswap(a,s,e);
	}
	const pass=(a,s,e,l,g,t)=>{
		for(let i=s;i<e;i++)
			for(let g2=g;g2>t;g2/=2)
				if(i+g2<l)
					comp(a,i,i+g2);
	}
	const merge=(a,s,e,b)=>{
		if(e<=s)return;
		let m=(s+e)/2|0,g0=m-s,g1=g0/2|0;
		if(!b)
			for(let i=s;i<m;i++)
				if(i+g0<e)
					comp(a,i,i+g0);
		if(s==m)return;
		if(e-s>4)
			pass(a,s+g1,m,e,g1,1);
		merge(a,s,m,1);
		merge(a,m,e,1);
	}
	const sort=(a,s,e)=>{
		if(e<=s)return;
		let m=(s+e)/2|0;
		if(s==m)merge(a,s,e,0);
		else{
			sort(a,s,m);
			sort(a,m,e);
			merge(a,s,e,0);
		}
	}
	let n=1;
	while(n*2<=len)n*=2;
	sort(array,0,len);
	pass(array,0,len,len,n-1,0);
	return[5,1]
}
function circleHalverSort(){
	let array=[...arr];
	let end;
	const cs=(a,b,c)=>{
		let m=b<c&&c<len&&compareIndices(a,b,c)>0
		m&&rswap(a,b,c);
		return m;
	}
	const bc=(a,b,c)=>{
		let d=0
		for(let i=b,j=c-1;i<j;i++,j--)
			d=cs(a,i,j);
		return d;
	}
	const halver=(a,b,c)=>{
		let n=c-b,e=-1;
		while(1){
			for(let j=1;j<n/2;j*=2)
				for(let i=b;i<minVal(len,c);i+=2*j)
					for(let k=0;k<j;k++)
						cs(a,i+k,i+j+k);
			if(!bc(a,b,c))break;
			e++;
		}
	}
	let l=1<<(log(len-1)/log(2))+1|0;
	halver(array,0,l);
	for(let j=l/2;j>4;j/=2)
		for(let i=0;i+j/2<len;i+=j)
			if(bc(array,i,i+j))
				halver(array,i,i+j);
	for(let i=2;i<len;i+=4)
		cs(array,i-1,i);
	return[5,1]
}
function iterativePairwiseSort(){
	let array=[...arr];
	const sort=(ar,l)=>{
		let a=1,b=0,c=0,d=0,e=0;
		while(a<l){
			b=a;
			c=0;
			while(b<l){
				if(compareIndices(ar,b-a,b)==1)
					rswap(ar,b-a,b);
				c=(c+1)%a;
				b++;
				if(c==0)b+=a;
			}
			a*=2;
		}
		a/=4;
		e=1;
		while(a>circleDepth){
			d=++e;
			while(d>0){
				b=(d+1)*a;
				c=0;
				while(b<l){
					if(compareIndices(ar,b-d*a,b)==1)
						rswap(ar,b-d*a,b);
					c=(c+1)%a;
					b++;
					if(c==0)b+=a;
				}
				d/=2;
			}
			a/=2;
			e*=2;
		}
	}
	sort(array,len);
	return[5,1]
}
function iterativeVanVoorhisSort(){
	let array=[...arr];
	const cs=(a,b,c)=>{
		if(compareIndices(array,b,c)>0)rswap(a,b,c);
	}
	const cr=(a,b,c,s)=>{
		while(s-->0)cs(a,b++,c++);
	}
	for(let k=4;k/4<=len;k*=4){
		let f=k/4;
		for(let i=0;i<len;i+=k){
			cr(array,i,i+f,f);
			cr(array,i+f+f,i+f+f+f,f);
		}
		for(let i=0;i<len;i+=k){
			cr(array,i,i+f+f,f);
			cr(array,i+f,i+f+f+f,f);
		}
		for(let i=0;i<len;i+=k)
			cr(array,i+f,i+f+f,f);
		for(let m=16;m<=k;m*=4){
			let s=k/m;
			for(let i=0;i<len;i+=k){
				for(let j=2;j+7<m;j+=4){
					cr(array,i+j*s,i+(j+6)*s,s);
					cr(array,i+(j+1)*s,i+(j+7)*s,s);
				}
			}
			for(let i=0;i<len;i+=k){
				for(let j=1;j+5<m;j+=4){
					cr(array,i+j*s,i+(j+3)*s,s);
					cr(array,i+(j+2)*s,i+(j+5)*s,s);
				}
			}
			for(let i=0;i<len;i+=k){
				for(let j=2;j+3<m;j+=4){
					cr(array,i+j*s,i+(j+2)*s,s);
					cr(array,i+(j+1)*s,i+(j+3)*s,s);
				}
			}
			for(let i=0;i<len;i+=k)
				for(let j=3;j+3<m;j+=2)
					cr(array,i+j*s,i+(j+1)*s,s);
		}
	}
	return[5,1]
}
function rotateLSDRadixSort(){
	let array=[...arr];
	const msw=(a,b,c,l)=>{
		for(let i=0;i<l;i++)rswap(a,b+i,c+i);
	}
	function rotate(a,b,c,m){
		let l=m-b,r=c-m;
		while(l>0&&r>0){
			if(r<l){
				msw(a,m-r,m,r);
				c-=r;m-=r;l-=r;
			}else{
				msw(a,b,m,l);
				b+=l;m+=l;r-=l;
			}
		}
	}
	function bs(ar,a,b,d,p){
		while(a<b){
			let m=(a+b)/2|0;
			if(getDigit(ar[m],p,base)>=d)b=m;
			else a=m+1;
		}
		return a;
	}
	function merge(array,a,m,b,da,db,p){
		if(b-a<2||db-da<2)return;
		let dm=(da+db)/2|0;
		let m1=bs(array,a,m,dm,p);
		let m2=bs(array,m,b,dm,p);
		rotate(array,m1,m2,m);
		m=m1+(m2-m);
		merge(array,m,m2,b,dm,db,p);
		merge(array,a,m1,m,da,dm,p);
	}

	function ms(ar,a,b,p){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		ms(ar,a,m,p);
		ms(ar,m,b,p);
		merge(ar,a,m,b,0,base,p);
	}
	let base=10;
	let max=maxLog(array,len,base);
	for(let i=0;i<=max;i++)
		ms(array,0,len,i);
	return[5,1]
}
function digSort(){
	let array=[...arr];
	function par(ar,a,b){
		let mx=new Array(b-a),
			max=ar[a];
		for(let i=1;i<b-a;i++){
			if(ar[a+i]>max){
				max=ar[a+i];
				mx[i]=1;
			}
		}
		let p=1;
		for(let i=b-a-1,j=b-a-1;j>=0&&i>=p;j--){
			while(!mx[j]&&j>0)j--;
			max=array[a+j];
			while(max<=ar[a+i]&&i>=p)i--;
			if(compareIndices(ar,a+j,a+i)==1&&p<i-j)p=i-j;
		}
		return p;
	}
	let ls=0,le=0,ms=len-2,sw=1;
	for(let i=0;i<len&&sw;i=ls){
		le=par(array,0,len);
		sw=0;
		let msed=0;
		for(let j=ms;j>=i;j--){
			if(compareIndices(array,j,j+1)>0){
				rswap(array,ls=j,j+1);
				sw=1
				if(msed){
					msed=1;
					ms=j+1<len-1?j+1:len-2;
				}
			}
		}
		for(let l=ls+1;l<=ms&&sw;l++){
			if(compareIndices(array,l,l+1)>0){
				let bl=l+le<len-1?l+le:len-2;
				for(let r=l+1;r<=bl;r++){
					if(compareIndices(array,l,r)>0){
						rswap(array,l++,r);
						if(r>ms)ms=r;
					}
				}
			}
		}
	}
	return[5,1]
}
function cityscapeSort(){
	let array=[...arr];
	function csdep(a,i,j){
		if(i==j)return;
		let b=math.min(i,j),c=math.max(i,j);
		if(compareIndices(a,b,c)>0)rswap(a,b,c);
	}
	function sp(a,s,e,g){
		for(let h=g,i=h+s;i<e;i++){
			let v=a[i],j=i,w=0;
			for(;j>=h&&j-h>=s&&compareValues(a[j-h],v)==1;j-=h)rset(a,j,a[j-h],w=1);
			if(w)rset(a,j,v);
		}
	}
	function sh(a,s,e){
		for(let g=((e-s)/2.25)|0;g>=2;g/=2.25)sp(a,s,e,g|0);
		sp(a,s,e,1);
	}
	function mxs(ar,st,e){
		let a=e-1,b=e-1,sg=1;
		while(sg){
			if(b-1<st)return st;
			if(compareIndices(ar,b-1,b)>0)sg=0;
			else b--;
		}
		let sel=b-1;
		for(let s=b-2;s>=st;s--)
			if(compareIndices(ar,sel,s)<0)sel=s;
		while(compareIndices(ar,sel,a)<=0)
			if(--a<st)break;
		return a+1;
	}
	function shuffle(a,s,e){
		for(let i=s;i<e;i++){
			let r=random()*(e-i)+i|0;
			if(r!=i)rswap(array,i,r);
		}
	}
	let i=len;
	while(i>0){
		let h=i,j=0;
		for(;j<i;j++){
			csdep(array,j,j+1);
			for(h=i-1;h>i-j-2;h--){
				csdep(array,j,h);
				if(h<=j)break;
			}
			if(h<=j)break;
		}
		sh(array,j,i);
		i=mxs(array,0,i);
		shuffle(array,0,i);
	}
	return[5,1]
}
function iterativeClericSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(iclsr(array,n,len));
	return[5,1]
}
function recursiveClericSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rclsr(array,0,n-1,0));
	return[5,1]
}
function debrisSort(){
	let array=[...arr];
	let i=0;
	let f=1;
	let l=len-1;
	let nl=len-1;
	let ar=true;
	while(ar){
		ar=false;
		let ff=false;
		if(f>0)i=f-1;
		else i=0;
		for(;i<l;i++){
			let s=i;
			for(;compareIndices(array,i,i+1)>0&&i<l;i++){
				if(!ff){
					f=i;
					ff=true;
				}
				nl=i+1;
			}
			let e=i;
			if(s!=e){
				if(e-s<3)rswap(array,s,e,1,ar=true);
				else reversal(array,s,e,1,ar=true);
			}
		}
		if(nl+1<len)l=nl+1;
		else l=len-1;
	}
	return[5,1]
}
function californiumSort(){
	let array=[...arr];
	function sqrtrnd(v){
		let p=0;
		while(++p*p<v);
		return p;
	}
	function cal(ar,a,b,d,d2){
		if(b-a==2&&compareIndices(ar,a,a+1)>0)rswap(ar,a,a+1);
		if(--d2<1){
			for(let i=a;++i<b;)
				if(compareIndices(ar,i-1,i)>0)
					rswap(ar,i-1,i,i=a);
			return;
		}
		if(a>=b-2)
			return;
		let recurse=new Array(),maxstack=new Array();
		let i=b,j,k,m,me=0,b0=b;
		let shd=0;
		bndchk:while(i>a+1){
			recurse.unshift(i=b0)
			maxstack=[];
			for(k=sqrtrnd(i-a);k-->0;){
				shd=maxstack.length&&compareValues(ar[a],maxstack[0])>=0;
				me=0;
				for(j=(m=a)+1;j<i;j++){
					let p=compareIndices(ar,m,j);
					if(p==0)me++;
					if(p<0||shd)
						if(!maxstack.length||compareValues(ar[j],maxstack[0])<0){
							m=j;
							shd=0;
							me=0;
						}
				}
				if(shd)
					break bndchk;
				maxstack.unshift(ar[m])
				k-=me;
			}
			cnt:for(j=b0=a;j<i;j++){
				for(let i=0;i<maxstack.length;i++){
					let v=maxstack[i]
					if(compareValues(ar[j],v)==0){
						reversal(ar,b0,j-1,1);
						continue cnt;
					}
				}
				reversal(ar,b0,j-1,2);
				reversal(ar,a,b0-1,2);
				rmultiSwap(ar,j,b0++);
			}
		}
		if(me==b-a-1)
			return;
		j=a;
		for(k=0;k<recurse.length;k++)
			cal(ar,j,j=recurse[k],d,d2);
	}
	cal(array,0,len,0,(32-clz32(len-1))/2|0);
	return[5,1]
}
function evubSort(){
	let array=[...arr];
	function cs(a,z){
		if(compareIndices(a,z,z+1)>0)
			rswap(a,z,z+1);
	}
	function sort(a,b,bs){
		if(bs==1)
			for(let c=0;c<=b;c++)
				cs(a,c);
		else
			for(let c=0;c<=b;c++)
				sort(a,c,bs-1);
	}
	let base=3;
	for(let a=len-1;a>0;a--)
		for(let b=0;b+1<=a;b++)
			if(base==2)cs(array,b);
			else sort(array,b,base-2);
	return[5,0]
}
function iterativeFiringSquadSort(){
	let array=[...arr];
	function fs(array,start,end,dir){
		if(dir){
			let left=start;
			let right=start+1;
			let lcycle=1;
			let rcycle=true;
			while(left<right){
				if(compareIndices(array,left,right)>0)rswap(array,left,right,swaps=1);
				if(++lcycle>2){
					left++;
					lcycle=0;
				}
				if(rcycle){
					if(++right>end-1){
						right--;
						rcycle=0;
					}
				}else right--;
			}
		}else{
			let right=end-1;
			let left=end-2;
			let rcycle=1;
			let lcycle=true;
			while(left<right){
				if(compareIndices(array,left,right)>0)rswap(array,left,right,swaps=1);
				if(++rcycle>2){
					right--;
					rcycle=0;
				}
				if(lcycle){
					if(--left<start){
						left++;
						lcycle=false;
					}
				}else left++;
			}
		}
	}
	function init(array,start,end,firstdir){
		fs(array,start,end,firstdir);
		let dir=true;
		for(let l=(end-start)/2;l>1;l/=2)
			for(let i=start;i+l<=end;i+=l)
				fs(array,i,i+l,dir=!dir);
	}
	let swaps=1;
	let l=2;
	for(;l*2<=len;l*=2);
	let cdir=0;
	while(swaps){
		swaps=false;
		if(l==len)init(array,0,len,cdir=!cdir);
		else{
			init(array,0,l,true);
			if(len-l>=l/2)init(array,(len-l)/2|0,(len+l)/2|0,true);
			init(array,len-l,len,false);
		}
	}
	return[5,1]
}
function recursiveFiringSquadSort(){
	let array=[...arr];
	function fs(array,start,end,dir){
		if (dir) {
			let left=start;
			let right=start+1;
			let lcycle=1;
			let rcycle=true;
			while(left<right){
				if(compareIndices(array,left,right)>0)rswap(array,left,right,swaps=1);
				if(++lcycle>2){
					left++;
					lcycle=0;
				}
				if(rcycle){
					if(++right>end-1){
						right--;
						rcycle=0;
					}
				}else right--;
			}
		}else{
			let right=end-1;
			let left=end-2;
			let rcycle=1;
			let lcycle=1;
			while(left<right){
				if(compareIndices(array,left,right)>0)rswap(array,left,right,swaps=1);
				if(++rcycle>2){
					right--;
					rcycle=0;
				}
				if(lcycle){
					if(--left<start){
						left++;
						lcycle=0;
					}
				}else left++;
			}
		}
		if(end-start>2){
			fs(array,start,end-(end-start)/2|0,false);
			fs(array,end-(end-start)/2|0,end,true);
		}
	}
	let swaps=1;
	let l=2;
	for(;l*2<=len;l*=2);
	let cdir=0;
	while(swaps){
		swaps=false;
		if(l==len)fs(array,0,len,cdir=!cdir);
		else{
			fs(array,0,l,true);
			if(len-l>=l/2)init(array,(len-l)/2|0,(len+l)/2|0,true);
			fs(array,len-l,len,false);
		}
	}
	return[5,1]
}
function fordSort(){
	let array=[...arr];
	let q=0;
	while(!rangeSorted(array,len)){
		for(let k=len/2;k>0;k--){
			for(let i=q;i<len;i+=2*k){
				let l=i;
				let change=0;
				while(l>0&&compareIndices(array,l,l-1)==-1){
					rswap(array,l,l-1);
					l-=2;
					if(i>0)i--;
					change=1;
				}
				if(change)i++;
				else i--;
			}
		}
		q=(q+1)&1;
	}
	return[5,1]
}
function futureSort(){
	let array=[...arr];
	let as=1;
	let tl=2;
	for(;tl*2<=len;tl*=2);
	let l=len;
	while(as){
		as=0;
		let ls=0;
		for(let o=0,m=1;o!=l-1;o++){
			if(tl>1){
				while(o+m*2<l)m*=2;
				while(m>=tl)m/=2;
			}
			for(;m>=1;m/=2)
				if(compareIndices(array,o,o+m)>0)
					rswap(array,ls=o,o+m,as=1);
		}
		l=ls+2<l?ls+1:l-1;
		if(tl>1)tl/=2;
	}
	return[5,1]
}
function iterativePopSort(){
	let array=[...arr];
	function cf(a,d,s,j,b,f,c){
		for(let i=s;i<j;i++){
			if(compareIndices(a,i,i+1)==d){
				swap(a,i,i+1);
				if(!b)f=i;
				b=1;
				c=1;
			}else c++;
		}
		return[f,b,c]
	}
	const bubble=(a,st,e,d)=>{
		let s;
		let c=1;
		let f=1;
		for(let j=e-1;j>0;j-=c){
			if(f-1<st)s=st;
			else s=f-1;
			let b=0;
			c=1;
			let f1=1,b1=b,c1=c;
			[f,b,c]=cf(a,d,s,j,b1,f1,c1)
			if(b)customFunc(cf,[d,s,j,b1,f1,c1]);
		}
	}
	for(let l=2;l<len;l*=2){
		let i=0;
		let d=-1;
		for(;i+l<=len;i+=l,d*=-1)bubble(array,i,i+l,d);
		if(i!=len)bubble(array,i,len,d);
	}
	bubble(array,0,len,1);
	return[5,1]
}
function jumpDownSort(){
	let array=[...arr];
	for(let i=len-1;i>0;i--)
		for(let j=0;j<i;j++)
			if(compareIndices(array,i,j)<0)
				rswap(array,i,j);
	return[5,1]
}
function monolithicClurgeSort(){
	let array=[...arr];
	const mc=(a,s,m,e,b)=>{
		if(m<=s||e<=m)return;
		if(b==0){
			mc(a,s,s+(m-s)/2|0,m,0);
			mc(a,m,m+(e-m)/2|0,e,0);
			mc(a,s,m,e,1);
		}else{
			let c=0;
			if((c=compareIndices(a,s,m))==1)
				rswap(a,s,m);
			mc(a,s+1,m,e,2);
			if(b!=2)
				mc(a,s+(c==-1?2:1),m+1,e,1);
		}
	}
	mc(array,0,len/2|0,len,0);
	return[5,1]
}
function pairwiseCombSort(){
	let array=[...arr];
	const i3s=n=>{
		while((n&1)==0)n>>=1;
		return(n&++n)==0;
	}
	for(let g=len/2;g>0;g--)
		if(i3s(g))
			for(let i=g;i<len;i++)
				if(compareIndices(array,i-g,i)==1)
					rswap(array,i-g,i);
	return[5,1]
}
function pancakeQuickSort(){
	let array=[...arr];
	const flip=(a,i)=>{
		reversal(a,0,i,1);
	}
	const rot=(a,c1,c2)=>{
		flip(a,c1-1);
		flip(a,c2-1);
		flip(a,c2-c1-1);
	}
	const medOf3=(a,p1,p2,p3)=>{
		if(p1==p2)return p1;
		if(p2==p3)return p2;
		if(compareIndices(a,p1,p2)<=0){
			if(compareIndices(a,p2,p3)<=0)return p2;
			if(compareIndices(a,p1,p3)<=0)return p3;
			return p1;
		}
		if(compareIndices(a,p2,p3)<=0)return p2;
		if(compareIndices(a,p1,p3)<=0)return p1;
		return p3;
	}
	function pancakeLLQS(a,l){
		if(l==2){
			if(compareIndices(a,0,l-1)>0)
				flip(a,l-1);
			return;
		}else if(l<2)return;
		let j=0,m=(l-1)/2|0,piv=a[medOf3(a,0,m,l-1)];
		for(let i=0;i<l;i++){
			let k=i;
			while(k<l&&compareValues(piv,a[k])>=0){
				k++;j++;
			}
			if(k>i){
				flip(a,i-1);
				flip(a,k-1);
				i=k-1;
			}
		}
		pancakeLLQS(a,j);
		rot(a,j,l);
		pancakeLLQS(a,l-j);
		rot(a,l-j,l);

	}
	pancakeLLQS(array,len);
	return[5,1]
}
function popPopSort(){
	let array=[...arr];
	function cf(a,s,e,d){
		j=s
		for(let i=s;i<=e-1;i++)
			if(compareIndices(a,i-1,i)==d)
				swap(a,i-1,j=i);
		return j
	}
	const bb=(a,s,e,d)=>{
		while(1){
			customFunc(cf,[s,e,d]);
			if(cf(a,s,e,d)<s+1)break;
		}
	}
	const p=(a,s,e,d)=>{
		bb(a,s,s+(e-s)/4|0,0-d);
		bb(a,s+(e-s)/4+1|0,(s+e)/2|0,d);
		bb(a,(s+e)/2+1|0,s+(e-s)*3/4|0,0-s);
		bb(a,s+(e-s)*3/4+1|0,e,d);
		bb(a,s,(s+e)/2|0,0-d);
		bb(a,(s+e)/2+1|0,e,d);
		bb(a,s,e,d);
	}
	p(array,1,(len+1)/4|0,-1);
	p(array,(len+1)/4+1|0,(len+1)/2|0,1);
	p(array,(len+1)/2+1|0,(len+1)*3/4|0,-1);
	p(array,(len+1)*3/4+1|0,len,1);
	p(array,1,len,1);
	return[5,0]
}
function inPlaceLSDRadixSort(){
	let array=[...arr];
	let pos=0;
	let base=10;
	let vregs=new Array(base-1);
	let maxpower=maxLog(array,len,base);
	for(let p=0;p<=maxpower;p++){
		for(let i=0;i<vregs.length;i++)
			write(vregs,i,len-1);
		pos=0;
		for(let i=0;i<len;i++){
			let digit=getDigit(array[pos],p,base);
			if(digit==0)
				pos++;
			else{
				for(let j=0;j<vregs.length;j++)
					rswap(array,vregs[j],vregs[j]);
				rmultiSwap(array,pos,vregs[digit-1]);
				for(let j=digit-1;j>0;j--)
					write(vregs,j-1,vregs[j-1]-1);
			}
		}
	}
	return[5,1]
}
function swaplessPushSort(){
	let array=[...arr];
	let as=1,i,f=1;
	while(as){
		as=0;
		if(f>1)i=f-1;
		else i=1;
		let g=1;
		while(i+g<=len){
			if(compareIndices(array,i-1,i-1+g)>0){
				if(!as)f=i;
				insertTo(array,i-1+g,i-1,2,as=1);
				g++;
			}else i++;
		}
	}
	return[5,1]
}
function reboundSort(){
	let array=[...arr];
	let st=0;
	let s=0;
	for(let d=1;!s;d*=-1){
		let i=d==1||!st?0:len-2;
		st=1;
		s=1;
		for(;i>=0&&i<len-1;i+=d)
			if(compareIndices(array,i,i+1)>0){
				rswap(array,i,i+1,s=0);
				d=-d;
			}
	}
	return[5,1]
}
function rubbleSort(){
	let array=[...arr];
	const sig=(a,b,d)=>((a+d)+d*abs(a-b))/2|0;
	function run(a,s,e){
		if(s>=e-1)return s+1;
		let c=-compareIndices(a,s++,s)|1,k=s-1,d;
		do d=compareIndices(a,s++,s);while(s<e&&d!=c);
		let m=(s-k)/2|0,q=sig(k,s-1,-c);
		for(let i=0;i<m;i++)rswap(a,k+i,q+c*i);
		return s;
	}
	let runs=new Array(len/2|0+1);
	let rf=0,r=0;
	while(r<len)write(runs,rf++,(r=run(array,r,len))-1);
	function cf(ar,rs,rf){
		for(let i=2;i<rf;i++){
			if(compareIndices(ar,rs[i-1],rs[i])>0){
				let t=ar[rs[i-1]],temp=rs[i-1]-1;
				while(temp>=(i-2<0?0:rs[i-2]+1)){
					if(compareIndices(ar,temp,rs[i])<=0)break;
					write(ar,temp+1,ar[temp--]);
				}
				write(ar,temp+1,ar[rs[i]]);
				write(ar,rs[i],t);
			}
		}
	}
	while(rf>1){
		customFunc(cf,[[...runs],rf])
		cf(array,[...runs],rf)
		if(runs[rf-1]==runs[rf-2])write(runs,--rf,0);
		else write(runs,rf-1,runs[rf-1]-1);
	}
	doubleInsert(array,0,len)
	arraycopy([...arr].sort((a,b)=>a-b),0,array,0,len,1)
	return[5,1]
}
function searchSort(){
	let array=[...arr];
	const bs=(a,b,c,v)=>{
		while(b<c){
			let m=b+((c-b)/2)|0;
			if(compareValues(v,a[m])<0)c=m;
			else b=m+1;
		}
		return b;
	}
	let i=0;
	while(i+1<len){
		let ver=1;
		while(i+1<len&&ver){
			if(compareIndices(array,i,i+1)<=0)i++;
			else ver=0;
		}
		if(i+1<len)rswap(array,i+1,bs(array,0,i,array[i+1]));
	}
	return[5,1]
}
function selectionSort(){
	let array=[...arr];
	for(let i=0;i<len-1;i++){
		let l=i;
		for(let j=i+1;j<len;j++)
			if(compareIndices(array,j,l)==-1)
				l=j;
		rswap(array,i,l);
	}
	return[5,1]
}
function iterativeShircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(ishsr(array,n));
	return[5,1]
}
function recursiveShircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rshsr(array,0,n-1,0));
	return[5,1]
}
function XSort(){
	let array=[...arr];
	let gap=len;
	function cf(ar,g,l){
		let as=0
		for(let i=1;i-1+g<l;i++){
			if(compareIndices(ar,i-1,i-1+g)>0){
				swap(ar,i-1,i-1+g);
				as=true;
				let xleft=i+1;
				let xright=i+g-1;
				if(g!=1){
					for(let r=0;r<g-1;r++){
						if(compareIndices(ar,xleft-1,xright-1)>0)
							swap(ar,xleft-1,xright-1,1);
						xleft++;
						xright--;
					}
				}
			}
		}
		return[g,as]
	}
	let as=0;
	while(1){
		[gap,as]=cf(array,gap,len)
		customFunc(cf,[gap,len])
		if(!as){
			if(gap==1)break;
			else gap--;
		}
	}
	return[5,1]
}
function blockShellSort(){
	let array=[...arr];
	function gappedBinary(A,P,l,K,G,i){
		let L=-1,R=l,C,M;
		while(L<R-1){
			M=L+((R-L)>>1);
			C=compareIndices(A,P+M*G,K);
			if(C==1||(i&&C==0))R=M;
			else L=M;
		}
		return R;
	}
	function GSFW(A,P,L,G){
		let t=A[P];
		for(let i=0;i<L;i++)rset(A,P+i*G,A[P+(i+1)*G]);
		rset(A,P+L*G,t);
	}
	function GSBW(A,P,L,G){
		let t=A[P+L*G];
		for(let i=L;i>0;i--)rset(A,P+i*G,A[P+(i-1)*G]);
		rset(A,P,t);
	}
	function GMSFW(A,lA,lB,L,G){
		for(let i=0;i<L;i++)rswap(A,lA+i*G,lB+i*G);
	}
	function GMSBW(A,lA,lB,L,G){
		for(let i=0;i<L;i++)rswap(A,lA+i*G,lB+i*G);
	}
	function rotate(A,P,L,R,G){
		while(L>1&&R>1){
			if(L<=R){
				GMSFW(A,P,P+L*G,L,G);
				P+=L*G;
				R-=L;
			}else{
				GMSBW(A,P+(L-R)*G,P+L*G,R,G);
				L-=R;
			}
		}
		if(L>0&&R>0){
			if(L==1)GSFW(A,P,R,G);
			else if(R==1)GSBW(A,P,L,G);
		}
	}
	function merge(array,P,L0,L1,G){
		let S;
		if(L0<L1){
			while(L0!=0){
				S=gappedBinary(array,P+L0*G,L1,P,G,true);
				if(S!=0){
					rotate(array,P,L0,S,G);
					P+=S*G;
					L1-=S;
				}
				if(L1==0)break;
				do{P+=G;L0--;}while(L0!=0&&compareIndices(array,P,P+L0*G)<=0);
			}
		}else{
			while(L1!=0){
				S=gappedBinary(array,P,L0,P+(L0+L1-1)*G,G,false);
				if(S!=L0){
					rotate(array,P+S*G,L0-S,L1,G);
					L0=S;
				}
				if(L0==0)break;
				do L1--;while(L1!=0&&compareIndices(array,P+(L0-1)*G,P+(L0+L1-1)*G)<=0);
			}
		}
	}
	function gappedReverse(a,s,e,g){
		for(;s<=e-g;s+=g,e-=g)rswap(a,s,e);
	}
	function getRun(array,start,end,gap){
		let t=start,iD=-compareIndices(array,start,start+gap),len=1;
		if(end-start<gap)return 1;
		if(iD==0)iD=1;
		do{len++;start+=gap;}while(start<=end-gap&&compareIndices(array,start,start+gap)!=iD);
		if(iD==-1)gappedReverse(array,t,start,gap);
		return len;
	}
	let gaps=[1,4,10,23,57,132,301,701];
	function ciura(n){
		if(n<=gaps.length)return gaps[n-1];
		return pow(2.25,n)|0;
	}
	function shellPass(array,start,end,gap){
		if(end-start<gap)return;
		let done,starts=new Array(gap),lens=new Array(gap),ends=new Array(gap);
		for(let i=0;i<gap;i++){
			starts[i]=start+i;
			lens[i]=0;
			ends[i]=(end-(end%gap))+i;
			if(ends[i]>=end)
				ends[i]-=gap;
		}
		do{
			done=true;
			for(let i=0;i<gap;i++){
				let v=starts[i]+lens[i]*gap;
				if(v>ends[i]||ends[i]==-1)continue;
				done=false;
				let r=getRun(array,v,ends[i],gap);
				merge(array,starts[i],lens[i],r,gap);
				write(lens,i,lens[i]+r);
			}
		}while(!done);
	}
	let k=1;
	while(ciura(k++)<len);
	while(--k>1)shellPass(array,0,len,ciura(k-1));
	return[5,1]
}
function rotateMSDRadixSort(){
	let array=[...arr];
	function shift(n,q){
		while(q>0){
			n/=base;
			q--;
		}
		return n|0;
	}
	function ms(ar,a,b,l){
		for(let i=0;i<l;i++)
			rswap(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				ms(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				ms(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function bs(ar,a,b,d,p){
		while(a<b){
			let m=(a+b)/2|0;
			if(getDigit(ar[m],p,base)>=d)b=m;
			else a=m+1;
		}
		return a;
	}
	function merge(ar,a,m,b,da,db,p){
		if(b-a<2||db-da<2)return;
		let dm=(da+db)/2|0;
		let m1=bs(ar,a,m,dm,p);
		let m2=bs(ar,m,b,dm,p);
		rot(ar,m1,m,m2);
		m=m1+(m2-m);
		merge(ar,m,m2,b,dm,db,p);
		merge(ar,a,m1,m,da,dm,p);
	}
	function mrs(ar,a,b,p){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		mrs(ar,a,m,p);
		mrs(ar,m,b,p);
		merge(ar,a,m,b,0,base,p);
	}
	function dist(ar,a,b,p){
		mrs(ar,a,b,p);
		return bs(ar,a,b,1,p);
	}
	let base=4;
	let q=maxLog(array,len,base);
	let m=0,i=0,b=len;
	while(i<len){
		let p=b-i<1?i:dist(array,i,b,q);
		if(q==0){
			m+=base;
			let t=m/base;
			while(t%base==0){
				t/=base;
				q++;
			}
			i=b;
			while(b<len&&shift(array[b],q+1)==shift(m,q+1))
				b++;
		}else{
			b=p;
			q--;
		}
	}
	return[5,1]
}
function recursivePairwiseSort(){
	let array=[...arr];
	function psr(ar,s,e,g){
		if(s==e-g)return;
		let a=1,b=s+g;
		while(b<e){
			if(compareIndices(ar,b-g,b)>0)
				rswap(ar,b-g,b);
			b+=2*g;
		}
		if(((e-s)/g)%2==0){
			psr(ar,s,e,g*2);
			psr(ar,s+g,e+g,g*2);
		}else{
			psr(ar,s,e+g,g*2);
			psr(ar,s+g,e,g*2);
		}
		while(a<((e-s)/g))a=a*2+1;
		b=s+g;
		while(b+g<e){
			let c=a;
			while(c>1){
				c/=2;c|=0;
				if(b+c*g<e)
					if(compareIndices(ar,b,b+c*g)>0)
						rswap(ar,b,b+c*g);
			}
			b+=2*g;
		}
	}
	psr(array,0,len,1);
	return[5,1]
}
function flashSort(){
	let array=[...arr];
	function sort(array,len){
		let m=(.2*len)+2|0,min,max,mi;
		min=max=array[0];
		mi=0;
		for(let i=1;i<len-1;i+=2){
			let small,big,bi;
			if(compareIndices(array,i,i+1)<0){
				small=array[i];
				big=array[i+1];
				bi=i+1;
			}else{
				big=array[i];
				bi=i;
				small=array[i+1];
			}
			if(big>max){
				max=big;
				mi=bi;
			}
			if(small<min)min=small;
		}
		if(compareValues(array[len-1],min)<0)min=array[len-1];
		else if(compareValues(array[len-1],max)>0){
			max=array[len-1];
			mi=len-1;
		}
		if(max==min)return;
		let L=new Array(m+1);
		for(let t=1;t<=m;t++)write(L,t,0)
		let c=(m-1)/(max-min);
		let K;
		for(let h=0;h<len;h++){
			K=((array[h]-min)*c)+1|0;
			write(L,K,L[K]+1);
		}
		for(K=2;K<=m;K++)write(L,K,L[K]+L[K-1]);
		rswap(array,mi,0);
		let j=0;
		K=m;
		let moves=0;
		while(moves<len){
			while(j>=L[K]){
				j++;
				K=((array[j]-min)*c)+1|0;
			}
			let evicted=array[j];
			while(j<L[K]){
				K=((evicted-min)*c)+1|0;
				let loc=L[K]-1;
				let temp=array[loc];
				rset(array,loc,evicted);
				evicted=temp;
				write(L,K,L[K]-1);
				moves++;
			}
		}
		insertSort(array,0,len);
	}
	sort(array,len)
	return[5,1]
}
function americanFlagSort(){
	let array=[...arr];
	let base=4;
	function gmnod(a,l){
		let m=-1/0,t=0;
		for(let i=0;i<l;i++){
			t=log(a[i])/log(base)+1;
			if(t>m)m=t;
		}
		return m|0;
	}
	function getd(i,d){
		return(i/d|0)%base;
	}
	function sort(a,s,e,dv){
		let cnt=new Array(base);
		let offset=new Array(base);
		let digit=0;
		for(let i=s;i<e;i++){
			let d=a[i];
			digit=getd(d,dv);
			write(cnt,digit,cnt[digit]+1);
		}
		write(offset,0,s);
		for(let i=1;i<base;i++)
			write(offset,i,cnt[i-1]+offset[i-1]);
		for(let b=0;b<base;b++){
			while(cnt[b]>0){
				let origin=offset[b],from=origin,num=a[from];
				a[from]=-1
				do{
					digit=getd(num,dv);
					let to=offset[digit];
					write(offset,digit,offset[digit]+1);
					write(cnt,digit,cnt[digit]-1);
					let temp=a[to];
					rset(a,to,num);
					num=temp;
					from=to;
				}while(from!=origin);
			}
		}
		if(dv>1){
			for(let i=0;i<base;i++){
				let begin=(i>0)?offset[i-1]:s;
				let end=offset[i];
				if(end-begin>1)
					sort(a,begin,end,dv/base|0);
			}
		}
	}

	let nod=gmnod(array,len);
	let max=1;
	for(let i=0;i<nod-1;i++)max*=base;
	sort(array,0,len,max);
	insertSort(array,0,len)
	return[5,1]
}
function iterative3SmoothCombSort(){
	let array=[...arr];
	let pow2=log(len-1)/log(2)|0;
	for(let k=pow2;k>=0;k--){
		let pow3=(log(len)-k*log(2))/log(3)|0;
		for(let j=pow3;j>=0;j--){
			let gap=pow(2,k)*pow(3,j)|0;
			for(let i=0;i+gap<len;i++)
				if(compareIndices(array,i,i+gap)>0)
					rswap(array,i,i+gap)
		}
	}
	return[5,1]
}
function recursive3SmoothCombSort(){
	let array=[...arr];
	function rc(a,p,g,e){
		if(p+g>e)return;
		rc(a,p,g*2,e);
		rc(a,p+g,g*2,e);
		pot(a,p,g,e);
	}
	function pot(a,p,g,e){
		if(p+g>e)return;
		pot(a,p,g*3,e);
		pot(a,p+g,g*3,e);
		pot(a,p+2*g,g*3,e);
		for(let i=p;i+g<e;i+=g)
			if(compareIndices(a,i,i+g)>0)
				rswap(array,i,i+g);
	}
	rc(array,0,1,len);
	return[5,1]
}
function binaryDoubleInsertionSort(){
	let array=[...arr];
	doubleInsert(array,0,len)
	return[5,1]
}
function ectaSort(){
	let array=[...arr];
	const gmr=(n)=>{
		let mr=n;
		for(;mr>=32;mr=(mr+1)/2);
		return mr|0;
	}
	function shift(ar,a,m,b){
		while(m<b)rset(ar,a++,ar[m++]);
	}
	function shiftBW(ar,a,m,b){
		while(m>a)rset(ar,--b,ar[--m]);
	}
	function mergeTo(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<=0)rset(ar,p++,ar[i++]);
			else rset(ar,p++,ar[j++]);
		}
		while(i<m)rset(ar,p++,ar[i++]);
		while(j<b)rset(ar,p++,ar[j++]);
	}
	function ppm(ar,a,m1,m2,m3,b,p){
		let p1=p+m2-a,pEnd=p+b-a;
		mergeTo(ar,a,m1,m2,p);
		mergeTo(ar,m2,m3,b,p1);
		mergeTo(ar,p,p1,pEnd,a);
	}
	function merge(ar,a,m,b,p){
		let l=b-m,pEnd=p+l-1;
		arraycopy(ar,m--,ar,p,l,1);
		while(m>=a&&pEnd>=p){
			if(compareIndices(ar,m,pEnd)>0)rset(ar,--b,ar[m--]);
			else rset(ar,--b,ar[pEnd--]);
		}
		while(pEnd>=p)rset(ar,--b,ar[pEnd--]);
	}
	function mergeFromBuf(ar,buf,a,m,b,bufLen){
		let i=0;
		while(i<bufLen&&m<b){
			if(compareValues(buf[i],ar[m])<=0)rset(ar,a++,buf[i++]);
			else rset(ar,a++,ar[m++]);
		}
		while(i<bufLen)
			rset(ar,a++,buf[i++]);
	}
	function dualMergeFromBufBW(ar,buf,a,a1,m,b,bufLen){
		let i=bufLen-1;
		bufLen-=b-(m--);
		while(i>=bufLen&&m>=a1){
			if(compareValues(buf[i],ar[m])>0)rset(ar,--b,buf[i--]);
			else rset(ar,--b,ar[m--]);
		}
		if(m<a1)while(i>=0)rset(ar,--b,buf[i--]);
		else mergeFromBuf(ar,buf,a,a1,b,bufLen);
	}
	function mrs(ar,a,b,p,mRun,bufLen){
		let i=a,j=mRun;
		for(;i+j<=b;i+=j)
			doubleInsert(ar,i,i+j);
		doubleInsert(ar,i,b);
		while(4*j<=bufLen){
			for(i=a;i+4*j<=b;i+=4*j)
				ppm(ar,i,i+j,i+2*j,i+3*j,i+4*j,p);
			if(i+3*j<b)
				ppm(ar,i,i+j,i+2*j,i+3*j,b,p);
			else if(i+2*j<b)
				ppm(ar,i,i+j,i+2*j,b,b,p);
			else if(i+j<b)
				merge(ar,i,i+j,b,p);
			j*=4;
		}
		while(j<=bufLen){
			for(i=a;i+2*j<=b;i+=2*j)
				merge(ar,i,i+j,i+2*j,p);
			if(i+j<b)
				merge(ar,i,i+j,b,p);
			j*=2;
		}
		return j;
	}
	function blockCycle(ar,keys,a,bLen,t,p,excl,fw){
		let s=fw?bLen:-bLen;
		for(let i=0;i<t;i++){
			if(compareValues(i,keys[i])!=0){
				arraycopy(ar,a+i*s,ar,p,bLen,1);
				let j=i,next=keys[i];
				do{
					if(!(excl&&j==t-1))
						arraycopy(ar,a+next*s,ar,a+j*s,bLen,1);
					write(keys,j,j);
					j=next;
					next=keys[next];
				}while(compareValues(next,i)!=0);
				arraycopy(ar,p,ar,a+j*s,bLen,1);
				write(keys,j,j);
			}
		}
	}
	function ectaMergeFW(ar,tags,a,m,b,bLen){
		let i=a,j=m,t=0,tc=0;
		let s=[2*bLen,0];
		let p=[a-2*bLen,m];
		do{
			let c=s[0]<bLen?1:0;
			for(let k=0;k<bLen;k++){
				if(i<m&&j<b){
					if(compareIndices(ar,i,j)<=0){
						rset(ar,p[c]+k,ar[i++]);
						s[0]++;
					}else{
						rset(ar,p[c]+k,ar[j++]);
						s[1]++;
					}
				}else if(i<m){
					rset(ar,p[c]+k,ar[i++]);
					s[0]++;
				}else{
					rset(ar,p[c]+k,ar[j++]);
					s[1]++;
				}
			}
			p[c]+=bLen;
			s[c]-=bLen;
			write(tags,tc++,c==0?t++:-1);
		}while(i<m||j<b);
		if(s[0]>0)write(tags,tc,t++);
		for(let k=2;k<tc;k++)
			if(tags[k]==-1)
				write(tags,k,t++);
		blockCycle(ar,tags,a-2*bLen,bLen,t,b-bLen,s[0]>0,true);
	}
	function ectaMergeBW(ar,tags,a,m,b,bLen){
		let i=b-1,j=m-1,t=0,tc=0;
		let s=[2*bLen,0];
		let p=[b+2*bLen,m];
		do{
			let c=s[0]<bLen?1:0;
			for(let k=1;k<=bLen;k++){
				if(i>=m&&j>=a){
					if(compareIndices(ar,i,j)>=0){
						rset(ar,p[c]-k,ar[i--]);
						s[0]++;
					}else{
						rset(ar,p[c]-k,ar[j--]);
						s[1]++;
					}
				}else if(i>=m){
					rset(ar,p[c]-k,ar[i--]);
					s[0]++;
				}else{
					rset(ar,p[c]-k,ar[j--]);
					s[1]++;
				}
			}
			p[c]-=bLen;
			s[c]-=bLen;
			write(tags,tc++,c==0?t++:-1);
		}while(i>=m||j>=a);
		if(s[0]>0)write(tags,tc,t++);
		for(let k=2;k<tc;k++)
			if(tags[k]==-1)
				write(tags,k,t++);
		blockCycle(ar,tags,b+bLen,bLen,t,a,s[0]>0,false);
	}
	if(len<256){
		if(len<=32)doubleInsert(array,0,len,);
		else{
			let mRun=gmr(len),bufLen=len/2|0;
			let buf=new Array(bufLen);
			arraycopy(array,bufLen,buf,0,bufLen,0);
			mrs(array,0,bufLen,bufLen,mRun,bufLen);
			arraycopy(buf,0,array,bufLen,bufLen,1);
			arraycopy(array,0,buf,0,bufLen,0);
			mrs(array,bufLen,len,0,mRun,bufLen);
			mergeFromBuf(array,buf,0,bufLen,len,bufLen);
		}
		return;
	}
	let mRun=gmr(len),bLen=mRun;
	for(;bLen*bLen<len/2;bLen*=2);
	let bufLen=2*bLen+len%bLen;
	let a=bufLen,b=len,l=b-a;
	let buf=new Array(bufLen);
	let tags=new Array(l/bLen+1|0);
	arraycopy(array,a,buf,0,bufLen,0);
	mrs(array,0,a,a,gmr(bufLen),bufLen);
	arraycopy(buf,0,array,a,bufLen,1);
	arraycopy(array,0,buf,0,bufLen,0);
	let i=a,j=mrs(array,a,b,0,mRun,bufLen);
	let bw=false;
	while(j<l){
		for(i=a;i+2*j<=b;i+=2*j)
			ectaMergeFW(array,tags,i,i+j,i+2*j,bLen);
		if(i+j<b)ectaMergeFW(array,tags,i,i+j,b,bLen);
		else shift(array,i-2*bLen,i,b);
		j*=2;
		a-=2*bLen;
		b-=2*bLen;
		if(j>=l){
			bw=true;
			break;
		}
		for(i=a;i+2*j<=b;i+=2*j);
		if(i+j<b)ectaMergeBW(array,tags,i,i+j,b,bLen);
		else shiftBW(array,i,b,b+2*bLen);
		for(i-=2*j;i>=a;i-=2*j)
			ectaMergeBW(array,tags,i,i+j,i+2*j,bLen);
		j*=2;
		a+=2*bLen;
		b+=2*bLen;
	}
	if(bw)dualMergeFromBufBW(array,buf,0,a,b,len,bufLen);
	else mergeFromBuf(array,buf,0,a,b,bufLen);
	return[15,1]
}
function flanSort(){
	let array=[...arr];
	let G=14,R=4;
	const kys=(s,pa,a,b)=>{
		let cmp=compareValues(s[pa[a]],s[pa[b]]);
		return cmp<0||(cmp==0&&compareValues(a,b)<0);
	}
	function sift(src,heap,pa,t,r,size){
		while(2*r+2<size){
			let nxt=2*r+1;
			let min=nxt+(kys(src,pa,heap[nxt],heap[nxt+1])?0:1);
			if(kys(src,pa,heap[min],t)){
				write(heap,r,heap[min]);
				r=min;
			}else break;
		}
		let min=2*r+1;
		if(min<size&&kys(src,pa,heap[min],t)){
			write(heap,r,heap[min]);
			r=min;
		}
		write(heap,r,t);
	}
	function mot(ar,a,m,b){
		if(compareIndices(ar,m,a)>0){
			if(compareIndices(ar,m,b)<0)return m;
			if(compareIndices(ar,a,b)>0)return a;
			return b;
		}else{
			if(compareIndices(ar,m,b)>0)return m;
			if(compareIndices(ar,a,b)<0)return a;
			return b;
		}
	}
	function ninther(ar,a,b){
		let s=(b-a)/9|0;
		let a1=mot(array,a,a+s,a+2*s);
		let m1=mot(array,a+3*s,a+4*s,a+5*s);
		let b1=mot(array,a+6*s,a+7*s,a+8*s);
		return mot(array,a1,m1,b1);
	}
	function motn(ar,a,b){
		let s=(b-a)/3|0;
		let a1=ninther(ar,a,a+s);
		let m1=ninther(ar,a+s,a+2*s);
		let b1=ninther(ar,a+2*s,b);
		return mot(ar,a1,m1,b1);
	}
	function shiftBW(ar,a,m,b){
		while(m>a)rswap(ar,--b,--m);
	}
	function lbls(ar,a,b,v){
		let s=G+1;
		while(a<b){
			let m=a+(((b-a)/s)/2)*s|0;
			if(compareValues(v,ar[m])<=0)b=m;
			else a=m+s;
		}
		return a;
	}
	function rbls(ar,a,b,v){
		let s=G+1;
		while(a<b){
			let m=a+(((b-a)/s)/2)*s|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+s;
		}
		return a;
	}
	function rbs(ar,a,b,v,bw){
		let cmp=bw?1:-1;
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])==cmp)b=m;
			else a=m+1;
		}
		return a;
	}
	function insertTo(ar,t,a,b){
		while(a>b)rset(ar,a,ar[--a]);
		rset(ar,b,t);
	}
	function bininsert(ar,a,b){
		for(let i=a+1;i<b;i++)
			insertTo(ar,ar[i],i,rbs(ar,a,i,ar[i]));
	}
	function kWayMerge(ar,heap,pa,s,b,p,sz){
		if(sz<2){
			if(sz==1)while(pa[0]<b)rswap(ar,p++,pa[0]++);
			return;
		}
		let a=pa[0];
		for(let i=0;i<sz;i++)write(heap,i,i);
		for(let i=(sz-1)/2|0;i>=0;i--)
			sift(ar,heap,pa,heap[i],i,sz);
		while(sz>0){
			let min=heap[0];
			rswap(ar,p++,pa[min]);
			write(pa,min,pa[min]+1);
			if(pa[min]==minVal(a+(min+1)*s,b))
				sift(ar,heap,pa,heap[--sz],0,sz);
			else sift(ar,heap,pa,heap[0],0,sz);
		}
	}
	function retrieve(ar,i,p,pEnd,bsv,bw){
		let j=i-1,m;
		for(let k=pEnd-(G+1);k>p+G;){
			m=rbs(ar,k-G,k,bsv,bw)-1;
			k-=G+1;
			while(m>=k)rswap(ar,j--,m--);
		}
		m=rbs(ar,p,p+G,bsv,bw)-1;
		while(m>=p)rswap(ar,j--,m--);
	}
	function lib(ar,a,b,p,bsv,bw){
		let l=b-a;
		if(l<32){
			bininsert(ar,a,b);
			return;
		}
		let s=l;
		while(s>=32)s=(s-1)/R+1|0;
		let i=a+s,j=a+R*s,pEnd=p+(s+1)*(G+1)+G;
		bininsert(ar,a,i);
		for(let k=0;k<s;k++)
			rswap(ar,a+k,p+k*(G+1)+G);
		while(i<b){
			if(i==j){
				retrieve(ar,i,p,pEnd,bsv,bw);
				s=i-a;
				pEnd=p+(s+1)*(G+1)+G;
				j=a+(j-a)*R;
				for(let k=0;k<s;k++)
					rswap(ar,a+k,p+k*(G+1)+G);
			}
			let bLoc=lbls(ar,p+G,pEnd-(G+1),ar[i]);
			if(compareIndices(ar,i,bLoc)==0){
				let eqEnd=rbls(ar,bLoc+(G+1),pEnd-(G+1),ar[i]);
				bLoc+=(random((eqEnd-bLoc)/(G+1)|0)|0)*(G+1);
			}
			let loc=rbs(ar,bLoc-G,bLoc,bsv,bw);
			if(loc==bLoc){
				do bLoc+=G+1;while(bLoc<pEnd&&rbs(ar,bLoc-G,bLoc,bsv,bw)==bLoc);
				if(bLoc==pEnd){
					retrieve(ar,i,p,pEnd,bsv,bw);
					s=i-a;
					pEnd=p+(s+1)*(G+1)+G;
					j=a+(j-a)*R;
					for(let k=0;k<s;k++)rswap(ar,a+k,p+k*(G+1)+G);
				}else{
					let rotP=rbs(ar,bLoc-G,bLoc,bsv,bw);
					let rotS=bLoc-maxVal(rotP,bLoc-G/2);
					shiftBW(ar,loc-rotS,bLoc-rotS,bLoc);
				}
			}else{
				let t=ar[i];
				rset(ar,i++,ar[loc]);
				insertTo(ar,t,loc,rbs(ar,bLoc-G,loc,t,false));
			}
		}
		retrieve(ar,b,p,pEnd,bsv,bw);
	}
	let pa=new Array(G+2);
	let heap=new Array(G+2);
	let a=0,b=len;
	while(b-a>=32){
		let piv=array[motn(array,a,b)];
		let i1=a,i=a-1,j=b,j1=b;
		for(;;){
			while(++i<j){
				let cmp=compareValues(array[i],piv);
				if(cmp==0)rswap(array,i1++,i);
				else if(cmp<0)break;
			}
			while(--j>i){
				let cmp=compareValues(array[j],piv);
				if(cmp==0)rswap(array,--j1,j);
				else if(cmp>0)break;
			}
			if(i<j)rswap(array,i,j);
			else{
				if(i1==b)return;
				else if(j<i)j++;
				while(i1>a)rswap(array,--i,--i1);
				while(j1<b)rswap(array,j++,j1++);
				break;
			}
		}
		let left=i-a,right=b-j,m,kCnt=0;
		if(left<=right){
			m=b-left;
			left=maxVal((right+1)/(G+1)|0,16);
			for(let k=a;k<i;k+=left){
				lib(array,k,minVal(k+left,i),j,piv,true);
				write(pa,kCnt++,k);
			}
			kWayMerge(array,heap,pa,left,i,m,kCnt);
			if(j-i<m-j){
				while(i<j)rswap(array,i++,--m);
				b=m;
			}else{
				while(m>j)rswap(array,i++,--m);
				b=i;
			}
		}else{
			m=a+right;
			right=maxVal((left+1)/(G+1)|0,16);
			for(let k=j;k<b;k+=right){
				lib(array,k,minVal(k+right,b),a,piv,false);
				write(pa,kCnt++,k);
			}
			kWayMerge(array,heap,pa,right,b,a,kCnt);
			if(i-m<j-i){
				while(m<i)rswap(array,m++,--j);
				a=j;
			}else{
				while(j>i)rswap(array,m++,--j);
				a=m;
			}
		}
	}
	bininsert(array,a,b);
	return[5,1]
}
function circularGrailSort(){
	let array=[...arr];
	const csw=(ar,a,b)=>rswap(ar,a%n,b%n);
	const cci=(ar,a,b)=>compareIndices(ar,a%n,b%n);
	const sFW=(ar,a,m,b)=>{while(m<b)csw(ar,a++,m++)}
	const sBW=(ar,a,m,b)=>{while(m>a)csw(ar,--b,--m)}
	function ins(ar,a,b){
		for(let i=a+1;i<b;i++)
			while(i>a&&cci(ar,i-1,i)>0)
				csw(ar,i,--i);
	}
	function msw(ar,a,b,l){
		for(let i=0;i<l;i++)
			csw(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				msw(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function ipm(ar,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(cci(ar,i,j)>0){
				k=j;
				while(++k<b&&cci(ar,i,k)>0);
				rot(ar,i,j,k);
				i+=k-j;j=k;
			}else i++;
		}
	}
	function merge(ar,p,a,m,b,f){
		let i=a,j=m;
		while(i<m&&j<b){
			if(cci(ar,i,j)<=0)csw(ar,p++,i++);
			else csw(ar,p++,j++);
		}
		if(i<m){
			if(i>p)sFW(ar,p,i,m);
		}else if(f)sFW(ar,p,j,b);
		return i<m?i:j;
	}
	function blt(ar,a,b,bl){
		let c=cci(ar,a,b);
		return c==-1||(c==0&&cci(ar,a+bl-1,b+bl-1)==-1);
	}
	function bmr(ar,a,m,b,bL){
		let b1=b-(b-m-1)%bL-1|0;
		if(b1>m){
			let b2=b1;
			for(let i=m-bL;i>a&&blt(ar,b1,i,bL);i-=bL,b2-=bL);
			for(let j=a;j<b1-bL;j+=bL){
				let min=j;
				for(let i=min+bL;i<b1;i+=bL)
					if(blt(ar,i,min,bL))min=i;
				if(min!=j)msw(ar,j,min,bL);
			}
			let f=a;
			for(let i=a+bL;i<b2;i+=bL){
				f=merge(ar,f-bL,f,i,i+bL,false);
				if(f<i){
					sBW(ar,f,i,i+bL);
					f+=bL;
				}
			}
			merge(ar,f-bL,f,b1,b,true);
		}else merge(ar,a-bL,a,m,b,true);
	}
	let n=len;
	if(len<=16)ins(array,0,len);
	else{
		let bLen=1;
		for(;bLen*bLen<len;bLen*=2);
		let i=bLen,j=1,l=len-i,b=len;
		while(j<=bLen){
			for(;i+2*j<b;i+=2*j)merge(array,i-j,i,i+j,i+2*j,true);
			if(i+j<b)merge(array,i-j,i,i+j,b,true);
			else sFW(array,i-j,i,b);
			i=b+bLen-j;b=i+l;j*=2;
		}
		while(j<l){
			for(;i+2*j<b;i+=2*j)bmr(array,i,i+j,i+2*j,bLen);
			if(i+j<b)bmr(array,i,i+j,b,bLen);
			else sFW(array,i-bLen,i,b);
			i=b;b+=l;j*=2;
		}
		ins(array,i-bLen,i);
		ipm(array,i-bLen,i,b);
		rot(array,0,(i-bLen)%n,len);
	}
	return[5,1]
}
function poplarHeapSort(){
	let array=[...arr];
	const hf=n=>pow(2,floor(log(n)/log(2)));
	function uis(ar,f,l){
		for(let i=f+1;i!=l;++i){
			let s=i,s1=i-1;
			if(compareIndices(ar,s,s1)<0){
				let t=ar[s];
				do rset(ar,s,ar[s1]);while(--s!=f&&compareValues(t,ar[--s1])<0);
				rset(ar,s,t);
			}
		}
	}
	function ins(ar,f,l){
		if(f==l)return;
		uis(ar,f,l);
	}
	function sift(ar,f,sz){
		if(sz<2)return;
		let rt=f+sz-1;
		let cr1=rt-1;
		let cr2=f+(sz/2-1)|0;
		while(1){
			let mr=rt;
			if(compareIndices(ar,mr,cr1)<0)mr=cr1;
			if(compareIndices(ar,mr,cr2)<0)mr=cr2;
			if(mr==rt)return;
			rswap(ar,rt,mr);
			sz/=2;
			if(sz<2)return;
			rt=mr;
			cr1=rt-1;
			cr2=mr-sz/2|0;
		}
	}
	function phws(ar,f,l,sz){
		let prs=hf(sz+1)-1;
		let lrt=l-1;
		let bg=lrt;
		let bgs=prs;
		let it=f;
		while(1){
			let rt=it+prs-1;
			if(rt==lrt)break;
			if(compareIndices(ar,bg,rt)<0){
				bg=rt;
				bgs=prs;
			}
			it=rt+1;
			sz-=prs;
			prs=hf(sz+1)-1;
		}
		if(bg!=lrt){
			rswap(ar,bg,lrt);
			sift(ar,bg-(bgs-1),bgs);
		}
	}
	function mkhp(ar,f,l){
		let sz=l-f;
		if(sz<2)return;
		let sps=15;
		if(sz<=sps)return uis(ar,f,l);
		let prl=1;
		let it=f;
		let nx=it+sps;
		while(1){
			uis(ar,it,nx);
			let prs=sps;
			for(let i=(prl&(-prl))>>1;i!=0;i>>=1){
				it-=prs;
				prs=2*prs+1;
				sift(ar,it,prs);
				++nx;
			}
			if((l-nx)<=sps)return ins(ar,nx,l);
			it=nx;
			nx+=sps;
			++prl;
		}
	}
	function shp(ar,f,l){
		let sz=l-f;
		if(sz<2)return;
		do phws(ar,f,l--,sz--);while(sz>1);
	}
	function hs(a,s,e){
		mkhp(a,s,e);
		shp(a,s,e);
	}
	hs(array,0,len);
	return[5,1]
}
function adaptiveGrailSort(){
	let array=[...arr];
	const subarray={LEFT:"L",RIGHT:"R"}
	let minRun;
	const msw=(ar,a,b,l)=>{
		for(let i=0;i<l;i++)
			rswap(ar,a+i,b+i);
	}
	const mts=(ar,a,b,c,l)=>{
		for(let i=0;i<l;i++){
			let t=ar[a+i];
			rset(ar,a+i,ar[b+i]);
			rset(ar,b+i,ar[c+i]);
			rset(ar,c+i,t);
		}
	}
	function insto(ar,a,b){
		let t=ar[a];
		while(a>b)rset(ar,a,ar[(a--)-1]);
		rset(ar,b,t);
	}
	function instoBW(ar,a,b){
		let t=ar[a];
		while(a<b)rset(ar,a,ar[(a++)+1]);
		rset(ar,a,t);
	}
	function shft(ar,a,m,b){
		while(m<b)rswap(ar,a++,m++);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>1&&r>1){
			if(r<l){
				msw(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
		if(r==1)insto(ar,m,a);
		else if(l==1)instoBW(ar,a,b-1);
	}
	function lbs(ar,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<=0)b=m;
			else a=m+1;
		}
		return a;
	}
	function rbs(ar,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function burn(ar,a,n){
		let nKeys=1,i=a+1;
		if(compareIndices(ar,i-1,i)==-1){
			i++;nKeys++;
			while(nKeys<n&&compareIndices(ar,i-1,i)<0){
				i++;nKeys++;
			}
		}else if(compareIndices(ar,i-1,i)>0){
			i++;nKeys++;
			while(nKeys<n&&compareIndices(ar,i-1,i)>0){
				i++;nKeys++;
			}
			reversal(ar,a,i-1);
		}
		return nKeys;
	}
	function burnBW(ar,b,n){
		let nKeys=1,i=b-1;
		if(compareIndices(ar,i-1,i)<0){
			i--;nKeys++;
			while(nKeys<n&&compareIndices(ar,i-1,i)<0){
				i--;nKeys++;
			}
		}else if(compareIndices(ar,i-1,i)>0){
			i--;nKeys++;
			while(nKeys<n&&compareIndices(ar,i-1,i)>0){
				i--;nKeys++;
			}
			reversal(ar,i,b-1);
		}
		return nKeys;
	}
	function fkys(ar,a,b,nKeys,n){
		let p=a,pEnd=a+nKeys;
		for(let i=pEnd;i<b&&nKeys<n;i++){
			let loc=lbs(ar,p,pEnd,ar[i]);
			if(pEnd==loc||compareIndices(ar,i,loc)!=0){
				rot(ar,p,pEnd,i);
				let inc=i-pEnd;
				loc+=inc;p+=inc;pEnd+=inc;
				insto(ar,pEnd,loc);
				nKeys++;pEnd++;
			}
		}
		rot(ar,a,p,pEnd);
		return nKeys;
	}
	function fkysBW(ar,a,b,nKeys,n){
		let p=b-nKeys,pEnd=b;
		for(let i=p-1;i>=a&&nKeys<n;i--){
			let loc=lbs(ar,p,pEnd,ar[i]);
			if(pEnd==loc||compareIndices(ar,i,loc)!=0){
				rot(ar,i+1,p,pEnd);
				let inc=p-(i+1);
				loc-=inc;pEnd-=inc;p-=inc+1;nKeys++;
				instoBW(ar,i,loc-1);
			}
		}
		rot(ar,p,pEnd,b);
		return nKeys;
	}
	function buildRuns(ar,a,b){
		let i=a+1,j=a;
		while(i<b){
			if(compareIndices(ar,i-1,i++)==1){
				while(i<b&&compareIndices(ar,i-1,i)==1)i++;
				reversal(ar,j,i-1);
			}else while(i<b&&compareIndices(ar,i-1,i)<=0)i++;
			if(i<b)j=i-(i-j-1)%minRun-1;
			while(i-j<minRun&&i<b){
				insto(ar,i,rbs(ar,j,i,ar[i]));
				i++;
			}
			j=i++;
		}
	}
	function binins(ar,a,b){
		for(let i=a+1;i<b;i++)insto(ar,i,rbs(ar,a,i,ar[i]));
	}
	function mwbr(ar,a,m,b,p,pLen){
		let i=0,j=m,k=a;
		while(i<pLen&&j<b){
			if(compareIndices(ar,p+i,j)<=0)rswap(ar,k++,p+(i++));
			else rswap(ar,k++,j++);
		}
		while(i<pLen)rswap(ar,k++,p+(i++));
	}
	function mwb(ar,a,m,b,p){
		let l=m-a;
		msw(ar,p,a,l);
		mwbr(ar,a,m,b,p,l);
	}
	function mwbBW(ar,a,m,b,p){
		let pLen=b-m;
		msw(ar,m,p,pLen);
		let i=pLen-1,j=m-1,k=b-1;
		while(i>=0&&j>=a){
			if(compareIndices(ar,p+i,j)>=0)rswap(ar,k--,p+(i--));
			else rswap(ar,k--,j--);
		}
		while(i>=0)rswap(ar,k--,p+(i--));
	}
	function ipm(ar,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(compareIndices(ar,i,j)>0){
				k=lbs(ar,j+1,b,ar[i]);
				rot(ar,i,j,k);
				i+=k-j;
				j=k;
			}else i++;
		}
	}
	function ipmBW(ar,a,m,b){
		let i=m-1,j=b-1,k;
		while(j>i&&i>=a){
			if(compareIndices(ar,i,j)>0){
				k=rbs(ar,a,i,ar[j]);
				rot(ar,k,i+1,j+1);
				j-=(i+1)-k;
				i=k-1;
			}else j--;
		}
	}
	function mwob(ar,a,m,b){
		if(m-a>b-m)ipmBW(ar,a,m,b);
		else ipm(ar,a,m,b);
	}
	function csrt(ar,a,m,b){
		return compareIndices(ar,m-1,m)>0;
	}
	function ckrbd(ar,a,m,b){
		if(compareIndices(ar,a,b-1)==1){
			rot(ar,a,m,b);
			return false;
		}
		return true;
	}
	function ckbd(ar,a,m,b){
		return csrt(ar,a,m,b)&&ckrbd(ar,a,m,b);
	}
	function grlgetsub(ar,t,mKey){
		if(compareIndices(ar,t,mKey)<0)
			return subarray.LEFT;
		else return subarray.RIGHT;
	}
	function blslsrt(ar,p,t,r,d,lCount,bCount,bLen){
		let mKey=lCount;
		for(let j=0,k=lCount+1;j<k-1;j++){
			let min=j;
			for(let i=maxVal(lCount-r,j+1);i<k;i++){
				let cmp=compareIndices(ar,p+d+i*bLen,p+d+min*bLen);
				if(cmp<0||(cmp==0&&compareIndices(ar,t+i,t+min)<0))min=i;
			}
			if(min!=j){
				msw(ar,p+j*bLen,p+min*bLen,bLen);
				rswap(ar,t+j,t+min);
				if(k<bCount&&min==k-1)k++;
			}
			if(min==mKey)mKey=j;
		}
		return t+mKey;
	}
	function grlsrtkys(ar,b,p,mKey){
		rswap(ar,p,mKey);
		let i=mKey,j=i+1,k=p+1;
		while(j<b){
			if(compareIndices(ar,j,p)<0)rswap(ar,i++,j);
			else rswap(ar,k++,j);
			j++;
		}
		msw(ar,i,p,b-i);
	}
	function grlsrtkyswob(ar,b,mKey){
		let i=mKey,j=i+1;
		while(j<b){
			if(compareIndices(ar,j,i)<0)
				insto(ar,j,i++);
			j++;
		}
	}
	function grlmbl(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<=0)rswap(ar,p++,i++);
			else rswap(ar,p++,j++);
		}
		if(i>p)while(i<m)rswap(ar,p++,i++);
		return j;
	}
	function grlmblRev(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<0)rswap(ar,p++,i++);
			else rswap(ar,p++,j++);
		}
		if(i>p)while(i<m)rswap(ar,p++,i++);
		return j;
	}
	function grlblm(ar,a,m,b,t,p,bLen){
		let b1=b-(b-m-1)%bLen-1,i=a+bLen,j=a,key=t-1,lCount=(m-i)/bLen|0,bCount=(b1-i)/bLen|0,l=-1,r=lCount-1;
		mts(ar,p,m-bLen,a,bLen);
		instoBW(ar,t,t+lCount-1);
		let mKey=blslsrt(ar,i,t,1,bLen-1,lCount,bCount,bLen);
		let frag=subarray.LEFT;
		while(l<lCount&&r<bCount){
			if(frag==subarray.LEFT){
				do{
					j+=bLen;
					l++;
					key++;
				}while(l<lCount&&grlgetsub(ar,key,mKey)==subarray.LEFT);
				if(l==lCount){
					i=grlmbl(ar,i,j,b,i-bLen);
					mwbr(ar,i-bLen,i,b,p,bLen);
				}else i=grlmbl(ar,i,j,j+bLen-1,i-bLen);
				frag=subarray.RIGHT;
			}else{
				do{
					j+=bLen;
					r++;
					key++;
				}while(r<bCount&&grlgetsub(ar,key,mKey)==subarray.RIGHT);
				if(r==bCount){
					shft(ar,i-bLen,i,b);
					msw(ar,p,b-bLen,bLen);
				}else i=grlmblRev(ar,i,j,j+bLen-1,i-bLen);
				frag=subarray.LEFT;
			}
		}
		grlsrtkys(ar,t+bCount,p,mKey);
	}
	function grlblmwob(ar,a,m,b,t,bLen){
		let a1=a+(m-a)%bLen,b1=b-(b-m)%bLen,i=a,j=a1,key=t,lCount=(m-j)/bLen+1|0,bCount=(b1-j)/bLen+1|0,l=0,r=lCount;
		let mKey=blslsrt(ar,j,t,0,0,lCount-1,bCount-1,bLen);
		let frag=subarray.LEFT;
		while(l<lCount&&r<bCount){
			let next=grlgetsub(ar,key++,mKey);
			if(next==frag){
				if(frag==subarray.LEFT)l++;
				else r++;
				i=j;
			}else{
				let m2=j,b2=j+bLen,k;
				if(frag==subarray.LEFT){
					while(i<m2&&m2<b2){
						if(compareIndices(ar,i,m2)>0){
							k=lbs(ar,m2+1,b2,ar[i]);
							rot(ar,i,m2,k);
							i+=k-m2;
							m2=k;
						}else i++;
					}
				}else{
					while(i<m2&&m2<b2){
						if(compareIndices(ar,i,m2)>=0){
							k=rbs(ar,m2+1,b2,ar[i]);
							rot(ar,i,m2,k);
							i+=k-m2;
							m2=k;
						}else i++;
					}
				}
				if(i<m2){
					if(next==subarray.LEFT)l++;
					else r++;
				}else{
					if(frag==subarray.LEFT)l++;
					else r++;
					frag=next;
				}
			}
			j+=bLen;
		}
		if(l<lCount)ipmBW(ar,a,b1,b);
		grlsrtkyswob(ar,t+bCount-1,mKey);
	}
	function smtm(ar,a,m,b,p){
		if(ckbd(ar,a,m,b)){
			a=rbs(ar,a,m-1,ar[m]);
			mwb(ar,a,m,b,p);
		}
	}
	function smtmBW(ar,a,m,b,p){
		if(ckbd(ar,a,m,b)){
			b=lbs(ar,m+1,b,ar[m-1]);
			mwbBW(ar,a,m,b,p);
		}
	}
	function smtblm(ar,a,m,b,t,p,bLen){
		if(ckbd(ar,a,m,b)){
			let n=rbs(ar,a,m-1,ar[m]);
			b=lbs(ar,m+1,b,ar[m-1]);
			if(ckrbd(ar,n,m,b)){
				if(m-n<=bLen||b-m<=bLen){
					if(b-m<m-n)mwbBW(ar,n,m,b,p);
					else mwb(ar,n,m,b,p);
				}else{
					n-=(n-a)%bLen;
					grlblm(ar,n,m,b,t,p,bLen);
				}
			}
		}
	}
	function smtblmwob(ar,a,m,b,t,bLen){
		if(ckbd(ar,a,m,b)){
			a=rbs(ar,a,m-1,ar[m]);
			if(m-a<=bLen)ipm(ar,a,m,b);
			else grlblmwob(ar,a,m,b,t,bLen);
		}
	}
	function smtipm(ar,a,m,b){
		if(csrt(ar,a,m,b))ipmBW(ar,a,m,b);
	}
	function rbuf(ar,a,m,b){
		let rPos=lbs(ar,m,b,ar[a]);
		rot(ar,a,m,rPos);
		let dist=rPos-m;
		a+=dist;
		m+=dist;
		let a1=a+(m-a)/2|0;
		rPos=lbs(ar,m,b,ar[a1]);
		rot(ar,a1,m,rPos);
		dist=rPos-m;
		a1+=dist;
		m+=dist;
		mwob(ar,a,a1-dist,a1);
		mwob(ar,a1,m,b);
	}
	function rbufBW(ar,a,m,b){
		let rPos=rbs(ar,a,m,ar[b-1]);
		rot(ar,rPos,m,b);
		let dist=m-rPos;
		b-=dist;
		m-=dist;
		let b1=m+(b-m)/2|0;
		rPos=rbs(ar,a,m,ar[b1-1]);
		rot(ar,rPos,m,b1);
		dist=m-rPos;
		b1-=dist;
		m-=dist;
		mwob(ar,b1,b1+dist,b);
		mwob(ar,a,m,b1);
	}
	function ipms(ar,a,b){
		buildRuns(ar,a,b);
		let l=b-a;
		for(let i,j=minRun;j<l;j*=2){
			for(i=a;i+2*j<=b;i+=2*j)smtipm(ar,i,i+j,i+2*j);
			if(i+j<b)smtipm(ar,i,i+j,b);
		}
	}
	function grladswob(ar,a,b,keys,ideal,bwBuf){
		let l=b-a,bLen;
		for(bLen=minVal(keys,minRun);2*bLen<=keys;bLen*=2);
		let tLen=keys-bLen;
		let i,j=minRun,t,p,a1,b1;
		if(bwBuf){
			p=b-bLen;a1=a;b1=p-tLen;t=b1;
		}else{
			p=a+tLen;a1=p+bLen;b1=b;t=a;
		}
		buildRuns(ar,a1,b1);
		while(j<=bLen&&j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtm(ar,i,i+j,i+2*j,p);
			if(i+j<b1)
				smtmBW(ar,i,i+j,b1,p);
			j*=2;
		}
		if(bLen/2>=minRun&&bLen/2>=(keys+1)/2){
			binins(ar,p,p+bLen|0);
			bLen/=2;
			tLen=keys-bLen|0;
			p+=bLen|0;
		}
		bLen|=0
		while(tLen>=2*j/bLen-1&&j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtblm(ar,i,i+j,i+2*j,t,p,bLen);
			if(i+j<b1){
				if(b1-(i+j)>bLen)smtblm(ar,i,i+j,b1,t,p,bLen);
				else smtmBW(ar,i,i+j,b1,p);
			}
			j*=2;
		}
		binins(ar,p,p+bLen);
		tLen=keys-keys%2;
		while(j<l){
			bLen=2*j/tLen;
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtblmwob(ar,i,i+j,i+2*j,t,bLen);
			if(i+j<b1){
				if(b1-(i+j)>bLen)smtblmwob(ar,i,i+j,b1,t,bLen);
				else smtipm(ar,i,i+j,b1);
			}
			j*=2;
		}
		if(bwBuf){
			a=rbs(ar,a,b1,ar[b1]);
			if(keys>=ideal/2)rbufBW(ar,a,b1,b);
			else mwob(ar,a,b1,b);
		}else{
			b=lbs(ar,a1,b,ar[a1-1]);
			if(keys>=ideal/2)rbuf(ar,a,a1,b);
			else mwob(ar,a,a1,b);
		}
	}
	function grlasd(ar,a,b){
		let l=b-a;
		if(l<31)return binins(ar,a,b);
		if(l<63){
			minRun=(l+1)/2|0;
			buildRuns(ar,a,b);
			let m=a+minRun;
			if(ckbd(ar,a,m,b))
				rbufBW(ar,a,m,b);
			return;
		}
		for(minRun=l;minRun>=32;minRun=(minRun+1)/2);
		minRun|=0;
		let bLen;
		for(bLen=minRun;bLen*bLen<l;bLen*=2);
		let tLen=l/bLen-2,ideal=tLen+bLen;
		let bwBuf;
		let rRun=burnBW(ar,b,ideal),lRun=0;
		if(rRun==ideal)bwBuf=true;
		else{
			lRun=burn(ar,a,ideal);
			if(lRun==ideal)bwBuf=false;
			else bwBuf=(rRun<16&&lRun<16)||rRun>=lRun;
		}
		let keys=bwBuf?fkysBW(ar,a,b,rRun,ideal):fkys(ar,a,b,lRun,ideal);
		if(keys<ideal){
			if(keys==1)return;
			else if(keys<=4)ipmSort(ar,a,b);
			else grladswob(ar,a,b,keys,ideal,bwBuf);
			return;
		}
		let i,j=minRun,
			t,p,a1,b1;
		if(bwBuf){
			p=b-bLen;a1=a;b1=p-tLen;t=b1;
		}
		else{
			p=a+tLen;a1=p+bLen;b1=b;t=a;
		}
		buildRuns(ar,a1,b1);
		while(j<=bLen&&j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtm(ar,i,i+j,i+2*j,p);
			if(i+j<b1)
				smtmBW(ar,i,i+j,b1,p);
			j*=2;
		}
		while(j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtblm(ar,i,i+j,i+2*j,t,p,bLen);
			if(i+j<b1){
				if(b1-(i+j)>bLen)
					smtblm(ar,i,i+j,b1,t,p,bLen);
				else smtmBW(ar,i,i+j,b1,p);
			}
			j*=2;
		}
		binins(ar,p,p+bLen);
		if(bwBuf){
			a=rbs(ar,a,b1,ar[b1]);
			rbufBW(ar,a,b1,b);
		}else{
			b=lbs(ar,a1,b,ar[a1-1]);
			rbuf(ar,a,a1,b);
		}
	}
	grlasd(array,0,len);
	return[5,1]
}
function introSort(){
	let array=[...arr];
	const flbt=a=>floor(log(a)/log(2));
	function gm3(ar,a,m,b){
		if(compareIndices(ar,a,m)<0){
			if(compareIndices(ar,m,b)<0)rswap(ar,a,m);
			else if(compareIndices(ar,a,b)<0)rswap(ar,a,b);
		}else if(compareIndices(ar,a,b)<0)return ar[a];
		else if (compareIndices(ar,m,b)<0)rswap(ar,a,b);
		else rswap(ar,a,m);
		return ar[a];
	}
	function m3(ar,a,m,b){
		if(compareIndices(ar,b,a)<0)rswap(ar,a,b);
		if(compareIndices(ar,m,b)<0)rswap(ar,m,a);
		if(compareIndices(ar,b,m)<0)rswap(ar,b,m);
		return ar[m];
	}
	function par(a,lo,hi,x){
		let i=lo,j=hi;
		while(1){
			while(compareValues(a[i],x)<0)i++;
			do j--;while(compareValues(x,a[j])<0);
			if(i>=j)return i;
			rswap(a,i++,j);
		}
	}
	function sort(a,lo,hi,d){
		while(hi-lo>16){
			if(d==0)return heapSort(a,lo,hi,true);
			let p=par(a,lo,hi,m3(a,lo,lo+(hi-lo)/2|0,hi-1));
			sort(a,p,hi,--d);
			hi=p;
		}
	}
	sort(array,0,len,2*flbt(len));
	insertSort(array,0,len);
	return[5,1]
}
function testSort(){
	let array=[...arr];
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
class Shuffles{
	swap(a,f,t){
		f|=0;t|=0;
		let o=a[f];a[f]=a[t];a[t]=o;
		this.steps.push(["swap",f,t])
	}
	write(a,i,v,aux){
		i|=0;v|=0;
		a[i]=v;
		if(aux)return;
		this.steps.push(["set",i,v])
	}
	reversal(a,s,l){
		if(l-s>0)
			for(let i=s,j=l-1;i<j;i++,j--)
				this.swap(a,j,i);
	}
	arraycopy(s,sp,d,dp,l){
		let b=s!=d||dp<sp;
		let st=b?0:l-1,e=b?l:-1,dr=b?1:-1;
		for(let i=st;i!=e;i+=dr)
			this.write(d,dp+i,s[sp+i]);
	}
	customFunc(f,args){
		this.steps.push(["custom",btoa("("+f+")"),...args])
	}
	constructor(){
		this.steps=[];
	}
	shuffles(a,s,e,type){
		let aux,tmp,i,j,k,b,c,d,f,g,h,l,m,n,o,p,q,r,t,u,v,w,x,y,z;
		switch(type){
		case 0://random
			this.shuffle(a,s,e);
		break;
		case 1://reverse
			this.reversal(a,s,e);
		break;
		case 2://almost
			for(let i=0;i<maxVal(e/20|0,1);i++)
				this.swap(a,random()*e,random()*e);
		break;
		case 3:break;//sorted
		case 4://naive
			for(let i=s;i<e;i++)
				this.swap(a,i,random()*e);
		break;
		case 5://shuffle tail
			aux=new Array(e);
			i=0,j=0,k=0;
			while(i<e){
				if(random()<1/7)this.write(aux,k++,a[i++],true);
				else this.write(a,j++,a[i++]);
			}
			this.arraycopy(aux,0,a,j,k);
			this.shuffle(a,j,e);
		break;
		case 6://shuffle head
			aux=new Array(e);
			i=e-1,j=e-1,k=0;
			while(i>=0){
				if(random()<1/7)this.write(aux,k++,a[i--],true);
				else this.write(a,j--,a[i--]);
			}
			this.arraycopy(aux,0,a,0,k);
			this.shuffle(a,0,j);
		break;
		case 7://Shifted Element
			i=random()*e|0;
			j=random()*e|0;
			if(j<i){
				this.customFunc(IndexRots.holyGriesMills,[j,i,i+1])
				IndexRots.holyGriesMills(a,j,i,i+1);
			}else{
				this.customFunc(IndexRots.holyGriesMills,[i,i+1,j])
				IndexRots.holyGriesMills(a,i,i+1,j);
			}
		break;
		case 8://Noisy
			j=maxVal(4,sqrt(e)/2|0);
			for(i=0;i+j<=e;i+=random()*(j-1)+1)
				this.shuffle(a,i,i+j);
			this.shuffle(a,i,e);
		break;
		case 9://Shuffled Odds
			for(let i=1;i<e;i+=2)
				this.swap(a,i,(random()*(e-i)/2|0)*2+i);
		break;
		case 10://Final Merge Pass
			c=2;
			k=0;
			t=new Array(e);
			for(let j=0;j<c;j++)
				for(let i=j;i<e;i+=c)
					this.write(t,k++,a[i],true);

			for(let i=0;i<e;i++)
				this.write(a,i,t[i],false);
		break;
		}
	}
	sort(a,s,e){
		let mn=a[s],mx=mn;
		for(let i=s+1;i<e;i++){
			if(a[i]<mn)mn=ar[i];
			else if(a[i]>mx)mx=a[i];
		}
		let sz=mx-mn+1;
		let holes=new Array(sz);
		for(let i=s;i<e;i++)
			this.write(holes,a[i]-mn,holes[a[i]-mn]+1,true);
		for(let i=0,j=s;i<sz;i++){
			while(holes[i]>0){
				this.write(holes,i,holes[i]-1,true);
				this.write(a,j,i+mn,false);
				j++;
			}
		}
	}
	shuffle(a,s,e){
		for(let i=s;i<e;i++)
			this.swap(a,i,random()*(e-i)+i);
	}
	start(a,t){
		this.shuffles([...a],0,a.length,t);
		return this.steps;
	}
}
let shuf=new Shuffles()
function s(m=0,i=0){
	arr=create(count).sort((a,b)=>a-b);
	let stp=shuf.start(arr,i),tck=0;
	swaps=0;writes=0;
	let shuffling=setInterval(()=>{
		tck++%5==0&&display(arr)
		if(stp.length){
			canskip=0
			names.innerText="Shuffling...";
			inputdisplay.innerText=""
			let c=stp.shift()
			switch(c[0]){
				case"swap":swap(arr,c[1],c[2],1);break;
				case"set":write(arr,c[1],c[2]);mark(c[1]);break;
				case"custom":eval(atob(c[1]))(arr,...c.splice(2,1/0));break;
			}
		}else{
			markarray.checked=0;
			clearInterval(shuffling);
			canskip=1
			names.innerText="currently frozen/crashed";
			setTimeout(()=>{
				names.innerText=sn[m][0]+" ("+(m+1)+"/"+Object.keys(sn).length+")";
				inputdisplay.innerText=inputs[i]
				rdisp([...sn[m][1](),function(){
					didskip=0
					display(arr)
					let z=-1,y=setInterval(()=>{
						if(z>=len){
							clearInterval(y);
							setTimeout(()=>{
								if(!loopsort.checked){
									let snl=Object.keys(sn).length
									if(++m==snl){
										if(queue==null)
											i++;
										i%=Object.keys(inputs).length
										m%=snl
									}
								}
								if(queue==null){
									s(m,i)
								}else{
									s(queue,i)
									queue=null;
									nextsort.innerText="Next: ...";
								}
							},3e2)
						}
						for(let n=0;n<len*.04;n++){
							mark(++z+1,"lime")
							ctx.fillRect(z*bw,count-arr[z],bw,arr[z])
						}
					},1e3/50)
				}])
			},5);
			display(arr)
		}
	})
}
function set(v){
	sn.push(v)
}
function get(n,cs=0){
	for(let i=0;i<sn.length;i++){
		let v=sn[i][0]
		if(v.match(n))return i
	}
	if(n.trim().length==0)return 0;
	n=cs?n:n.toLowerCase();
	let offset=[];
	for(let i=0;i<sn.length;i++){
		let v=cs?sn[i][0]:sn[i][0].toLowerCase();
		offset[i]=[0,i];
		if(n.match(v))return i
		for(let j=0;j<n.length;j++)
			if(n[j]==v[j])
				offset[i][0]++
		offset[i][0]/=n.length
		offset[i][0]*=100;
	}
	return offset.sort((a,b)=>b[0]-a[0])[0][1]
}
set(["Iterative Bitonic Sort",iterativeBitonicSort])
set(["Batcher's Bitonic Sort",batcherBitonicSort])
set(["Iterative Bose-Nelson Sort",iterativeBoseNelsonSort])
set(["Recursive Bose-Nelson Sort",recursiveBoseNelsonSort])
set(["Crease Sort",creaseSort])
set(["Iterative Diamond Sort",iterativeDiamondSort])
set(["Recursive Diamond Sort",recursiveDiamondSort])
set(["Fold",foldSort])
set(["Batcher's Merge-Exchange Sort",batcherMergeExchangeSort])
set(["Recursive Odd-Even Merge Sort",recursiveOddEvenMergeSort])
set(["Iterative Pairwise Merge Sort",iterativePairwiseMergeSort])
set(["Recursive Pairwise Merge Sort",recursivePairwiseMergeSort])
set(["Iterative Weave Sort",iterativeWeaveSort])
set(["Recursive Weave Sort",recursiveWeaveSort])
set(["LSD Radix Sort",LSDRadixSort])
set(["In-Place LSD Radix Sort",inPlaceLSDRadixSort])
set(["In-Place MSD Radix Sort",inPlaceMSDRadixSort])
set(["L/MSD Radix Sort",LMSDRadixSort])
set(["Index Sort",indexSort])
set(["Bubble Sort",bubbleSort])
set(["Circloid Sort",circloidSort])
set(["Comb Sort",combSort])
set(["Complete Graph Sort",completeGraphSort])
set(["Cocktail Shaker Sort",cocktailShakerSort])
set(["Gnome Sort",gnomeSort])
set(["Left/Left Quick Sort",LLQuickSort])
set(["Left/Right Quick Sort",LRQuickSort])
set(["Odd-Even Sort",oddEvenSort])
set(["Stooge Sort",stoogeSort])
set(["Slope Sort",slopeSort])
set(["Shell Sort",shellSort])
set(["Recursive Shell Sort",recursiveShellSort])
set(["Andrey Astrelin's In-Place Merge Sort",andreySort])
set(["Block-Swap Merge Sort",blockSwapMergeSort])
set(["In-Place Merge Sort",inPlaceMergeSort])
set(["Rotate Merge Sort",rotateMergeSort])
set(["Strand Sort",strandSort])
set(["Weaved Merge Sort",weavedMergeSort])
set(["Pancake Sort",pancakeSort])
set(["Max Heap Sort",maxHeapSort])
set(["Min Heap Sort",minHeapSort])
set(["Cycle Sort",cycleSort])
set(["Fun Sort",funSort])
set(["Asteraceae Sort",asteraceaeSort])
set(["Awkward Sort",awkwardSort])
set(["Chinotto Sort",chinottoSort])
set(["Circle Merge Sort",circleMergeSort])
set(["Clamber Sort",clamberSort])
set(["Cocktail Grate Sort",cocktailGrateSort])
set(["Cocktail Push Sort",cocktailPushSort])
set(["Dandelion Sort",dandelionSort])
set(["Float Sort",floatSort])
set(["Iterative Quick Sort",iterativeQuickSort])
set(["Index Quick Sort",indexQuickSort])
set(["Pseudo Heap Sort",pseudoHeapSort])
set(["Iterative Circle Sort",iterativeCircleSort])
set(["Recursive Circle Sort",recursiveCircleSort])
set(["Left/Left Quick Sort (Middle Pivot)",LLQuickSortMiddlePivotSort])
set(["Push Sort",pushSort])
set(["Reflection Sort",reflectionSort])
set(["Split Center Sort",splitCenterSort])
set(["Wiggle Sort",wiggleSort])
set(["Zipper Sort",zipperSort])
set(["Pairwise Circle Sort",pairwiseCircleSort])
set(["Iterative Sinking Merge Sort",iterativeSinkingMergeSort])
set(["Recursive Sinking Merge Sort",recursiveSinkingMergeSort])
set(["Cocktail Shell Sort",cocktailShellSort])
set(["Index Merge Sort",indexMergeSort])
set(["Mob Merge Sort",mobMergeSort])
set(["Modulo Merge Sort",moduloMergeSort])
set(["Split-16 Merge Sort",split16MergeSort])
set(["Cube Root Quick Sort",cbrtQuickSort])
set(["Apollyon Sort",apollyonSort])
set(["Optimized Pancake Sort",optimizedPancakeSort])
set(["Magnetica Quick Sort",magneticaQuickSort])
set(["Cocktail Peel Sort",cocktailPeelSort])
set(["Ecolo Sort",ecoloSort])
set(["Fall Sort",fallSort])
set(["Heavy Heap Sort",heavyHeapSort])
set(["Sandpaper Sort",sandPaperSort])
set(["Recursive Burning Sort",recursiveBurningSort])
set(["Corrupt Sort",corruptSort])
set(["Circle Halver Sort",circleHalverSort])
set(["Iterative Pairwise Sort",iterativePairwiseSort])
set(["Recursive Pairwise Sort",recursivePairwiseSort])
set(["Iterative [4,4] Van Voorhis Sort",iterativeVanVoorhisSort])
set(["Rotate LSD Radix Sort",rotateLSDRadixSort])
set(["Dig Sort",digSort])
set(["Cityscape Sort",cityscapeSort])
set(["Iterative Cleric Sort",iterativeClericSort])
set(["Recursive Cleric Sort",recursiveClericSort])
set(["Debris Sort",debrisSort])
set(["Californium Sort",californiumSort])
set(["Evub Sort",evubSort])
set(["Iterative Firing Squad Sort",iterativeFiringSquadSort])
set(["Recursive Firing Squad Sort",recursiveFiringSquadSort])
set(["Ford Sort",fordSort])
set(["Future Sort",futureSort])
set(["Iterative Pop Sort",iterativePopSort])
set(["Jump Down Sort",jumpDownSort])
set(["Monolithic Clurge Sort",monolithicClurgeSort])
set(["Pairwise Comb Sort",pairwiseCombSort])
set(["Pancake Quick Sort",pancakeQuickSort])
set(["Pop Pop Sort",popPopSort])
set(["Swapless Push Sort",swaplessPushSort])
set(["Rebound Sort",reboundSort])
set(["Rubble Sort",rubbleSort])
set(["Search Sort",searchSort])
set(["Selection Sort",selectionSort])
set(["Iterative Shircle Sort",iterativeShircleSort])
set(["Recursive Shircle Sort",recursiveShircleSort])
set(["X Pattern Sort",XSort])
set(["Block Shell Sort",blockShellSort])
set(["Rotate MSD Radix Sort",rotateMSDRadixSort])
set(["Flash Sort",flashSort])
set(["American Flag Sort",americanFlagSort])
set(["Iterative 3-Smooth Comb Sort",iterative3SmoothCombSort])
set(["Recursive 3-Smooth Comb Sort",recursive3SmoothCombSort])
set(["Binary Double Insertion Sort",binaryDoubleInsertionSort])
set(["Ecta Sort",ectaSort])
set(["Flan Sort",flanSort])
set(["Circular Grail Sort",circularGrailSort])
set(["Poplar Heap Sort",poplarHeapSort])
set(["Adaptive Grail Sort",adaptiveGrailSort])
set(["Intro Sort",introSort])
//set(["test Sort",testSort])
sn.sort((a,b)=>a[0].localeCompare(b[0]))
const inputs={
	0:"Random",
	1:"Reversed",
	2:"Slightly",
	3:"Sorted",
	4:"Naive Random",
	5:"Shuffled Tail",
	6:"Shuffled Head",
	7:"Shifted Elements",
	8:"Noisy",
	9:"Shuffled Odds",
	10:"Final Merge Pass",
}
function hold(e){
	["touchstart","mousedown"].forEach(m=>e.addEventListener(m,v=>e.style.opacity=.5));
	["touchend","mouseup","mouseout"].forEach(m=>e.addEventListener(m,v=>e.style.opacity=1));
}
function appendTo(parent,text,func){
	let a=document.createElement("div");
	a.className="selectbtn";
	a.textContent=text;
	hold(a)
	a.onclick=function(){
		queue=get(text)
		nextsort.innerText="Next: "+text;
		cancel=1;
		setTimeout(()=>cancel=0);
	}
	parent.appendChild(a)
}
sn.forEach(e=>{
	let name=e[0].toLowerCase();
	appendTo(sortsholder,e[0]);
	if(name.match("merge"))appendTo(mergesortsholder,e[0]);
	if(name.match("quick"))appendTo(quicksortsholder,e[0]);
	if(name.match("recur"))appendTo(recursortsholder,e[0]);
	if(name.match("itera"))appendTo(itersortsholder,e[0]);
	if(name.match("cocktail"))appendTo(cocktailsortsholder,e[0]);
})
Array.from(document.querySelectorAll("div.topicname")).map((e,i)=>{
	let ch=document.querySelectorAll("div.btnholder")[i]
	e.onclick=function(){
		if(cancel)return;
		let h=parseFloat(window.getComputedStyle(ch).getPropertyValue("opacity"))==1
		ch.style.height=(h?0:300)+"px";
		ch.style.opacity=h?0:1;
		ch.style.padding=(h?0:3)+"px 0px";
		document.querySelectorAll("div.space")[i].style.display=h?"none":"block";
	}
})
let req=get("")
if(Object.values(sn).map(e=>e[0].toLowerCase()).indexOf("test sort")>=0)req=get("test")
s(req)
/*
arr=create(count)
let perf=[],ix=0,jd=
setInterval(()=>{
	for(let fv=0;fv<len;fv++)swap(arr,fv,random()*len|0);
	sn[ix][1]();
	let r=logs.splice(0,1/0).length;
	perf.push([r/count,sn[ix++][0]])
	if(ix>=sn.length){
		clearInterval(jd)
		perf.sort((a,b)=>b[0]-a[0])
		perf.map(e=>e.join(" "))
		console.log(perf.join("\n"))
	}
})
*/
		</script>
	</body>
</html>