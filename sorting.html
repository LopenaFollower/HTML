<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport"content="width=device-width,initial-scale=1">
		<style>
			body{
				overflow-y:scroll;
				padding:0;
				margin:0 auto;
				zoom:.6;
				user-select:none;
			}
			div.holder{display:flex}
			#cvs{
				background:#000;
				aspect-ratio:auto;
			}
			td.lfa{text-align:right}
			td,#names,.topicname,#nextsort{
				font-family:monospace;
				color:#fff;
			}
			td{
				white-space:nowrap;
				overflow:none;
				text-overflow:clip;
			}
			legend{
				color:#fff;
				font:5px;
			}
			fieldset{width:fit-content}
			div.btnholder{
				transition-timing-function:linear;
				transition-duration:.2s;
				border-radius:4px;
				background:#1d2a35;
				border:3px black solid;
				height:0px;
				opacity:0;
				margin:0 5;
				overflow:scroll;
				width:fit-content;
			}
			div.selectbtn{
				color:#fff;
				background:#04aa6d;
				border-radius:10px;
				padding:3px;
				margin:3px;
				border:1px black solid;
			}
			div.topicname{
				margin:5px;
				border:2px dashed grey;
				padding:2px;
				text-align:center;
			}
			div.space{display:none;}
		</style>
	</head>
	<body bgcolor=#0e151a>
		<br>
		<span id=names></span>
		<div class=holder>
			<fieldset>
				<legend>Options</legend>
				<table>
					<tr>
						<td id=m0>bar</td>
						<td><input type=checkbox oninput='m0.innerText=dtype.checked?"bar":"pixel"'id=dtype checked/></td>
					</tr>
					<tr>
						<td>loop</td>
						<td><input type=checkbox id=loopsort /></td>
					</tr>
					<tr>
						<td>pause</td>
						<td><input type=checkbox id=pause /></td>
					</tr>
					<tr>
						<td>mark</td>
						<td><input type=checkbox id=markarray checked oninput='userinp=this.checked'/></td>
					</tr>
					<tr>
						<td>next shuffle</td>
						<td><input type=checkbox id=nextshuffle /></td>
					</tr>
					<tr>
						<td>zoom (25-200)</td>
						<td><input style='width:40px'value=60 type=number oninput='if(this["value"]>=25&&this["value"]<=200)document.body.style.zoom=this["value"]/100'/></td>
					</tr>
					<tr>
						<td>skip</td>
						<td><button style='width:40px'onclick='canskip&&arr.sort((a,b)=>a-b)&&(didskip=true)'>btn</button></td>
					</tr>
				</table>
			</fieldset>
			<fieldset>
				<legend>Info</legend>
				<table>
					<tr>
						<td>Elements</td>
						<td class=lfa id=elementcount></td>
					</tr>
					<tr>
						<td>FPS</td>
						<td class=lfa id=fpsdisplay>60</td>
					</tr>
					<tr>
						<td>Swaps</td>
						<td class=lfa id=swapdisplay>0</td>
					</tr>
					<tr>
						<td>Writes</td>
						<td class=lfa id=writedisplay>0</td>
					</tr>
					<tr>
						<td>Input</td>
						<td class=lfa id=inputdisplay></td>
					</tr>
					<tr>
						<td>Input</td>
						<td class=lfa id=inputdisplay2></td>
					</tr>
				</table>
			</fieldset>
			<fieldset>
				<legend>Debug</legend>
				<table>
					<tr>
						<td>Frame</td>
						<td class=lfa id=framecount></td>
					</tr>
					<tr>
						<td>Rate</td>
						<td class=lfa id=framerate></td>
					</tr>
					<tr>
						<td>Sorted</td>
						<td class=lfa id=finalresult></td>
					</tr>
					<tr>
						<td>Duration</td>
						<td class=lfa id=duration></td>
					</tr>
					<tr>
						<td>Estim Finish</td>
						<td class=lfa id=estimated></td>
					</tr>
					<tr>
						<td>Rate</td>
						<td class=lfa><input type=number value=1 id=rate style='width:60px'oninput='let tv=parseFloat(this["value"]);if(tv>=-50&&tv<=500)atr=tv'/></td>
					</tr>
					<tr>
						<td>Fixed Rate</td>
						<td class=lfa><input type=checkbox id=fixedrate /></td>
					</tr>
				</table>
			</fieldset>
		</div>
		<div class=holder>
			<div>
				<canvas id=cvs></canvas>
				<div id=nextsort>Next: ...</div>
			</div>
			<div>
				<div class=topicname>Shuffles<div class=space>&nbsp;</div><div class=holder><div id=shufflesholder class=btnholder></div></div></div><br>
				<div class=topicname>Sorts<div class=space>&nbsp;</div><div class=holder><div id=sortsholder class=btnholder></div></div></div>
				<div class=topicname>Merge<div class=space>&nbsp;</div><div class=holder><div id=mergesortsholder class=btnholder></div></div></div>
				<div class=topicname>Quick<div class=space>&nbsp;</div><div class=holder><div id=quicksortsholder class=btnholder></div></div></div>
				<div class=topicname>Cocktail<div class=space>&nbsp;</div><div class=holder><div id=cocktailsortsholder class=btnholder></div></div></div>
				<div class=topicname>Binary<div class=space>&nbsp;</div><div class=holder><div id=binarysortsholder class=btnholder></div></div></div>
				<div class=topicname>Recursive<div class=space>&nbsp;</div><div class=holder><div id=recursortsholder class=btnholder></div></div></div>
				<div class=topicname>Iterative<div class=space>&nbsp;</div><div class=holder><div id=itersortsholder class=btnholder></div></div></div>
			</div>
		</div>
		<br>
		<script>
window.onresize=resize;window.onblur=function(){pause.checked=1};window.onfocus=function(){pause.checked=0}
const count=512,ctx=cvs.getContext("2d"),logs=[],sn=[],len=count,{random,ceil,floor,round,sqrt,cbrt,log,abs,pow,clz32,sin,sign,PI}=Math;
let userinp=1,swaps=0,writes=0,queue,queue2,atr,curDur=Date.now(),dcd=false,cancel=0,bw=(maxVal(window.innerWidth,window.innerHeight)/minVal(window.innerWidth,window.innerHeight)).toFixed(2),arr,canskip=1,canq2=0,didskip=0;
function resize(){bw=(maxVal(window.innerWidth,window.innerHeight)/minVal(window.innerWidth,window.innerHeight)).toFixed(2);let horizontal=maxVal(window.innerWidth,window.innerHeight),vertical=minVal(window.innerWidth,window.innerHeight);Array.from(document.querySelectorAll("td,legend")).map(e=>e.style.fontSize=horizontal/50+"px");names.style.fontSize=horizontal/50+"px";cvs.width=count*bw;cvs.height=count;cvs.style.width=horizontal*.75+"px";cvs.style.height=vertical*.75+"px";elementcount.innerText=count;}
resize()
const fps=(()=>{
	let el1=Date.now(),el2=Date.now(),frame=0,fps=60,rate=2;
	let update=()=>{
		if(Date.now()-el1<=1e3/rate)frame+=rate
		else{
			el1=Date.now();fps=frame
			if(fps<30)markarray.checked=0;if(fps>=55)markarray.checked=userinp;
			fpsdisplay.innerText=fps;frame=0
		}
		if(Date.now()-el2>=1e3/16){
			el2=Date.now();
			swapdisplay.innerText=swaps.toLocaleString()
			writedisplay.innerText=writes.toLocaleString()
			dcd&&(duration.innerText=((Date.now()-curDur)/1000).toFixed(1)+"s");
		}
		requestAnimationFrame(update)
	}
	requestAnimationFrame(update)
	return{g:()=>fps}
})();
const isSorted=a=>a.every((e,i)=>!i||a[i-1]<=e);
const rangeSorted=(a,s,e)=>a.every((v,i)=>!i||a[i-1]<=v||i>=e);
class Shuffles{
	constructor(){
		this.steps=[];
	}
	swap(a,f,t,aux){
		f|=0;t|=0;let o=a[f];a[f]=a[t];a[t]=o;
		if(aux)return;
		this.steps.push(["swap",f,t])
	}
	write(a,i,v,aux){
		i|=0;v|=0;a[i]=v;
		if(aux)return;
		this.steps.push(["set",i,v])
	}
	reversal(a,s,l,aux){
		if(l-s>0)
			for(let i=s,j=l-1;i<j;i++,j--)
				this.swap(a,j,i,aux);
	}
	arraycopy(s,sp,d,dp,l,aux){
		let b=s!=d||dp<sp,st=b?0:l-1,e=b?l:-1,dr=b?1:-1;
		for(let i=st;i!=e;i+=dr)
			this.write(d,dp+i,s[sp+i],aux);
	}
	multiSwap(a,p,t,aux){
		if(t-p>0)for(let i=p;i<t;i++)this.swap(a,i,i+1,aux);
		else for(let i=p;i>t;i--)this.swap(a,i,i-1,aux);
	}
	customFunc(f,args){
		this.steps.push(["custom",btoa("("+f+")"),...args])
	}
	siftDown(a,r,d,s,m,aux){
		let cv=m?-1:1;
		while(r<=d/2){
			let l=2*r;
			if(l<d&&compareIndices(a,s+l-1,s+l)==cv)l++;
			if(compareIndices(a,s+r-1,s+l-1)==cv){
				this.swap(a,s+r-1,s+l-1,aux)
				r=l;
			}else break;
		}
	}
	heapify(ar,lw,h,m,aux){
		let le=h-lw;
		for(let i=le/2;i>=1;i--)
			this.siftDown(ar,i,le,lw,m,aux)
	}
	shuffles(a,s,e,type){
		let aux,len,max,rot,sz,min,base,exp,mask,counts,mid,tmp=new Array(e),i,j,k,b,c,d,f,g,h,l,m,n,o,p,q,r,t,u,v,w,x,y,z;
		switch(type){
		case 0://random
			this.shuffle(a,s,e);
		break;
		case 1://reverse
			this.reversal(a,s,e);
		break;
		case 2://almost
			for(let i=0;i<maxVal(e/20|0,1);i++)
				this.swap(a,random()*e,random()*e);
		break;
		case 3://sorted
			this.sort(a,s,e)
		break;
		case 4://naive
			for(let i=s;i<e;i++)this.swap(a,i,random()*e);
		break;
		case 5://shuffle tail
			i=0,j=0,k=0;
			while(i<e)
				if(random()<1/7)this.write(tmp,k++,a[i++],true);
				else this.write(a,j++,a[i++]);
			this.arraycopy(tmp,0,a,j,k);
			this.shuffle(a,j,e);
		break;
		case 6://shuffle head
			i=0,j=0,k=0;
			while(i<e)
				if(random()<1/7)this.write(tmp,k++,a[i++],true);
				else this.write(a,j++,a[i++]);
			this.arraycopy(tmp,0,a,j,k);
			this.shuffle(a,j,e);
			for(let i=j-1;i>=0;i--)this.swap(a,(e-j+i)%e,(i)%e);
		break;
		case 7://Shifted Element
			while(i==j){i=random()*e|0;j=random()*e|0;}
			this.swap(a,i,j)
		break;
		case 8://Noisy
			j=maxVal(4,sqrt(e)/2|0);
			for(i=0;i+j<=e;i+=random()*(j-1)+1)this.shuffle(a,i,i+j);
			this.shuffle(a,i,e);
		break;
		case 9://Shuffled Odds
			for(let i=1;i<e;i+=2)this.swap(a,i,(random()*(e-i)/2|0)*2+i);
		break;
		case 10://Final Merge Pass
			c=2;k=0
			for(let j=0;j<c;j++)for(let i=j;i<e;i+=c)this.write(tmp,k++,a[i],true);
			for(let i=0;i<e;i++)this.write(a,i,tmp[i]);
		break;
		case 11://Shuffled Final Merge
			this.shuffle(a,s,e)
			m=e/2|0;
			this.sort(a,s,m)
			this.sort(a,m+1,e)
		break;
		case 12://Shuffled Half
			this.shuffle(a,s,e)
			this.sort(a,s,e/2|0)
		break;
		case 13://Partitioned 
			this.sort(a,s,e)
			this.shuffle(a,s,e/2|0)
			this.shuffle(a,e/2|0,e)
		break;
		case 14://Sawtooth
			c=4;k=0;
			for(let j=0;j<c;j++)for(let i=j;i<e;i+=c)this.write(tmp,k++,a[i],true);
			for(let i=0;i<e;i++)this.write(a,i,tmp[i]);
		break;
		case 15://Pipe Organ
			for(let i=0,j=0;i<e;i+=2)tmp[j++]=a[i];
			for(let i=1,j=e;i<e;i+=2)tmp[--j]=a[i];
			for(let i=0;i<e;i++)this.write(a,i,tmp[i]);
		break;
		case 16://Final Bitonic Pass
			this.reversal(a,0,e);
			for(let i=0,j=0;i<e;i+=2)tmp[j++]=a[i];
			for(let i=1,j=e;i<e;i+=2)tmp[--j]=a[i];
			for(let i=0;i<e;i++)this.write(a,i,tmp[i]);
		break;
		case 17://Interlaced
			this.arraycopy(a,0,tmp,0,e,true);
			l=1;r=e-1;
			for(let i=1;i<e;i++)
				if(i%2==0)this.write(a,i,tmp[l++]);
				else this.write(a,i,tmp[r--]);
		break;
		case 18://Double Layered
			for(let i=0;i<e/2;i+=2)this.swap(a,i,e-i-1);
		break;
		case 19://Final Radix Pass
			len=e;len-=e%2;mid=e/2;tmp=new Array(mid);
			for(let i=0;i<mid;i++)this.write(tmp,i,a[i],true);
			for(let i=mid,j=0;i<e;i++,j+=2){
				this.write(a,j,a[i]);
				this.write(a,j+1,tmp[i-mid]);
			}
		break;
		case 20://Real Final Radix
			base=10;c=2;min=minVal(a);max=maxVal(a);exp=1;p=0;
			while((max-min)/exp>=1&&p++<2){
				b=new Array(base).fill(0),o=new Array(e);
				for(n=0;n<e;n++)b[((a[n]-min)/exp)%base|0]++;
				for(n=1;n<base;n++)b[n]+=b[n-1];
				for(n=e-1;n>=0;n--)o[--b[((a[n]-min)/exp)%base|0]]=a[n];
				for(n=0;n<e;n++)this.write(a,n,o[n]);
				exp*=10;
			}
		break;
		case 21://Recursive Final Radix
			w=(a,p,l,g)=>{
				if(l<2)return;
				let m2=l%2;l-=m2;let mid=l/2|0,temp=new Array(mid);
				for(let i=p,j=0;i<p+g*mid;i+=g,j++)this.write(temp,j,a[i],true);
				for(let i=p+g*mid,j=p,k=0;i<p+g*l;i+=g,j+=2*g,k++){
					this.write(a,j,a[i]);
					this.write(a,j+g,temp[k]);
				}
				w(a,p,mid+m2,2*g);
				w(a,p+g,mid,2*g);
			}
			w(a,0,e,1);
		break;
		case 22://Half Rotation
			b=0,m=(e+1)/2|0;
			if(e%2==0)while(m<e)this.swap(a,b++,m++);
			else{
				tmp=a[b];
				while(m<e){
					this.write(a,b++,a[m]);
					this.write(a,m++,a[b]);
				}
				this.write(a,b,tmp);
			}
		break;
		case 23://Half Reversed
			this.reversal(a,0,e);
			this.reversal(a,e/4|0,e-e/4|0);
		break;
		case 24://Logarithmic Slopes
			for(let i=0;i<e;i++)this.write(tmp,i,a[i],true);
			for(let i=1;i<e;i++){
				let lg=log(i)/log(2)|0,pw=pow(2,lg),vl=tmp[2*(i-pw)+1];
				this.write(a,i,vl);
			}
		break;
		case 25://Heapified
			this.heapify(a,0,e,1)
		break;
		case 26://Triangular Heapified
			s=(a,e,r)=>{
				const trt=v=>sqrt((8*v+1)-1)/2|0;
				let t=a[r],ln=trt(r),l=r+ln+1,ri=l+1;
				while(l<e){
					if(ri>=e){
						if(compareValues(a[l],t)>0)this.write(a,r,a[l]);
						break;
					}
					let mx=compareIndices(a,l,ri)>=0?l:ri;
					if(compareValues(a[mx],t)>0){
						this.write(a,r,a[mx]);
						r=mx;ln=trt(r);l=r+ln+1;ri=l+1;
						continue;
					}
					break;
				}
				this.write(a,r,t);
			}
			for(let i=e-1;i>=0;i--)s(a,e,i);
		break;
		case 27://Circle Pass
			this.shuffle(a,0,e);
			n=1;
			for(;n<e;n*=2);
			let csrout=(a,o,i,e)=>{
				if(o==i)return;
				let h=i,l=o,m=(i-o)/2|0;
				while(o<i){
					if(i<e&&compareIndices(a,o,i)>0)this.swap(a,o,i);
					o++;i--;
				}
				csrout(a,l,l+m,e);
				if(l+m+1<e)csrout(a,l+m+1,h,e);
			}
			csrout(a,0,n-1,e);
		break;
		case 28://Final Pairwise Pass
			this.shuffle(a,0,e);
			tmp.fill(0)
			for(let i=1;i<e;i+=2)if(compareIndices(a,i-1,i)>0)this.swap(a,i-1,i);
			for(let m=0;m<2;m++){
				for(let k=m;k<e;k+=2)this.write(tmp,a[k],tmp[a[k]]+1,true);
				i=0,j=m;
				while(1){
					while(i<e&&tmp[i]==0)i++;
					if(i>=e)break;
					this.write(a,j,i);
					j+=2;
					this.write(tmp,i,tmp[i]-1,true);
				}
			}
		break;
		case 29://Recursive Reversal
			r=(ar,a,b)=>{
				if(b-a<2)return;
				this.reversal(ar,a,b-1);
				let m=(a+b)/2|0;
				r(ar,a,m);
				r(ar,m,b);
			}
			r(a,0,e+1);
		break;
		case 30://Gray Code Fractal
			r=(ar,a,b,d)=>{
				if(b-a<3)return;
				let m=(a+b)/2|0;
				if(d)this.reversal(ar,a,m-1);
				else this.reversal(ar,m,b-1);
				r(ar,a,m,0);
				r(ar,m,b,1);
			}
			r(a,0,e+1,0);
		break;
		case 31://Sierpinski Triangle
			t=(tm,a,b)=>{
				if(b-a<2)return;
				if(b-a==2)return tm[a+1]++;
				let h=(b-a)/3|0,t1=(a+a+b)/3|0,t2=(a+b+b+2)/3|0;
				for(let i=a;i<t1;i++)tm[i]+=h;
				for(let i=t1;i<t2;i++)tm[i]+=2*h;
				t(tm,a,t1);
				t(tm,t1,t2);
				t(tm,t2,b);
			}
			t(tmp.fill(0),0,e);
			aux=[...a];
			for(let i=0;i<e;i++)this.write(a,i,aux[tmp[i]]);
		break;
		case 32://Triangular
			tmp.fill(0);
			j=0,k=2;max=0;
			for(let i=1;i<e;i++,j++){
				if(i==k){
					j=0;k*=2;
				}
				tmp[i]=tmp[j]+1;
				if(tmp[i]>max)max=tmp[i];
			}
			counts=new Array(max+1).fill(0);			
			for(let i=0;i<e;i++)counts[tmp[i]]++;
			for(let i=1;i<counts.length;i++)counts[i]+=counts[i-1];
			for(let i=e-1;i>=0;i--)tmp[i]=--counts[tmp[i]];
			aux=[...a];
			for(let i=0;i<e;i++)this.write(a,i,aux[tmp[i]]);
		break;
		case 33://QuickSort Adversary
			for(let j=e-e%2-2,i=j-1;i>=0;i-=2,j--)this.swap(a,i,j);
		break;
		case 34://Grailsort Adversary
			rot=(ar,a,m,b)=>{
				this.reversal(ar,a,m-1);
				this.reversal(ar,m,b-1);
				this.reversal(ar,a,b-1);
			}
			p=(ar,a,b,bL)=>{
				let len=b-a,b1=b-len%bL,len1=b1-a,m=bL;
				if(len1<=2*bL)return;
				while(2*m<len)m*=2;
				m+=a;
				if(b1-m<bL)p(ar,a,m,bL);
				else{
					m=a+b1-m;
					rot(ar,m-(bL-2),b1-(bL-1),b1);
					this.multiSwap(ar,a,m);
					rot(ar,a,m,b1);
					m=a+b1-m;
					p(ar,a,m,bL);
					p(ar,m,b,bL);
				}
			}
			if(e<17)this.reversal(a,0,e-1);
			else{
				b=1;
				while(b*b<e)b*=2;
				n=(e-1)/b+1|0;k=b+n;
				this.shuffle(a,0,e);
				this.sort(a,0,k);
				this.reversal(a,0,k);
				this.sort(a,k,e);
				p(a,k,e,b);
			}
		break;
		case 35://Modulo
			for(let i=1;i<e;i++)if((i*2)%e!=i)this.swap(a,i,(i*2)%e);
		break;
		case 36://Quadratic
			y=x=>-(x**2)/(e/2|0)|0;
			for(k=0,i=-(e/2|0);i<e/2|0;i++,k++)this.write(a,k,(y(i)+e/2|0)*2)
			this.shuffle(a,0,e)
		break;
		case 37://Cubic
			y=x=>(1/(e/2)**2)*x**3|0;
			for(k=0,i=-(e/2|0);i<e/2|0;i++,k++)this.write(a,k,y(i)+e/2|0+1)
			this.shuffle(a,0,e)
		break;
		case 38://Bit Reversal
			len=1<<(log(e)/log(2)|0);
			p=len==e;tmp=[...a];
			for(let i=0;i<len;i++)a[i]=i;
			m=0;d=len>>1,b=d+(d>>1);			
			for(let i=1;i<len-1;i++){
				let j=d;
				for(let k=i,n=b;(k&1)==0;j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)this.swap(a,i,m);
			}
			if(!p){
				for(let i=len;i<e;i++)this.write(a,i,a[i-len]);
				aux=new Array(len).fill(0);
				for(let i=0;i<e;i++)aux[a[i]]++;
				for(let i=1;i<aux.length;i++)aux[i]+=aux[i-1];
				for(let i=e-1;i>=0;i--)this.write(a,i,--aux[a[i]]);
			}
			x=[...a];
			for(let i=0;i<e;i++)this.write(a,i,tmp[x[i]]);
		break;
		case 39://Random Blocks
			s=(ar,a,b,l)=>{
				for(let i=0;i<l;i++)this.swap(ar,(a+i)%e,(b+i)%e);
			}
			p=v=>{
				let l;
				for(l=1;l<<1<=v;l<<=1);
				return l;
			}
			c=e;b=p(sqrt(c)|0);c-=c%b;
			for(let i=0;i<c;i+=b)s(a,i,random()*((c-i)/b|0)*b+i,b);
		break;
		case 40://Block Reverse
			s=(ar,a,b,l)=>{
				for(let i=0;i<l;i++)this.swap(ar,(a+i)%e,(b+i)%e);
			}
			p=v=>{
				let l;
				for(l=1;l<<1<=v;l<<=1);
				return l;
			}
			c=e;b=p(sqrt(c)|0);c-=c%b;
			i=0,j=c-b;
			while(i<j){
				s(a,i,j,b);
				i+=b;j-=b;
			}
		break;
		case 41://Sine Wave
			n=e-1;c=2*PI/n
			for(let i=0;i<e;i++)this.write(a,i,maxVal(n*(sin(c*i)+1)/2|0,1));
			this.shuffle(a,0,e)
		break;
		case 42://Partial Merge
			this.shuffle(a,0,e)
			tmp=tmp.fill(2).map((e,i)=>e**++i)
			while(tmp.pop()>e/2);
			g=tmp[random()*tmp.length|0];i=0
			for(;i+g<e;i+=g)this.sort(a,i,i+g)
			if(i<e)this.sort(a,i,e)
		break;
		}
	}
	sort(a,s,e){
		let min=a[s],max=min;
		for(let i=s+1;i<e;i++)
			if(a[i]<min)min=a[i];
			else if(a[i]>max)max=a[i];
		let size=max-min+1,holes=new Array(size).fill(0);
		for(let i=s;i<e;i++)holes[a[i]-min]++
		for(let i=0,j=s;i<size;i++)while(holes[i]-->0)this.write(a,j++,i+min);
	}
	shuffle(a,s,e){
		for(let i=s;i<e;i++)this.swap(a,i,random()*(e-i)+i);
	}
	start(a,t){
		this.shuffles([...a],0,a.length,t);
		return this.steps;
	}
}
let shuf=new Shuffles()
function display(a){
	ctx.clearRect(0,0,cvs.width,cvs.height)
	ctx.fillStyle="#fff";
	for(let i=0;i<len;i++)ctx.fillRect(i*bw,count-a[i],bw,dtype.checked?a[i]:bw)
}
function mark(i,after){
	if(fps.g()>=30&&markarray.checked){
		ctx.fillStyle="#f00";
		ctx.fillRect(i*bw,count-arr[i],bw,dtype.checked?arr[i]:bw)
	}
	if(after)ctx.fillStyle=after;
}
function format(e){
	if(typeof e!="object"&&parseFloat(e)+""!=="NaN")return parseFloat(e);
	else return e
}
const joinSymbol="@";
function rdisp(args){
	if(args.length==3){var[interval,m,onfinish]=args,refresh=24
	}else if(args.length==4){var[interval,m,refresh,onfinish]=args}else return;
	let elapsed=Date.now(),updts=0,avrge=0,ticks=0,frames=0,clen=logs.length,tr=maxVal(len*.001,clen/(15000/interval)),tmp=[...arr],orlen=clen
	if(interval<0){tr=len*abs(interval)|0;interval=10}
	logs.forEach(e=>{
		let c=e.map(format)
		switch(c[0]){
			case"swap":swap(tmp,c[1],c[2],true);break;
			case"set":write(tmp,c[1],c[2],true);break;
			case"msw":multiSwap(tmp,c[1],c[2],true);break;
			case"rev":reversal(tmp,c[1],c[2],true);break;
			case"insert":insertTo(tmp,c[1],c[2],true);break;
			case"custom":eval(atob(c[1]))(tmp,...c.splice(2,1/0));break;
		}
	})
	tr=parseFloat(tr.toFixed(2));
	if(tr+.5<5&&tr>1)tr=1
	if(!fixedrate.checked)rate.value=tr
	atr=parseFloat(rate.value)
	let sed=isSorted(tmp.splice(0,1/0));
	finalresult.innerText=sed;finalresult.style.color=sed?"#fff":"#f00";
	swaps=0;writes=0;dcd=true;curDur=Date.now();
	markarray.checked=1;
	let itts=0;
	let n=setInterval(()=>{
		if(pause.checked)return;
		if(Date.now()-elapsed>1e3/refresh){
			elapsed=Date.now()
			display(arr)
			perms=0
			framecount.innerText=(orlen-clen).toLocaleString()+" / "+orlen.toLocaleString();
			framerate.innerText=frames+"/s"
			if(ticks++%5==0)estimated.innerText=(avrge/updts-3.5).toFixed(1)+"s";
		}
		let rte=0;itts++
		if(atr<0)atr=0
		if(rate.value<0)rte=itts%(abs(rate.value)+1);
		for(;rte<=atr;rte++){
			updts++;frames++
			setTimeout(()=>frames--,1e3)
			avrge+=orlen/frames
			if(clen--&&!didskip){
				let c=logs.shift().map(format)
				switch(c[0]){
					case"swap":swap(arr,c[1],c[2],true);mark(c[1]);mark(c[2]);break;
					case"set":write(arr,c[1],c[2],true);mark(c[1]);break;
					case"msw":multiSwap(arr,c[1],c[2],true);break;
					case"rev":reversal(arr,c[1],c[2],true);break;
					case"insert":insertTo(arr,c[1],c[2],true);break;
					case"custom":eval(atob(c[1]))(arr,...c.splice(2,1/0));break;
				}
			}else{
				clearArr(logs)
				clearInterval(n)
				onfinish()
				dcd=false
				setTimeout(()=>{
					finalresult.innerText=framecount.innerText=framerate.innerText="...";
				},5)
				break;
			}
		}
	},interval)
	let ratio=(orlen/count);
	if(ratio>=75)console.log(names.innerText,ratio.toFixed(2))
	if(!sed)console.log(names.innerText,sed)
}
function create(c){
	return Array(c).fill().map((e,i)=>++i)
}
function rotateText(t){
	let aux=t.split("");
	t=aux.splice(-1).concat(aux).join("")
	return t
}
/* Sauces: 
* https://github.com/Gaming32/ArrayV/blob/main/src/main/java/io/github/arrayv/sorts/
* https://github.com/Gaming32/ArrayV-Extra-Sorts/blob/main/src/main/java/io/github/arrayv/sorts/
* https://github.com/Gaming32/ArrayV/tree/main/src/main/java/io/github/arrayv/utils
* https://github.com/PCBoyGames/ArrayV-v4.0/tree/ad703423641022a396437e2025405916f2435b13/src/sorts
* https://github.com/PCBoyGames/ArrayV-v4.0/tree/ad703423641022a396437e2025405916f2435b13/src/utils
*/
const Rots={
	swapBlocksBackwards:function(ar,a,b,l,aux){
		for(let i=0;i<l;i++)swap(ar,a+l-i-1,b+l-i-1,aux);
	},
	blockSwap:function(ar,a,b,l,aux){
		for(let i=0;i<l;i++)swap(ar,a+i,b+i,aux);
	},
	shiftForwards:function(a,s,l,aux){
		let t=a[s];
		for(let i=0;i<l;i++)write(a,s+i,a[s+i+1],aux);
		write(a,s+l,t,aux);
	},
	shiftBackwards:function(a,s,l,aux){
		let t=a[s+l];
		for(let i=l;i>0;i--)write(a,s+i,a[s+i-1],aux);
		write(a,s,t,aux);
	},
	mapIndex:function(i,n,l){return(i-n+l)%l|0;},
	swap:function(ar,a,v,aux){
		let old=ar[a];
		write(ar,a,v,aux);
		return old;
	},
	griesMills:function(a,p,A,B,aux){
		while(A!=0&&B!=0){
			if(A<=B){
				this.blockSwap(a,p,p+A,A,aux);
				p+=A;B-=A;
			}else{
				this.blockSwap(a,p+(A-B),p+A,B,aux);
				A-=B;
			}
		}
	},
	threeReversal:function(a,p,A,B,aux=0){
		reversal(a,p,p+A-1,aux);
		reversal(a,p+A,p+A+B-1,aux);
		reversal(a,p,p+A+B-1,aux);
	},
	holyGriesMills:function(a,p,A,B,aux=0){
		while(A>1&&B>1){
			while(A<=B){
				this.blockSwap(a,p,p+A,A,aux);
				p+=A;B-=A;
			}
			if(A<=1||B<=1)break;
			while(A>B){
				this.swapBlocksBackwards(a,p+A-B,p+A,B,aux);
				A-=B;
			}
		}
		if(A==1)this.shiftForwards(a,p,B,aux);
		else if(B==1)this.shiftBackwards(a,p,A,aux);
	},
	helium:function(a,p,A,B,aux=0){
		while(B>1&&A>1)
			if(B<A){
				this.blockSwap(a,p,p+A,B,aux);
				p+=B;A-=B;
			}else{
				this.swapBlocksBackwards(a,p,p+B,A,aux);
				B-=A;
			}
		if(B==1)this.shiftBackwards(a,p,A,aux);
		else if(A==1)this.shiftForwards(a,p,B,aux);
	},
	cycleReverse:function(ar,p,A,B,aux){
		if(A<1||B<1)return;
		let a=p,b=p+A-1,c=p+A,d=p+A+B-1,s;
		while(a<b&&c<d){
			s=ar[b];
			write(ar,b--,ar[a],aux);
			write(ar,a++,ar[c],aux);
			write(ar,c++,ar[d],aux);
			write(ar,d--,s,aux);
		}
		while(a<b){
			s=ar[b];
			write(ar,b--,ar[a],aux);
			write(ar,a++,ar[d],aux);
			write(ar,d--,s,aux);
		}
		while(c<d){
			s=ar[c];
			write(ar,c++,ar[d],aux);
			write(ar,d--,ar[a],aux);
			write(ar,a++,s,aux);
		}
		if(a<d){
			if(d-a>2)reversal(ar,a,d,aux);
			else swap(ar,a,d,aux);
		}
	},
	juggling:function(a,p,A,B,aux=0){
		let l=A+B;A%=l;
		if(A==0)return;
		for(let c=0,i=0,v=a[p+i],s=i;c<l;c++){
			let n=this.mapIndex(i,A,l);
			v=this.swap(a,p+n,v,aux);
			if(n==s){
				s=i=this.mapIndex(i,1,l);
				v=a[p+i];
			}else i=n;
		}
	},
	bridge:function(a,p,l,b,aux=0){
		if(l<1||b<1)return;
		let pta=p,ptb=p+l,ptc=p+b,ptd=ptb+b;
		if(l<b){
			let bridge=b-l;
			if(bridge<l){
				let loop=l;
				let sw=new Array(bridge);
				arraycopy(a,ptb,sw,0,bridge,true);
				while(loop-->0){
					write(a,--ptc,a[--ptd],aux);
					write(a,ptd,a[--ptb],aux);
				}
				arraycopy(sw,0,a,pta,bridge,aux);
			}else{
				let sw=new Array(l);
				arraycopy(a,pta,sw,0,l,true);
				arraycopy(a,ptb,a,pta,b,aux);
				arraycopy(sw,0,a,ptc,l,aux);
			}
		}else if(b<l){
			let bridge=l-b;
			if(bridge<b){
				let loop=b;
				let sw=new Array(bridge);
				arraycopy(a,ptc,sw,0,bridge,true);
				while(loop-->0){
					write(a,ptc++,a[pta],aux);
					write(a,pta++,a[ptb++],aux);
				}
				arraycopy(sw,0,a,ptd-bridge,bridge,aux);
			}else{
				let sw=new Array(b);
				arraycopy(a,ptb,sw,0,b,true);
				while(l-->0)write(a,--ptd,a[--ptb],aux);
				arraycopy(sw,0,a,pta,b,aux);
			}
		}else while(left-->0)swap(a,pta++,ptb++,aux);
	},
	neon:function(a,p,A,B,aux=0){
		let end=p+A+B;
		while(A>0&&B>0){
			if(A<B){
				for(let i=0;i<A;i++){
					let t=a[p+i],j=p+i+A;
					for(;j<end;j+=A)write(a,j-A,a[j],aux);
					write(a,j-A,t,aux);
				}
				p+=B;B%=A;A-=B;
			}else{
				for(let i=0;i<B;i++){
					let t=a[p+i+A],j=p+i+A-B;
					for(;j>=p;j-=B)write(a,j+B,a[j],aux);
					write(a,j+B,t,aux);
				}
				end=p+B;A%=B;B-=A;
			}
		}
	},
	foolish:function(a,p,A,B,aux=0){
		if(A<B)for(let i=0;i<A;i++)insertTo(a,p,p+A+B-1,aux);
		else for(let i=0;i<B;i++)insertTo(a,p+A+B-1,p,aux);
	},
	morefoolish:function(a,p,A,B,aux=0){
		if(A>B)for(let i=0;i<A;i++)insertTo(a,p,p+A+B-1,aux);
		else for(let i=0;i<B;i++)insertTo(a,p+A+B-1,p,aux);
	},
	radon:function(a,p,A,B,aux=0){
		let min=minVal(A,B),max=maxVal(A,B),bridge=max-min;
		if(min<1)return;
		if(bridge<=min)reversal(a,p+min,p+max-1,aux);
		for(let i=0;i<min;i++)swap(a,p+i,p+max+i,aux);
		if(bridge==0)return;
		if(A>B){
			if(bridge>min)this.cycleReverse(a,p+min,bridge,min,aux);
			else{
				let sw,a1=p+min,b=p+max,c=b+min-1;
				while(b<c){
					sw=a[c];
					swap(a,c--,a[a1],aux);
					swap(a,a1++,a[b],aux);
					swap(a,b++,sw,aux);
				}
				reversal(a,a1,c,aux);
			}
		}else{
			if(bridge>min)this.cycleReverse(a,p,min,bridge,aux);
			else{
				let sw,a1=p,b=a+min-1,c=a+max-1;
				while(a<b){
					sw=a[a1];
					swap(a,a1++,a[c],aux);
					swap(a,c--,a[b],aux);
					swap(a,b--,sw,aux);
				}
				reversal(a,a1,c,aux);
			}
		}
	},
	centered:function(a,p,A,B,aux=0){
		if(A<1||B<1)return;
		if(A<B){
			let h=(B-A)/2|0;
			this.blockSwap(a,p,p+A+h,A,aux);
			this.centered(a,p+A+h,A,B-A-h,aux);
			this.centered(a,p,A,h,aux);
		}else if(A==B)this.blockSwap(a,p,p+A,A,aux);
		else{
			let h=(A-B)/2|0;
			this.blockSwap(a,p+h,p+A,B,aux);
			this.centered(a,p,h,B,aux);
			this.centered(a,p+h+B,A-B-h,B,aux);
		}
	},
	adaptable:function(a,p,A,B,aux=0){
		if(A==0||B==0)return;
		if(A%B==0||B%A==0)this.holyGriesMills(a,p,A,B,aux);
		else this.cycleReverse(a,p,A,B,aux);
	}
}
const IndexRots={
	griesMills:function(a,s,m,e,aux){Rots.griesMills(a,s,m-s,e-m,aux)},
	threeReversal:function(a,s,m,e,aux){Rots.threeReversal(a,s,m-s,e-m,aux)},
	juggling:function(a,s,m,e,aux){Rots.juggling(a,s,m-s,e-m,aux)},
	holyGriesMills:function(a,s,m,e,aux){Rots.holyGriesMills(a,s,m-s,e-m,aux)},
	helium:function(a,s,m,e,aux){Rots.helium(a,s,m-s,e-m,aux)},
	cycleReverse:function(a,s,m,e,aux){Rots.cycleReverse(a,s,m-s,e-m,aux)},
	bridge:function(a,s,m,e,aux){Rots.bridge(a,s,m-s,e-m,aux)},
	neon:function(a,s,m,e,aux){Rots.neon(a,s,m-s,e-m,aux)},
	foolish:function(a,s,m,e,aux){Rots.foolish(a,s,m-s,e-m,aux)},
	morefoolish:function(a,s,m,e,aux){Rots.morefoolish(a,s,m-s,e-m,aux)},
	radon:function(a,s,m,e,aux){Rots.radon(a,s,m-s,e-m,aux)},
	centered:function(a,s,m,e,aux){Rots.centered(a,s,m-s,e-m,aux)},
	adaptable:function(a,s,m,e,aux){Rots.adaptable(a,s,m-s,e-m,aux)}
}
function analyzeBit(a,l){
	let m=0;
	for(let i=0;i<l;i++){
		let v=a[i];
		if(v>m)m=v;
	}
	return 31-clz32(m);
}
function getBit(n,k){
	return((n>>k)&1)==1;
}
function getDigit(a,p,r){
	return(a/pow(r,p))%r|0;
}
function minVal(a){
	return typeof a=="object"?Math.min(...a):Math.min(...arguments);
}
function maxVal(a){
	return typeof a=="object"?Math.max(...a):Math.max(...arguments);
}
function maxLog(a,l,b){
	let m=0,i;
	for(i=0;i<l;i++){
		let v=a[i];
		if(v>m)m=v;
	}
	return log(m)/log(b)|0;
}
function compareValues(a,b){
	a|=0;b|=0
	return a==b?0:a>b?1:-1
}
function compareIndices(a,b,c){
	b|=0;c|=0
	return a[b]==a[c]?0:a[b]>a[c]?1:-1
}
function swap(a,f,t,aux){
	f|=0;t|=0;
	let o=a[f];a[f]=a[t];a[t]=o;
	if(aux){swaps++;writes+=2
	}else logs.push(["swap",f,t])
}
function customFunc(f,args){
	logs.push(["custom",btoa("("+f+")"),...args])
}
function write(a,t,v,aux){
	a[t|0]=v|0;
	if(aux)writes++
	else logs.push(["set",t|0,v|0])
}
function insertTo(a,p,t,aux=undefined){
	let tp=a[p];
	if(aux===undefined||aux===null){
		logs.push(["insert",p,t])
		aux=true;
	}
	let d=t-p>0?1:-1;
	for(let i=p;d>0?(i<t):(i>t);i+=d)write(a,i,a[i+d],aux);
	if(p!=t)write(a,t,tp,aux);
}
function multiSwap(a,p,t,aux=undefined){
	if(abs(p-t)==1)return swap(a,p,t,aux);
	if(aux===undefined){
		logs.push(["msw",p,t])
		aux=true;
	}
	let d=t-p>0?1:-1;
	for(let i=p;d?(i<t):(i>t);i+=d)swap(a,i,i+d,aux);
}
function transcribe(a,g,s,aux){
	let t=s;
	for(let i=0;i<g.length;i++){
		for(let j=0;j<g[i].length;j++)write(a,t++,g[i][j],aux);
		g[i]=[]
	}
}
function transcribeMSD(a,rgs,s,m,aux){
	let t=s,p=0;
	for(let i=0;i<rgs.length;i++)t+=rgs[i].length;
	for(let i=rgs.length-1;i>=0;i--)for(let j=rgs[i].length-1;j>=0;j--)write(a,t+m-p++-1,rgs[i][j],aux);
}
function fancyTranscribe(a,e,regs){
	let aux=new Array(e),aux2=new Array(e).fill(false),rad=regs.length;
	transcribe(aux,regs,0,true);
	for(let i=0;i<e;i++){
		let reg=i%rad,p=(reg*(e/rad))+(i/rad)|0;
		if(!aux2[p]){
			write(a,p,aux[p]);
			aux2[p]=true;
		}
	}
	for(let i=0;i<e;i++)if(!aux2[i])write(a,i,aux[i]);
}
function reversal(a,s,l,aux=undefined){
	if(l-s<1)return;
	if(aux===undefined){
		logs.push(["rev",s,l,true])
		aux=true
	}
	for(let i=s;i<s+((l-s+1)/2);i++)swap(a,i,s+l-i,aux);
}
function clearArr(a){a.splice(0,1/0)}
function arraycopy(s,sp,d,dp,l,aux){
	let b=s!=d||dp<sp,st=b?0:l-1,e=b?l:-1,dr=b?1:-1;
	for(let i=st;i!=e;i+=dr)write(d,dp+i,s[sp+i],aux);
}
function getMin(a,l){
	let m=1/0;
	for(let i=0;i<l;i++)if(a[i]<m)m=a[i];
	return m;
}
function getMax(a,l){
	let m=-1/0;
	for(let i=0;i<l;i++)if(a[i]>m)m=a[i];
	return m;
}
function getMaxIndex(a,l){
	let i=0,n;
	for(n=0;n<l;++n)if(a[n]>a[i])i=n;
	return i;
}
const circleDepth=.01
//templates
function icsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)for(let s=0;s+g<len;s+=2*g)for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)if(h<len&&compareIndices(a,lw,h)>0)swap(a,lw,h,0,sc++);
	return sc;
}
function rcsr(a,l,h,s){
	if(l==h)return s;
	let hi=h,lo=l,m=(h-l)/2|0;
	for(;l<h;l++,h--)if(h<len&&compareIndices(a,l,h)>0)swap(a,l,h,0,s++);
	s=rcsr(a,lo,lo+m,s);
	if(lo+m+1<len)s=rcsr(a,lo+m+1,hi,s);
	return s;
}
function iclsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)for(let s=0;s+g<len;s+=2*g)for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)if(h<len&&compareIndices(a,lw,h)>0)reversal(a,lw,h,0,sc++);
	return sc;
}
function rclsr(a,lo,hi,s){
	if(lo==hi)return s;
	let h=hi,l=lo,m=(hi-lo)/2|0;
	for(;lo<hi;lo++,hi--)if(hi<len&&compareIndices(a,lo,hi)>0)reversal(a,lo,hi,0,s++);
	s=rclsr(a,l,l+m,s);
	if(l+m+1<len)s=rclsr(a,l+m+1,h,s);
	return s;
}
function ishsr(a,l){
	let sc=0;
	for(let g=l/2;g>circleDepth;g/=2)for(let s=0;s+g<len;s+=2*g)for(let h=s+2*g-1,lw=s;lw<h;lw++,h--)if(h<len&&compareIndices(a,lw,h)>0)insertTo(a,lw,h,undefined,sc++);
	return sc;
}
function rshsr(a,lo,hi,s){
	if(lo==hi)return s;
	let h=hi,l=lo,m=(hi-lo)/2|0;
	for(;lo<hi;lo++,hi--)if(hi<len&&compareIndices(a,lo,hi)>0)insertTo(a,lo,hi,undefined,s++);
	s=rshsr(a,l,l+m,s);
	if(l+m+1<len)s=rshsr(a,l+m+1,h,s);
	return s;
}
function insertSort(a,s,l,x=0){
	for(let i=s;i<l;i++){
		let p=i-1,c=a[i];
		while(p>=s&&compareValues(a[p],c)>0)write(a,p+1,a[p--],x);
		write(a,p+1,c,x);
	}
}
function siftDown(a,r,d,s,m,x=0){
	let cv=m?-1:1;
	while(r<=d/2){
		let l=2*r;
		if(l<d&&compareIndices(a,s+l-1,s+l)==cv)l++;
		if(compareIndices(a,s+r-1,s+l-1)==cv){
			swap(a,s+r-1,s+l-1,x);
			r=l;
		}else break;
	}
}
function heapify(ar,lw,h,m,x=0){
	let le=h-lw;
	for(let i=le/2|0;i>=1;i--)siftDown(ar,i,le,lw,m,x)
}
function heapSort(a,s,l,mx,aux=0){
	heapify(a,s,l,mx,aux);
	for(let i=l-s;i>1;i--){
		swap(a,s,s+i-1,aux);
		siftDown(a,1,i-1,s,mx,aux);
	}
	if(!mx)reversal(a,s,s+l-1,aux);
}
function binDoubleInsert(ar,a,b,aux=0){
	const lbs=(ar,a,b,v)=>{
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	const rbs=(ar,a,b,v)=>{
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function itl(ar,a,b,t){
		while(a>b)write(ar,a,ar[--a],aux);
		write(ar,b,t,aux);
	}
	function itr(ar,a,b,t){
		while(a<b)write(ar,a,ar[++a],aux);
		write(ar,a,t,aux);
	}
	function dbi(ar,a,b){
		if(b-a<2)return;
		let j=a+(b-a-2)/2+1|0,i=a+(b-a-1)/2|0;
		if(j>i&&compareIndices(ar,i,j)>0)swap(ar,i,j,aux);
		i--;j++;
		while(j<b){
			if(compareIndices(ar,i,j)>0){
				let l=ar[j],r=ar[i],m=rbs(ar,i+1,j,l);
				itr(ar,i,m-1,l);
				itl(ar,j,lbs(ar,m,j,r),r);
			}else{
				let l=ar[i],r=ar[j],m=lbs(ar,i+1,j,l);
				itr(ar,i,m-1,l);
				itl(ar,j,rbs(ar,m,j,r),r);
			}
			i--;j++;
		}
	}
	dbi(ar,a,b);
}
function binInsertSort(a,s,e){
	for(let i=s;i<e;i++){
		let n=a[i],l=s,h=i;
		while(l<h){
			let m=l+(h-l)/2|0;
			if(compareValues(n,a[m])<0)h=m;
			else l=m+1;
		}
		let j=i-1;
		while(j>=l)write(a,j+1,a[j--]);
		write(a,l,n);
	}
}
function mergeSortTemp(ar,l,bin){
	if(l<32&&bin)return binInsertSort(ar,0,l);
	let tmp=new Array(l),end=l,mid=end/2|0;
	const merge=(a,t,s,m,e,b)=>{
		if(s==m)return;
		if(e-s<32&&b)return;
		else if(e-s<64&&b)binInsertSort(a,s,e);
		else{
			merge(a,t,s,(m+s)/2|0,m,b);
			merge(a,t,m,(m+e)/2|0,e,b);
			let l=s,h=m;
			for(let n=0;n<e-s;n++){
				if(l>=m&&h>=e)break;
				if(l<m&&h>=e)write(t,n,a[l++],true);
				else if(l>=m&&h<e)write(t,n,a[h++],true);
				else if(compareIndices(a,l,h)<1)write(t,n,a[l++],true);
				else write(t,n,a[h++],true);
			}
			for(let i=0;i<e-s;i++)write(a,s+i,t[i]);
		}
	}
	merge(ar,tmp,0,mid,end,bin);
}
function cocktailShakerTemp(a,s,e){
	for(let i=0;i<(e/2|0)+s;){
		let sw=true;
		for(let j=i;j<e+s-i-1;j++)if(compareIndices(a,j,j+1)>0)sw=swap(a,j,j+1);
		for(let j=e+s-i-1;j>i;j--)if(compareIndices(a,j,j-1)<0)sw=swap(a,j,j-1);
		if(sw)break;else i++;
	}
}
function combSortTemp(a,l,h,y){
	let s=false,g=l;
	while(g>1||s){
		if(g>1)g=g/h|0;
		s=false;
		for(let i=0;g+i<l;++i){
			if(y&&g<=Math.min(8,l*.0325)){
				g=0;insertSort(a,0,l);
				break;
			}
			if(compareIndices(a,i,i+g)>0)s=!swap(a,i,i+g);
		}
	}
}
//end
//class templates
class QdSB{
	swapTwo(a,s){
		if(compareIndices(a,s,s+1)>0)swap(a,s,s+1);
	}
	swapThree(a,s){
		if(compareIndices(a,s,s+1)>0){
			if(compareIndices(a,s,s+2)<1)swap(a,s,s+1);
			else if(compareIndices(a,s+1,s+2)>0)swap(a,s,s+2);
			else{
				let t=a[s];
				write(a,s,a[s+1]);
				write(a,s+1,a[s+2]);
				write(a,s+2,t);
			}
		}else if(compareIndices(a,s+1,s+2)>0){
			if(compareIndices(a,s,s+2)>0){
				let t=a[s+2];
				write(a,s+2,a[s+1]);
				write(a,s+1,a[s]);
				write(a,s,t);
			}else swap(a,s+2,s+1);
		}
	}
	swapFour(a,s){
		if(compareIndices(a,s,s+1)>0)swap(a,s,s+1);
		if(compareIndices(a,s+2,s+3)>0)swap(a,s+2,s+3);
		if(compareIndices(a,s+1,s+2)>0){
			if(compareIndices(a,s,s+2)<1){
				if(compareIndices(a,s+1,s+3)<1)swap(a,s+1,s+2);
				else{
					let t=a[s+1];
					write(a,s+1,a[s+2]);
					write(a,s+2,a[s+3]);
					write(a,s+3,t);
				}
			}else if(compareIndices(a,s,s+3)>0){
				swap(a,s+1,s+3);
				swap(a,s,s+2);
			}else if(compareIndices(a,s+1,s+3)<1){
				let t=a[s+1];
				write(a,s+1,a[s]);
				write(a,s,a[s+2]);
				write(a,s+2,t);
			}else{
				let t=a[s+1];
				write(a,s+1,a[s]);
				write(a,s,a[s+2]);
				write(a,s+2,a[s+3]);
				write(a,s+3,t);
			}
		}
	}
	swapFive(a,s){
		this.end=s+4;this.pta=this.end++;this.ptt=this.pta--;
		if(compareIndices(a,this.pta,this.ptt)>0){
			this.key=a[this.ptt];
			write(a,this.ptt--,a[this.pta--]);
			if(this.pta>s&&compareValues(a[this.pta-1],this.key)>0){
				write(a,this.ptt--,a[this.pta--]);
				write(a,this.ptt--,a[this.pta--]);
			}
			if(this.pta>=s&&compareValues(a[this.pta],this.key)>0)write(a,this.ptt--,a[this.pta--]);
			a[this.ptt]=this.key;
		}
	}
	tailSwapEight(a,s){
		this.pta=this.end++;this.ptt=this.pta--;
		if(compareIndices(a,this.pta,this.ptt)>0){
			this.key=a[this.ptt];
			write(a,this.ptt--,a[this.pta--]);
			if(compareValues(a[this.pta-2],this.key)>0)for(let i=0;i<3;i++)write(a,this.ptt--,a[this.pta--]);
			if(this.pta>s&&compareValues(a[this.pta-1],this.key)>0){
				write(a,this.ptt--,a[this.pta--]);
				write(a,this.ptt--,a[this.pta--]);
			}
			if(this.pta>=s&&compareValues(a[this.pta],this.key)>0)write(a,this.ptt--,a[this.pta--]);
			a[this.ptt]=this.key;
		}
	}
	swapSix(a,s){
		this.swapFive(a,s);
		this.tailSwapEight(a,s);
	}
	swapSeven(a,s){
		this.swapSix(a,s);
		this.tailSwapEight(a,s);
	}
	swapEight(a,s){
		this.swapSeven(a,s);
		this.tailSwapEight(a,s);
	}
}
class QdS{
	constructor(){
		this.qs=new QdSB();
	}
	tailSwap(ar,s,n){
		let m,top,off;
		switch(n){
		case 0:
		case 1:return;
		case 2:this.qs.swapTwo(ar,s);return;
		case 3:this.qs.swapThree(ar,s);return;
		case 4:this.qs.swapFour(ar,s);return;
		case 5:this.qs.swapFour(ar,s);this.qs.swapFive(ar,s);return;
		case 6:this.qs.swapFour(ar,s);this.qs.swapSix(ar,s);return;
		case 7:this.qs.swapFour(ar,s);this.qs.swapSeven(ar,s);return;
		case 8:this.qs.swapFour(ar,s);this.qs.swapEight(ar,s);return;
		}
		this.qs.swapFour(ar,s);
		this.qs.swapEight(ar,s);
		this.qs.end=s+8;off=8;
		while(off<n){
			top=off++;
			this.qs.pta=this.qs.end++;this.qs.ptt=this.qs.pta--;
			if(compareIndices(ar,this.qs.pta,this.qs.ptt)<1)continue;
			let tm=ar[this.qs.ptt];
			while(top>1){
				m=top/2|0;
				if(compareValues(ar[this.qs.pta-m],tm)>0)this.qs.pta-=m;
				top-=m;
			}
			for(let i=this.qs.ptt;i>this.qs.pta;i--)write(ar,i,ar[i-1]);
			write(ar,this.qs.pta,tm);
		}
	}
	parityMerge4(fr,s,d,xo){
		let ptl,ptr,aP=xo;
		ptl=s;ptr=s+4;
		for(let i=0;i<3;i++)
			if(compareIndices(fr,ptl,ptr)<1)write(d,aP++,fr[ptl++],true);
			else write(d,aP++,fr[ptr++],true);
		if(compareIndices(fr,ptl,ptr)<1)write(d,aP,fr[ptl],true);
		else write(d,aP,fr[ptr],true);
		ptl=s+3;ptr=s+7;aP+=4;
		for(let i=0;i<3;i++)
			if(compareIndices(fr,ptl,ptr)>0)write(d,aP--,fr[ptl--],true);
			else write(d,aP--,fr[ptr--],true);
		if(compareIndices(fr,ptl,ptr)>0)write(d,aP,fr[ptl],true);
		else write(d,aP,fr[ptr],true);
	}
	parityMerge8(fr,s,d){
		let ptl=0,ptr=8,mainP=s;
		for(let i=0;i<7;i++)
			if(compareIndices(fr,ptl,ptr)<1)write(d,mainP++,fr[ptl++]);
			else write(d,mainP++,fr[ptr++]);
		if(compareIndices(fr,ptl,ptr)<1)write(d,mainP,fr[ptl]);
		else write(d,mainP,fr[ptr]);
		ptl=7;ptr=15;mainP+=8;
		for(let i=0;i<7;i++)
			if(compareIndices(fr,ptl,ptr)>0)write(d,mainP--,fr[ptl--]);
			else write(d,mainP--,fr[ptr--]);
		if(compareIndices(fr,ptl,ptr)>0)write(d,mainP,fr[ptl]);
		else write(d,mainP,fr[ptr]);
	}
	parityMerge16(ar,s,x){
		if(compareIndices(ar,s+3,s+4)<1&&compareIndices(ar,s+7,s+8)<1&&compareIndices(ar,s+11,s+12)<1)return;
		this.parityMerge4(ar,s,x,0);
		this.parityMerge4(ar,s+8,x,8);
		this.parityMerge8(x,s,ar);
	}
	partialBackwardMerge(ar,aux,st,n,o){
		let r,m,e,s;m=st+o;e=st+n-1;r=m--;
		if(compareIndices(ar,m,r)<1)return;
		while(compareIndices(ar,m,e)<1)e--;
		for(let i=r;i<r+(e-m);i++)write(aux,i-r,ar[i],true);
		s=e-r;
		write(ar,e--,ar[m--]);
		if(compareValues(ar[st],aux[0])<1){
			do{
				while(compareValues(ar[m],aux[s])>0)write(ar,e--,ar[m--]);
				write(ar,e--,aux[s--]);
			}while(s>=0);
		}else{
			do{
				while(compareValues(ar[m],aux[s])<1)write(ar,e--,aux[s--]);
				write(ar,e--,ar[m--]);
			}while(m>=st);
			do write(ar,e--,aux[s--]);while(s>=0);
		}
	}
	tailMerge(ar,aux,s,n,o){
		let pta,pte=s+n;
		for(;o<n;o*=2){
			for(pta=s;pta+o<pte;pta+=o*2){
				if(pta+o*2<pte){
					this.partialBackwardMerge(ar,aux,pta,o*2,o);
					continue;
				}
				this.partialBackwardMerge(ar,aux,pta,pte-pta,o);
				break;
			}
		}
	}
	forwardMerge(d,fr,s,auxs,o,toAux){
		let l=toAux?s:auxs,r=toAux?(s+o):(auxs+o),m=r,e=r+o,mergeP=toAux?auxs:s;
		if(compareIndices(fr,r-1,e-1)<1){
			leftFirst:do{
				for(let i=0;i<3;i++){
					if(compareIndices(fr,l,r)<1){
						write(d,mergeP++,fr[l++],toAux);
						continue leftFirst;
					}
					write(d,mergeP++,fr[r++],toAux);
				}
			}while(l<m);
			do write(d,mergeP++,fr[r++],toAux);while(r<e);
		}else{
			rightFirst:do{
				for(let i=0;i<3;i++){
					if(compareIndices(fr,l,r)>0){
						write(d,mergeP++,fr[r++],toAux);
						continue rightFirst;
					}
					write(d,mergeP++,fr[l++],toAux);
				}
			}while(r<e);
			do write(d,mergeP++,fr[l++],toAux);while(l<m);
		}
	}
	quadMergeBlock(ar,s,aux,o){
		let pts,c,cMax=s+o,oX2=o*2;
		if(compareIndices(ar,cMax-1,cMax)<1){
			cMax+=oX2;
			if(compareIndices(ar,cMax-1,cMax)<1){
				cMax-=o;
				if(compareIndices(ar,cMax-1,cMax)<1)return;
				pts=0;c=s;
				do write(aux,pts++,ar[c++],true);while(c<cMax);
				cMax=c+oX2;
				do write(aux,pts++,ar[c++],true);while(c<cMax);
				this.forwardMerge(ar,aux,s,0,oX2,false);
				return;
			}
			pts=0;c=s;cMax=s+oX2;
			do write(aux,pts++,ar[c++],true);while(c<cMax);
		}else this.forwardMerge(aux,ar,s,0,o,true);
		this.forwardMerge(aux,ar,s+oX2,oX2,o,true);
		this.forwardMerge(ar,aux,s,0,oX2,false);
	}
	quadMerge(ar,aux,s,n,o){
		let pta,pte=s+n;
		o*=4;
		for(;o*2<=n;o*=4){
			pta=s;
			do{
				this.quadMergeBlock(ar,pta,aux,o/4|0);
				pta+=o;
			}while(pta+o<=pte);
			this.tailMerge(ar,aux,pta,pte-pta,o/4|0);
		}
		this.tailMerge(ar,aux,s,n,o/4|0);
	}
	quadSwap(ar,s,n){
		let swp=new Array(16),c=n/4|0,rv,pta=s,pts=0,ptt=0,tm=0;
		wp:while(c-->0){
			while(1){
				if(compareIndices(ar,pta,pta+1)>0){
					if(compareIndices(ar,pta+2,pta+3)>0){
						if(compareIndices(ar,pta+1,pta+2)>0){
							pts=pta;pta+=4;
							break;
						}
						swap(ar,pta+2,pta+3);
					}
					swap(ar,pta,pta+1);
				}else if(compareIndices(ar,pta+2,pta+3)>0)swap(ar,pta+2,pta+3);
				if(compareIndices(ar,pta+1,pta+2)>0){
					if(compareIndices(ar,pta,pta+2)<1){
						if(compareIndices(ar,pta+1,pta+3)<1)swap(ar,pta+1,pta+2);
						else{
							tm=ar[pta+1];
							write(ar,pta+1,ar[pta+2]);
							write(ar,pta+2,ar[pta+3]);
							write(ar,pta+3,tm);
						}
					}else if(compareIndices(ar,pta,pta+3)>0){
						swap(ar,pta+1,pta+3);
						swap(ar,pta,pta+2);
					}else if(compareIndices(ar,pta+1,pta+3)<1){
						tm=ar[pta+1];
						write(ar,pta+1,ar[pta]);
						write(ar,pta,ar[pta+2]);
						write(ar,pta+2,tm);
					}else{
						tm=ar[pta+1];
						write(ar,pta+1,ar[pta]);
						write(ar,pta,ar[pta+2]);
						write(ar,pta+2,ar[pta+3]);
						write(ar,pta+3,tm);
					}
				}
				pta+=4;
				continue wp;
			}
			while(1){
				if(c-->0){
					if(compareIndices(ar,pta,pta+1)>0){
						if(compareIndices(ar,pta+2,pta+3)>0){
							if(compareIndices(ar,pta+1,pta+2)>0){
								if(compareIndices(ar,pta-1,pta)>0){
									pta+=4;
									continue;
								}
							}
							swap(ar,pta+2,pta+3);
						}
						swap(ar,pta,pta+1);
					}else if(compareIndices(ar,pta+2,pta+3)>0)swap(ar,pta+2,pta+3);
					if(compareIndices(ar,pta+1,pta+2)>0){
						if(compareIndices(ar,pta,pta+2)<1){
							if(compareIndices(ar,pta+1,pta+3)<1)swap(ar,pta+1,pta+2);
							else{
								tm=ar[pta+1];
								write(ar,pta+1,ar[pta+2]);
								write(ar,pta+2,ar[pta+3]);
								write(ar,pta+3,tm);
							}
						}else if(compareIndices(ar,pta,pta+3)>0){
							swap(ar,pta,pta+2);
							swap(ar,pta+1,pta+3);
						}else if(compareIndices(ar,pta+1,pta+3)<1){
							tm=ar[pta];
							write(ar,pta,ar[pta+2]);
							write(ar,pta+2,ar[pta+1]);
							write(ar,pta+1,tm);
						}else{
							tm=ar[pta];
							write(ar,pta,ar[pta+2]);
							write(ar,pta+2,ar[pta+3]);
							write(ar,pta+3,ar[pta+1]);
							write(ar,pta+1,tm);
						}
					}
					ptt=pta-1;rv=(ptt-pts)/2|0;
					do swap(ar,pts++,ptt--);while(rv-->0);
					pta+=4;
					continue wp;
				}
				if(pts==s){
					switch(n%4){
					case 3:if(compareIndices(ar,pta+1,pta+2)<1)break;
					case 2:if(compareIndices(ar,pta,pta+1)<1)break;
					case 1:if(compareIndices(ar,pta-1,pta)<1)break;
					case 0:
						ptt=pts+n-1;rv=(ptt-pts)/2|0;
						do swap(ar,pts++,ptt--);while(rv-->0);
						return 1;
					}
				}
				ptt=pta-1;rv=(ptt-pts)/2|0;
				do swap(ar,pts++,ptt--);while(rv-->0);
				break wp;
			}
		}
		this.tailSwap(ar,pta,n%4);
		pta=s;c=n/16|0;
		while(c-->0){
			this.parityMerge16(ar,pta,swp);
			pta+=16;
		}
		if(n%16>4)this.tailMerge(ar,swp,pta,n%16,4);
		return 0;
	}
	quadSort(ar,s,l){
		if(l<16)this.tailSwap(ar,s,l);
		else if(l<256){
			if(this.quadSwap(ar,s,l)==0){
				let swp =new Array(128);
				this.tailMerge(ar,swp,s,l,16);
			}
		}else{
			if(this.quadSwap(ar,s,l)==0){
				let swp=new Array(l/2|0);
				this.quadMerge(ar,swp,s,l,16);
			}
		}
	}
	quadSortSwap(ar,swp,s,l){
		if(l<16)this.tailSwap(ar,s,l);
		else if(l<256){
			if(this.quadSwap(ar,s,l)==0)this.tailMerge(ar,swp,s,l,16);
		}else{
			if(this.quadSwap(ar,s,l)==0)this.quadMerge(ar,swp,s,l,16);
		}
	}
}
class MWMS{
	keyLessThan(s,p,a,b){
		let c=compareIndices(s,p[a],p[b]);
		return c<0||(c==0&&compareValues(a,b)<0);
	}
	siftDown(s,h,p,t,r,z){
		while(2*r+2<z){
			let n=2*r+1,m=n+(this.keyLessThan(s,p,h[n],h[n+1])?0:1);
			if(this.keyLessThan(s,p,h[m],t)){
				write(h,r,h[m],true);
				r=m;
			}else break;
		}
		let m=2*r+1;
		if(m<z&&this.keyLessThan(s,p,h[m],t)){
			write(h,r,h[m],true);
			r=m;
		}
		write(h,r,t,true);
	}
	kWayMerge(s,d,h,a,b,z,x){
		for(let i=0;i<z;i++)write(h,i,i,true);
		for(let i=(z-1)/2|0;i>=0;i--)this.siftDown(s,h,a,h[i],i,z);
		for(let i=0;z>0;i++){
			let m=h[0];
			write(d,i,s[a[m]],x);
			write(a,m,a[m]+1,true);
			if(a[m]==b[m])this.siftDown(s,h,a,h[--z],0,z);
			else this.siftDown(s,h,a,h[0],0,z);
		}
	}
}
class BMS{
	shiftFW(a,b,m,c){
		while(m<c)swap(a,b++,m++);
	}
	shiftBW(a,b,m,c){
		while(m>b)swap(a,--c,--m);
	}
	shiftFWExt(a,b,m,c){
		while(m<c)write(a,b++,a[m++]);
	}
	shiftBWExt(a,b,m,c){
		while(m>b)write(a,--c,a[--m]);
	}
	insertTo(a,b,c){
		let t=a[b];
		while(b>c)write(a,b,a[--b]);
		write(a,c,t);
	}
	insertToBW(a,b,c){
		let t=a[b];
		while(b<c)write(a,b,a[++b]);
		write(a,b,t);
	}
	multiSwap(a,b,c,d){
		for(let i=0;i<d;i++)
			swap(a,b+i,c+i);
	}
	rotate(a,b,m,c){
		IndexRots.cycleReverse(a,b,m,c,false);
	}
	leftBinSearch(a,b,c,v){
		while(b<c){
			let m=b+(c-b)/2|0;
			if(compareValues(v,a[m])<1)c=m;
			else b=m+1;
		}
		return b;
	}
	rightBinSearch(c,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,c[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	buildRuns(c,a,b){
		let n=true,i=a+1,j=a;
		while(i<b){
			if(compareIndices(c,i-1,i++)==1){
				while(i<b&&compareIndices(c,i-1,i)==1)i++;
				reversal(c,j,i-1);
			}else while(i<b&&compareIndices(c,i-1,i)<1)i++;
			if(i<b){
				n=false;j=i-(i-j-1)%16-1;
			}
			while(i-j<16&&i<b)this.insertTo(c,i,Bms.rightBinSearch(c,j,i,c[i++]));
			j=i++;
		}
		return n;
	}
	findKeys(c,a,b,nk,n){
		let p=a,pE=a+nk;
		for(let i=pE;i<b&&nk<n;i++){
			let loc=this.leftBinSearch(c,p,pE,c[i]);
			if(pE==loc||compareValues(c[i],c[loc])!=0){
				this.rotate(c,p,pE,i);
				let inc=i-pE;
				loc+=inc;p+=inc;pE+=inc;nk++;
				this.insertTo(c,pE++,loc);
			}
		}
		this.rotate(c,a,p,pE);
		return nk;
	}
	findKeysBW(c,a,b,nk,n){
		let p=b-nk,pE=b;
		for(let i=p-1;i>=a&&nk<n;i--){
			let loc=this.leftBinSearch(c,p,pE,c[i]);
			if(pE==loc||compareValues(c[i],c[loc])!=0){
				this.rotate(c,i+1,p,pE);
				let inc=p-(i+1);
				loc-=inc;pE-=inc;p-=inc+1;nk++;
				this.insertToBW(c,i,loc-1);
			}
		}
		this.rotate(c,p,pE,b);
		return nk;
	}
	binaryInsertion(c,a,b){
		for(let i=a+1;i<b;i++)this.insertTo(c,i,Bms.rightBinSearch(c,a,i,c[i]));
	}
	boundCheck(c,a,m,b){
		return m>=b||compareValues(c[m-1],c[m])<1;
	}
	mergeBW(c,a,m,b,p){
		if(this.boundCheck(c,a,m,b))return;
		let pL=b-m;
		this.multiSwap(c,m,p,pL);
		let i=pL-1,j=m-1,k=b-1;
		while(i>=0&&j>=a)
			if(compareValues(c[p+i],c[j])>=0)swap(c,k--,p+(i--));
			else swap(c,k--,j--);
		while(i>=0)swap(c,k--,p+(i--));
	}
	mergeTo(c,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b)
			if(compareValues(c[i],c[j])<1)swap(c,p++,i++);
			else swap(c,p++,j++);
		while(i<m)swap(c,p++,i++);
		while(j<b)swap(c,p++,j++);
	}
	pingPongMerge(c,a,m1,m2,m3,b,p){
		if(compareValues(c[m1-1],c[m1])>0||(m3<b&&compareIndices(c,m3-1,m3)>0)){
			let p1=p+m2-a,pE=p+b-a;
			this.mergeTo(c,a,m1,m2,p);
			this.mergeTo(c,m2,m3,b,p1);
			this.mergeTo(c,p,p1,pE,a);
		}else this.mergeBW(c,a,m2,b,p);
	}
	mergeFWExt(c,tmp,a,m,b){
		let s=m-a;
		this.arraycopy(c,a,tmp,0,s,true);
		let i=0,j=m;
		while(i<s&&j<b)
			if(compareValues(tmp[i],c[j])<1)write(c,a++,tmp[i++]);
			else write(c,a++,c[j++]);
		while(i<s)write(c,a++,tmp[i++]);
	}
	mergeBWExt(c,tmp,a,m,b){
		let s=b-m;
		this.arraycopy(c,m,tmp,0,s,true);
		let i=s-1,j=m-1;
		while(i>=0&&j>=a)
			if(compareValues(tmp[i],c[j])>=0)write(c,--b,tmp[i--]);
			else write(c,--b,c[j--]);
		while(i>=0)write(c,--b,tmp[i--]);
	}
	mergeWithBufFW(c,a,m,b,p){
		let i=m;
		while(a<m&&i<b)
			if(compareIndices(c,a,i)<1)swap(c,p++,a++);
			else swap(c,p++,i++);
		if(a>p)this.shiftFW(c,p,a,m);
		this.shiftFW(c,p,i,b);
	}
	mergeWithBufBW(c,a,m,b,p){
		let i=m-1;b--;
		while(b>=m&&i>=a)
			if(compareIndices(c,b,i)>=0)swap(c,--p,b--);
			else swap(c,--p,i--);
		if(p>b)this.shiftBW(c,m,b+1,p);
		this.shiftBW(c,a,i+1,p);
	}
	mergeWithBufFWExt(c,a,m,b,p){
		let i=m;
		while(a<m&&i<b)
			if(compareIndices(c,a,i)<1)write(c,p++,c[a++]);
			else write(c,p++,c[i++]);
		if(a>p)this.shiftFWExt(c,p,a,m);
		this.shiftFWExt(c,p,i,b);
	}
	mergeWithBufBWExt(c,a,m,b,p){
		let i=m-1;b--;
		while(b>=m&&i>=a)
			if(compareIndices(c,b,i)>=0)write(c,--p,c[b--]);
			else write(c,--p,c[i--]);
		if(p>b)this.shiftBWExt(c,m,b+1,p);
		this.shiftBWExt(c,a,i+1,p);
	}

	inPlaceMerge(c,a,m,b){
		while(a<m&&m<b){
			a=Bms.rightBinSearch(c,a,m,c[m]);
			if(a==m)return;
			let i=this.leftBinSearch(c,m,b,c[a]);
			this.rotate(c,a,m,i);
			let t=i-m;m=i;a+=t+1;
		}
	}
	inPlaceMergeBW(c,a,m,b){
		while(b>m&&m>a){
			let i=Bms.rightBinSearch(c,a,m,c[b-1]);
			this.rotate(c,i,m,b);
			let t=m-i;
			m=i;b-=t+1;
			if(m==a)break;
			b=this.leftBinSearch(c,m,b,c[m-1]);
		}
	}
}
//end
function iterativeBitonicSort(){
	let array=[...arr];
	let i,j,k;
	for(k=2;k<len*2;k=2*k){
		let m=(((len+(k-1))/k)%2)!=0;
		for(j=k>>1;j>0;j=j>>1)
			for(i=0;i<len;i++){
				let ij=i^j;
				if(ij>i&&ij<len){
					if((((i&k)==0)==m)&&compareIndices(array,i,ij)>0)swap(array,i,ij);
					if((((i&k)!=0)==m)&&compareIndices(array,i,ij)<0)swap(array,i,ij);
				}
			}
	}
	return[5,1];
}
function batcherBitonicSort(){
	let array=[...arr];
	const bm=(a,l,n,dir)=>{
		if(n<=1)return;
		let m=1
		while(m<<1<n)m<<=1;
		for(let i=l;i<l+n-m;i++)if(dir==(compareIndices(a,i,i+m)==1))swap(a,i,i+m);
		bm(a,l,m,dir);
		bm(a,l+m,n-m,dir);
	}
	const bs=(a,l,n,d)=>{
		if(n<=1)return;
		let m=n/2;
		bs(a,l,m,!d);
		bs(a,l+m,n-m,d);
		bm(a,l,n,d);
	}
	bs(array,0,len,1)
	return[5,1];
}
function iterativeBoseNelsonSort(){
	let array=[...arr];
	let clen=1<<ceil(log(len)/log(2));
	for(let a=2;a<=clen;a*=2)
		for(let b=0;b<a/2;b++)
			for(let c=0;c+b<len;c+=a){
				let g=c,half=(c+a-g)/2,m=g+half;g+=b;
				for(let d=0;d<half-b;d++)if((d&~b)==d)if(m+d<len&&compareIndices(array,g+d,m+d)==1)swap(array,g+d,m+d);
			}
	return[5,1]
}
function recursiveBoseNelsonSort(){
	let array=[...arr];
	const cs=(a,s,e)=>{
		if(compareIndices(a,s,e)>0)swap(a,s,e);
	}
	const bn=(a,s,l)=>{
		if(l<=1)return;
		let m=l/2|0;
		bn(a,s,m);
		bn(a,s+m,l-m);
		bnm(a,s,m,s+m,l-m);
	}
	const bnm=(a,s1,l1,s2,l2)=>{
		if(l1==1&&l2==1)cs(a,s1,s2);
		else if(l1==1&&l2==2){
			cs(a,s1,s2+1);
			cs(a,s1,s2);
		}else if(l1==2&&l2==1){
			cs(a,s1,s2);
			cs(a,s1+1,s2);
		}else{
			let m1=l1/2|0,m2=(l1%2==1?l2/2:(l2+1)/2)|0;
			bnm(a,s1,m1,s2,m2);
			bnm(a,s1+m1,l1-m1,s2+m2,l2-m2);
			bnm(a,s1+m1,l1-m1,s2,m2);
		}
	}
	bn(array,0,len);
	return[5,1]
}
function creaseSort(){
	let array=[...arr];
	let max=1;
	for(;max*2<len;max*=2);
	let nx=max;
	for(;nx>0;nx/=2){
		for(let i=0;i+1<len;i+=2)if(compareIndices(array,i,i+1)==1)swap(array,i,i+1);
		for(let j=max;j>=nx&&j>1;j/=2)for(let i=1;i+j-1<len;i+=2)if(compareIndices(array,i,i+j-1)==1)swap(array,i,i+j-1);
	}
	return[5,1]
}
function iterativeDiamondSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	let m=4;
	for(;m<=n;m*=2){
		for(let k=0;k<m/2;k++){
			let cnt=k<=m/4?k:m/2-k;
			for(let j=0;j<len;j+=m)if(j+cnt+1<len)for(let i=j+cnt;i+1<minVal(len,j+m-cnt);i+=2)if(compareIndices(array,i,i+1)==1)swap(array,i,i+1);
		}
	}
	m/=2;
	for(let k=0;k<=m/2;k++)for(let i=k;i+1<minVal(len,m-k);i+=2)if(compareIndices(array,i,i+1)==1)swap(array,i,i+1);
	return[0,0]
}
function recursiveDiamondSort(){
	let array=[...arr];
	const sort=(ar,s,e,mm)=>{
		if(e-s==2){
			if(compareIndices(ar,s,e-1)>0)swap(ar,s,e-1);
		}else if(e-s>=3){
			let d=(e-s)/4,m=(e-s)/2+s;
			if(mm){
				sort(ar,s,m,1);
				sort(ar,m,e,1);
			}
			sort(ar,d+s|0,d*3+s|0,0);
			sort(ar,s,m,0);
			sort(ar,m,e,0);
			sort(ar,d+s|0,d*3+s|0,0);
		}
	}
	sort(array,0,len,true);
	return[5,1]
}
function foldSort(){
	let array=[...arr];
	let cL=1;
	for(;1<<cL<len;cL++);
	let sz=1<<cL;
	for(let k=sz>>1;k>0;k>>=1)
		for(let i=sz;i>=k;i>>=1)
			for(let j=0;j<len;j+=i){
				let l=j-1,h=j+i
				while(++l<--h)if(h<len&&compareIndices(array,l,h)>0)swap(array,l,h);
			}
	return[5,1]
}
function batcherMergeExchangeSort(){
	let array=[...arr];
	let t=log(len-1)/log(2)+1|0;
	let p0=1<<(t-1);
	for(let p=p0;p>0;p>>=1){
		let q=p0,r=0,d=p;
		while(1){
			for(let i=0;i<len-d;i++)
				if((i&p)==r&&compareIndices(array,i,i+d)>0)swap(array,i,i+d);
			if(q==p)break;
			d=q-p;q>>=1;r=p;
		}
	}
	return[5,1]
}
function recursiveOddEvenMergeSort(){
	let array=[...arr];
	const oemc=(a,i,j)=>{
		if(compareIndices(a,i,j)>0)swap(a,i,j);
	}
	const oem=(a,lo,m2,n,r)=>{
		let m=r*2;
		if(m<n){
			if((n/r|0)%2!=0){
				oem(a,lo,(m2+1)/2,n+r,m);
				oem(a,lo+r,m2/2,n-r,m);
			}else{
				oem(a,lo,(m2+1)/2,n,m);
				oem(a,lo+r,m2/2,n,m);
			}
			if(m2%2|0!=0)for(let i=lo;i+r<lo+n;i+=m)oemc(a,i,i+r);
			else for(let i=lo+r;i+r<lo+n;i+=m)oemc(a,i,i+r);
		}else if(n>r)oemc(a,lo,lo+r);
	}
	const oems=(a,lo,n)=>{
		if(n<=1)return;
		let m=n/2|0;
		oems(a,lo,m);
		oems(a,lo+m,n-m);
		oem(a,lo,m,n,1);
	}
	oems(array,0,len);
	return[5,1]
}
function iterativePairwiseMergeSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n<<=1);
	for(let k=n>>1;k>0;k>>=1)for(let j=0;j<len;j+=k<<1)for(let i=0;i<k;i++)if(j+k+i<len&&compareIndices(array,j+i,j+k+i)>0)swap(array,j+i,j+k+i);
	for(let k=2;k<n;k<<=1)for(let m=k>>1;m>0;m>>=1)for(let j=0;j<len;j+=k<<1)for(let p=m;p<((k-m)<<1);p+=m<<1)for(let i=0;i<m;i++)if(j+p+m+i<len&&compareIndices(array,j+p+i,j+p+m+i)>0)swap(array,j+p+i,j+p+m+i);
	return[5,1]
}
function recursivePairwiseMergeSort(){
	let array=[...arr];
	const pm=(ar,a,b)=>{
		let m=(a+b)/2|0,m1=(a+m)/2|0,g=m-m1;
		for(let i=0;m1+i<m;i++)for(let j=m1,k=g;k>0;k>>=1,j-=k-(i&k))if(j+i+k<len&&compareIndices(ar,j+i,j+i+k)>0)swap(ar,j+i+k,j+i);
		if(b-a>4)pm(ar,m,b);
	}
	const pms=(ar,a,b)=>{
		let m=(a+b)/2;
		for(let i=a,j=m;i<m;i++,j++)if(j<len&&compareIndices(ar,i,j)>0)swap(ar,i,j);
		if(b-a>2){
			pms(ar,a,m);
			pms(ar,m,b);
			pm(ar,a,b);
		}
	}
	let n=1;
	for(;n<len;n<<=1);
	pms(array,0,n);
	return[5,1]
}
function iterativeWeaveSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	for(let i=1;i<n;i*=2)for(let j=1;j<=i;j*=2)for(let k=0;k<n;k+=n/j)for(let d=n/i/2,m=0,l=n/j-d;l>=n/j/2;l-=d)for(let p=0;p<d;p++,m++)if(k+l+p<len&&compareIndices(array,k+m,k+l+p)>0)swap(array,k+m,k+l+p);
	return[5,1]
}
function recursiveWeaveSort(){
	let array=[...arr];
	const cr=(ar,p,l,g)=>{
		if(l<2)return;
		for(let i=0;2*i<(l-1)*g;i+=g)if(p+(l-1)*g-i<len&&compareIndices(ar,p+i,p+(l-1)*g-i)>0)swap(ar,p+i,p+(l-1)*g-i);
		cr(ar,p,l/2|0,g);
		if(p+l*g/2<len)cr(ar,p+l*g/2,l/2,g);
	}
	const wc=(ar,p,l,g)=>{
		if(l<2)return;
		wc(ar,p,l/2,2*g);
		wc(ar,p+g,l/2,2*g);
		cr(ar,p,l,g);
	}
	let n=1;
	for(;n<len;n*=2);
	wc(array,0,n,1);
	return[5,1]
}
function LSDRadixSort(){
	let array=[...arr];
	let base=10,hp=maxLog(array,len,base),vregs=new Array(base);
	for(let i=0;i<base;i++)vregs[i]=[];
	for(let p=0;p<=hp;p++){
		for(let i=0;i<len;i++)vregs[getDigit(array[i],p,base)].push(array[i]);
		fancyTranscribe(array,len,vregs,base*.8|0);
	}
	return[0,1]
}
function MSDRadixSort(){
	let array=[...arr];
	const msd=(a,l,mn,mx,r,p)=>{
		if(mn>=mx||p<0)return;
		let rgs=new Array(r),s=0;
		for(let i=0;i<r;i++)rgs[i]=[];
		for(let i=mn;i<mx;i++)rgs[getDigit(a[i],p,r)].push(a[i]);
		transcribeMSD(a,rgs,0,mn,false);
		for(let i=0;i<rgs.length;i++){
			msd(a,l,s+mn,s+mn+rgs[i].length,r,p-1);
			s+=rgs[i].length;
			rgs[i]=[];
		}
	}
	let hp=maxLog(array,len,4);
	msd(array,len,0,len,4,hp);
	return[5,1]
}
function indexSort(){
	let array=[...arr];
	let min=minVal(array)
	for(let i=0;i<len;i++){
		let c=0;
		while(compareValues(i,array[i]-min)!=0&&c<len)swap(array,i,array[i]-min,0,c++);
		if(c>=len-1)break;
	}
	return[5,1]
}
function bubbleSort(){
	let array=[...arr];
	function cf(ar,i){
		let s=1
		for(let j=0;j<i;j++)
			if(compareIndices(ar,j,j+1)==1){
				swap(ar,j,j+1,true);
				s=0;
			}
		return s;
	}
	for(let i=len-1;i>0;i--){
		customFunc(cf,[i])
		if(cf(array,i))break;
	}
	return[10,1]
}
function circloidSort(){
	let array=[...arr];
	const c=(a,l,r)=>{
		let s=0;
		while(l<r){
			if(compareIndices(a,l,r)==1){
				swap(a,l,r);
				s=1;
			}
			l++;r--;
			if(l==r)r++;
		}
		return s;
	}
	const cp=(a,l,r)=>{
		if(l>=r)return false;
		let m=(l+r)/2|0;
		let lf=cp(a,l,m);
		let rt=cp(a,m+1,r);
		return c(a,l,r)||lf||rt;
	}
	while(cp(array,0,len-1));
	return[5,1]
}
function combSort(){
	let array=[...arr];
	combSortTemp(array,len,1.3);
	return[5,1]
}
function completeGraphSort(){
	let array=[...arr];
	const cs=(ar,a,b)=>{
		if(compareIndices(ar,a,b)>0)swap(ar,a,b);
	}
	const split=(ar,a,m,b)=>{
		if(b-a<2)return;
		let c=0,len1=(b-a)/2|0,odd=(b-a)%2==1;
		if(odd){
			if(m-a>b-m)c=a++;
			else c=--b;
		}
		for(let s=0;s<len1;s++){
			let i=a;
			for(let j=s;j<len1;j++)cs(ar,i++,m+j);
			for(let j=0;j<s;j++)cs(ar,i++,m+j);
		}
		if(odd){
			if(c<m)for(let j=0;j<len1;j++)cs(ar,c,m+j);
			else for(let j=0;j<len1;j++)cs(ar,a+j,c);
		}
	}
	let n=len;
	let d=2,end=1<<(log(n-1)/log(2)|0+1);
	while(d<=end){
		let i=0,dec=0;
		while(i<n){
			let j=i;
			dec+=n;
			while(dec>=d){
				dec-=d;
				j++;
			}
			let k=j;
			dec+=n;
			while(dec>=d){
				dec-=d;
				k++;
			}
			split(array,i,j,k);
			i=k;
		}
		d*=2;
	}
	return[5,1]
}
function funSort(){
	let array=[...arr];
	function bs(ar,start,end,value){
		while(start<end){
			let m=(start+end)>>>1;
			if(compareValues(ar[m],value)<0)start=m+1;
			else end=m;
		}
		return start;
	}
	for(let i=1;i<len;i++){
		let done=false;
		do{
			done=true;
			let p=bs(array,0,len-1,array[i]);
			if(compareIndices(array,p,i)!=0){
				if(i<p-1)swap(array,i,p-1);
				else if(i>p)swap(array,i,p);
				done=false;
			}
		}while(!done);
	}
	return[-.05,1]
}
function cocktailShakerSort(){
	let array=[...arr];
	cocktailShakerTemp(array,0,len)
	return[-.05,1]
}
function gnomeSort(){
	let array=[...arr];
	for(let i=1;i<len;){
		if(compareIndices(array,i,i-1)>=0)i++;
		else{
			swap(array,i,i-1);
			if(i>1)i--;
		}
	}
	return[5,1]
}
function LLQuickSort(){
	let array=[...arr];
	function par(ar,lo,hi){
		let pivot=ar[hi],i=lo;
		for(let j=lo;j<hi;j++)if(compareValues(ar[j],pivot)<0)swap(ar,i++,j);
		swap(ar,i,hi);
		return i;
	}	
	function qs(ar,lo,hi){
		if(lo>=hi)return;
		let p=par(ar,lo,hi);
		qs(ar,lo,p-1);
		qs(ar,p+1,hi);
	}
	qs(array,0,len-1)
	return[5,1]
}
function LRQuickSort(){
	let array=[...arr];
	function quickSort(a,p,r){
		let pivot=p+(r-p+1)/2|0,x=a[pivot],i=p,j=r;
		while(i<=j){
			while(compareValues(a[i],x)<0)i++;
			while(compareValues(a[j],x)>0)j--;
			if(i<=j)swap(a,i++,j--);
		}
		if(p<j)quickSort(a,p,j);
		if(i<r)quickSort(a,i,r);
	}
	quickSort(array,0,len-1);
	return[5,1]
}
function oddEvenSort(){
	let array=[...arr];
	while(!isSorted(array)){
		for(let n=0;n<=len-2;n+=2)if(compareIndices(array,n,n+1)>0)swap(array,n,n+1);
		for(let n=1;n<=len-2;n+=2)if(compareIndices(array,n,n+1)>0)swap(array,n,n+1);
	}
	return[-.05,1]
}
function stoogeSort(){
	let array=[...arr];
	const ss=(a,i,j)=>{
		if(compareIndices(a,i,j)>0)swap(a,i,j);
		if(j-i+1>=3){
			let t=(j-i+1)/3|0;
			ss(a,i,j-t);
			ss(a,i+t,j);
			ss(a,i,j-t);
		}
	}
	ss(array,0,len-1)
	return[4,1]
}
function slopeSort(){
	let array=[...arr];
	for(let i=1,j=1;i<len;i=j,j++)for(let k=i-1;k>=0;k--,i--)if(compareIndices(array,i,k)<0)swap(array,i,k);
	return[5,1]
}
function shellSort(){
	let array=[...arr];
	for(let i=0;!isSorted(array);i++,i%=len){
		for(let n=len/2|0;n>0;n=n/2|0){
			let j,o=array[i];
			for(j=i;j>=n&&compareValues(array[j-n],o)>0;j-=n)swap(array,j,j-n);
			write(array,j,o);
		}
	}
	return[-.1,1]
}

function recursiveShellSort(){
	let array=[...arr];
	function gis(a,b,c,g){
		for(let i=b+g;i<c;i+=g){
			let k=a[i],j=i-g;
			while(j>=b&&compareValues(k,a[j])<0){
				write(a,j+g,a[j]);
				j-=g;
			}
			write(a,j+g,k);
		}
	}
	function rss(a,s,e,g){
		if(s+g>e)return;
		rss(a,s,e,3*g);
		rss(a,s+g,e,3*g);
		rss(a,s+2*g,e,3*g);
		gis(a,s,e,g);
	}
	rss(array,0,len,1);
	return[5,1]
}
function andreySort(){
	let array=[...arr];
	function sort(a,b,c){
		while(c>1){
			let k=0;
			for(let i=1;i<c;i++)if(compareIndices(a,b+k,b+i)>0)k=i;
			swap(a,b,b+k);
			b++;c--;
		}
	}
	function aswap(a,a1,a2,l){
		while(l-->0)swap(a,a1++,a2++);
	}
	function backmerge(a,a1,l1,a2,l2){
		let a0=a2+l1;
		for(;;){
			if(compareIndices(a,a1,a2)>0){
				swap(a,a1--,a0--);
				if(--l1==0)return 0;
			}else{
				swap(a,a2--,a0--);
				if(--l2==0)break;
			}
		}
		let res=l1;
		do swap(a,a1--,a0--);while(--l1!=0);
		return res;
	}
	function rmerge(ar,a,l,r){
		for(let i=0;i<l;i+=r){
			let q=i;
			for(let j=i+r;j<l;j+=r)if(compareIndices(ar,a+q,a+j)>0)q=j;
			if(q!=i)aswap(ar,a+i,a+q,r);
			if(i!=0){
				aswap(ar,a+l,a+i,r);
				backmerge(ar,a+(l+r-1),r,a+(i-1),r);
			}
		}
	}
	function rbnd(l){
		l/=2;l|=0;
		let k=0;
		for(let i=1;i<l;i*=2)k++;
		l/=k;l|=0;
		for(k=1;k<=l;k*=2);
		return k;
	}
	function msort(ar,a,l){
		if(l<12)return sort(ar,a,l);
		let r=rbnd(l),lr=(l/r-1|0)*r;
		for(let p=2;p<=lr;p+=2){
			if(compareIndices(ar,a+(p-2),a+(p-1))>0)
				swap(ar,a+(p-2),a+(p-1));
			if((p&2)!=0)continue;
			aswap(ar,a+(p-2),a+p,2);
			let m=l-p,q=2;
			for(;;){
				let q0=q*2;
				if(q0>m||(p&q0)!=0)break;
				backmerge(ar,a+(p-q-1),q,a+(p+q-1),q);
				q=q0;
			}
			backmerge(ar,a+(p+q-1),q,a+(p-q-1),q);
			let q1=q;
			q*=2;
			while((q&p)==0){
				q*=2;
				rmerge(ar,a+(p-q),q,q1);
			}
		}
		let q1=0;
		for(let q=r;q<lr;q*=2){
			if((lr&q)!=0){
				q1+=q;
				if(q1!=q)rmerge(ar,a+(lr-q1),q1,r);
			}
		}
		let s=l-lr;
		msort(ar,a+lr,s);
		aswap(ar,a,a+lr,s);
		msort(ar,a,s+=backmerge(ar,a+s-1,s,a+lr-1,lr-s));
	}
	msort(array,0,len);
	return[5,1]
}
function blockSwapMergeSort(){
	let array=[...arr];
	const bin=(ar,s,md,e)=>{
		let a=0,b=minVal(md-s,e-md),m=a+(b-a)/2|0;
		while(b>a){
			if(compareIndices(ar,md-m-1,md+m)==1)a=m+1;
			else b=m;
			m=a+(b-a)/2|0;
		}
		return m;
	}
	const msm=(a,s,md,e)=>{
		let m=bin(a,s,md,e);
		while(m>0){
			for(let i=0;i<m;i++)
				swap(a,md-m+i,md+i);
			msm(a,md,md+m,e);
			e=md;
			md-=m;
			m=bin(a,s,md,e);
		}
	}
	const msms=(a,b,c)=>{
		let len=c-b,i;
		for(let j=1;j<len;j*=2){
			for(i=b;i+2*j<=c;i+=j*2)
				msm(a,i,i+j,i+j*2);
			if(i+j<c)
				msm(a,i,i+j,c);
		}
	}
	msms(array,0,len);
	return[5,1]
}
function inPlaceMergeSort(){
	let array=[...arr];
	const push=(ar,p,a,b)=>{
		if(a==b)return;
		let tmp=ar[p];
		write(ar,p,ar[a]);
		for(let i=a+1;i<b;i++)
			write(ar,i-1,ar[i]);
		write(ar,b-1,tmp);
	}
	const M=(a,b,m,c)=>{
		let i=b,j=m;
		while(i<m&&j<c)
			if(compareIndices(a,i,j)==1)j++;
			else push(a,i++,m,j);
		while(i<m)push(a,i++,m,c);
	}
	const ms=(a,b,c)=>{
		let m=b+(c-b)/2|0;
		if(c-b>2){
			if(c-b>3)
				ms(a,b,m);
			ms(a,m,c);
		}
		M(a,b,m,c);
	}
	ms(array,0,len);
	return[-.05,1]
}
function rotateMergeSort(){
	let array=[...arr];
	function rotate(ar,a,m,b){
		IndexRots.griesMills(ar,a,m,b,false);
	}
	function bs(ar,a,b,value,left){
		while(a<b){
			let m=a+(b-a)/2|0,comp=left?compareValues(value,ar[m])<1:compareValues(value,ar[m])<0;
			if(comp)b=m;
			else a=m+1;
		}
		return a;
	}
	function rotateMerge(ar,a,m,b){
		let m1,m2,m3;
		if(m-a>=b-m){
			m1=a+(m-a)/2|0;
			m2=bs(ar,m,b,ar[m1],true);
			m3=m1+(m2-m);
		}else{
			m2=m+(b-m)/2|0;
			m1=bs(ar,a,m,ar[m2],false);
			m3=(m2++)-(m-m1);
		}
		rotate(ar,m1,m,m2);
		if(m2-m3+1>0&&b-m2>0)rotateMerge(ar,m3+1,m2,b);
		if(m1-a>0&&m3-m1>0)rotateMerge(ar,a,m1,m3);
	}
	function rotateMergeSort(ar,a,b){
		let len=b-a,i;
		for(let j=1;j<len;j*=2){
			for(i=a;i+2*j<=b;i+=2*j)rotateMerge(ar,i,i+j,i+2*j);
			if(i+j<b)rotateMerge(ar,i,i+j,b);
		}
	}
	rotateMergeSort(array,0,len);
	return[5,1]
}
function strandSort(){
	let array=[...arr];
	function mergeTo(array,subList,a,m,b){
		let i=0,s=m-a;
		while(i<s&&m<b)
			if(compareValues(subList[i],array[m])<0)write(array,a++,subList[i++]);
			else write(array,a++,array[m++]);
		while(i<s)write(array,a++,subList[i++]);
	}
	let subList=new Array(len),j=len,k=j;
	while(j>0){
		write(subList,0,array[0]);
		for(let i=0,p=0,m=1;m<j;m++){
			if(compareValues(array[m],subList[i])>=0){
				write(subList,++i,array[m],true);
				k--;
			}else write(array,p++,array[m]);
		}
		mergeTo(array,subList,--k,j,len);
		j=k;
	}
	return[-.01,1]
}
function weavedMergeSort(){
	let array=[...arr];
	function merge(array,tmp,length,residue,modulus){
		if(residue+modulus>=length)return;
		let low=residue;
		let high=residue+modulus;
		let dmodulus=modulus<<1;
		merge(array,tmp,length,low,dmodulus);
		merge(array,tmp,length,high,dmodulus);
		let nxt=residue;
		for(;low<length&&high<length;nxt+=modulus){
			let cmp=compareIndices(array,low,high);
			if(cmp==1||cmp==0&&low>high){
				write(tmp,nxt,array[high],true);
				high+=dmodulus;
			}else{
				write(tmp,nxt,array[low],true);
				low+=dmodulus;
			}
		}
		if(low>=length){
			while(high<length){
				write(tmp,nxt,array[high],true);
				nxt+=modulus;
				high+=dmodulus;
			}
		}else{
			while(low<length){
				write(tmp,nxt,array[low],true);
				nxt+=modulus;
				low+=dmodulus;
			}
		}
		for(let i=residue;i<length;i+=modulus)
			write(array,i,tmp[i]);
	}
	let tmp=new Array(len);
	merge(array,tmp,len,0,1);
	return[-.01,1]
}
function pancakeSort(){
	let array=[...arr];
	let i=len
	while(i>=0&&!isSorted(array)){
		let c=getMaxIndex(array,i);
		if(c!=--i){
			reversal(array,0,c,false)
			reversal(array,0,i,false)
		}
	}
	return[5,1]
}
function maxHeapSort(){
	let array=[...arr];
	heapSort(array,0,len,true)
	return[-.01,1]
}
function minHeapSort(){
	let array=[...arr];
	heapSort(array,0,len,false)
	return[-.01,1]
}
function cycleSort(){
	let array=[...arr];
	let i=0
	while(i<len){
		let c=array[i]-1;
		if(compareIndices(array,i,c)!=0)
			swap(array,i--,c)
		i++
	}
	return[5,1]
}
function inPlaceMSDRadixSort(){
	let array=[...arr];
	const radixMSD=(a,l,min,max,r,p)=>{
		if(min>=max||p<0)return;
		let b=new Array(r);
		for(let i=0;i<r;i++)b[i]=min;
		for(let i=min;i<max;i++){
			let t=a[i],d=getDigit(t,p,r);
			for(let j=r-1;j>d;j--){
				if(b[j]!=b[j-1])
					write(a,b[j],a[b[j-1]]);
				write(b,j,b[j]+1,true);
			}
			write(a,b[d],t);
			write(b,d,b[d]+1,true);
		}
		for(let i=0;i<r;i++)radixMSD(a,l,i==0?min:b[i-1],b[i],r,p-1);
	}
	let base=4
	let hp=maxLog(array,len,base);
	radixMSD(array,len,0,len,base,hp);
	return[5,1]
}
function asteraceaeSort(){
	let array=[...arr];
	function cf(ar,l){
		let i=1,fs=2,as=1,ls=0;
		if(fs-1==0)i=1;
		else i=fs-1;
		as=0;ls=0;
		while(i<len){
			if(compareIndices(ar,i-1,i)>0){
				swap(ar,i-1,i++,1);
				if(!as)fs=i-1;
				as=ls=1;
			}else{
				if(ls)i+=floor(sqrt(l));
				else i++;
				ls=0;
			}
		}
		return as
	}
	let as=1;
	while(as){
		as=cf(array,len)
		customFunc(cf,[len])
	}
	return[5,0]
}
function LMSDRadixSort(){
	let array=[...arr];
	function radixSort(a,s,e,p){
		let regs=new Array(base);
		for(let i=0;i<base;i++)regs[i]=[];
		for(let i=s;i<e;i++){
			let digit=getDigit(a[i],p,base);
			regs[digit]=regs[digit].concat([a[i]]);
		}
		let c=s;
		for(let i=0;i<base;i++)
			for(let j=0;j<regs[i].length;j++)
				write(a,c++,regs[i][j])
		return regs;
	}
	function lmsdRadixSort(array,mina,maxa,place,maxPlace){
		if(maxPlace<place||maxa-mina<=1)return;
		let regs=radixSort(array,mina,maxa,place);
		if(place!=maxPlace){
			regs=radixSort(array,mina,maxa,maxPlace);
			let sum=0;
			for(let i=0;i<regs.length;i++){
				lmsdRadixSort(array,sum+mina,sum+mina+regs[i].length,place+1,maxPlace-1);
				sum+=regs[i].length;
			}
		}
	}
	let base=4;
	let hp=maxLog(array,len,base);
	lmsdRadixSort(array,0,len,0,hp);
	return[0,1]
}
function awkwardSort(){
	let array=[...arr];
	const awkward=(arr,l,p)=>{
		if(l==1)return;
		l|=0
		p|=0
		awkward(arr,l/2,p);
		awkward(arr,l/2+l%2,p+l/2);
		for(let i=0;i<l/2;i++){
			let a=p+i;
			let b=p+l/2+l%2+i;
			if(compareIndices(arr,a,b)==1)
				swap(arr,a,b);
		}
		awkward(arr,l/2+l%2,p+l/4);
		awkward(arr,l/2,p);
		awkward(arr,l/2+l%2,p+l/2);
	}
	awkward(array,len,0);
	return[5,1]
}
function chinottoSort(){
	let array=[...arr];
	let d=0;
	let gap=1;
	while(!d){
		let i=0;
		d=1;
		for(;i+gap<len;i++){
			if(compareIndices(array,i,i+gap)==1){
				d=0;
				multiSwap(array,i,i+gap,undefined);
				gap++;
			}else if(gap>=2)gap--;
		}
		for(;i-gap>0;i--){
			if(compareIndices(array,i-gap,i)==1){
				d=0;
				multiSwap(array,i,i-gap,undefined);
				gap++;
			}else if(gap>=2)gap--;
		}
	}
	return[5,1]
}
function circleMergeSort(){
	let array=[...arr];
	const csr=(a,l)=>{
		let sc=0;
		for(let g=l/2;g>circleDepth;g/=2){
			for(let s=0;s+g<len;s+=2*g){
				let h=s+2*g-1|0;
				let lw=s|0;
				for(;lw<h;){
					if(h<len&&compareIndices(a,lw,h)>0)
						swap(a,lw,h,0,sc++);
					lw++;h--;
				}
			}
		}
		return sc;
	}
	for(let n=1;n<=len;n*=2)
		while(csr(array,n));
	return[5,1]
}
function clamberSort(){
	let array=[...arr];
	for(let i=1;i<len;i++)
		for(let j=0;j<i;j++)
			if(compareIndices(array,i,j)<0)
				swap(array,i,j);
	return[5,1]
}
function cocktailGrateSort(){
	let array=[...arr];
	let n=1;
	while(n){
		n=0;
		let i,j;
		for(i=0;i<len-1;i++){
			for(j=len-1;j>i;j--){
				if(compareIndices(array,i,j)>0){
					n=1;
					swap(array,i,j);
					break;
				}
			}
		}
		if(!n)break;
		for(i=0;i<len-1;i++){
			for(j=i+1;j<len;j++){
				if(compareIndices(array,i,j)>0){
					swap(array,i,j);
					break;
				}
			}
		}
	}
	return[5,1]
}
function cocktailPushSort(){
	let array=[...arr];
	let as=1;
	function cf(ar,a,b,s,g){
		for(let j=1;j<=g;j++)
			swap(ar,a,b+j*s,1);
	}
	while(as){
		as=0;
		let i=1,g=1;
		while(i+g<=len){
			if(compareIndices(array,i-1,i-1+g)>0){
				cf(array,i-1,i-1,1,g)
				customFunc(cf,[i-1,i-1,1,g])
				as=1
				g++;
			}else i++;
		}
		i=len;
		g=1;
		while(i-g>0){
			if(compareIndices(array,i-1-g,i-1)>0){
				cf(array,i-1,i-1,-1,g)
				customFunc(cf,[i-1,i-1,-1,g])
				as=1
				g++;
			}else i--;
		}
	}
	return[0,0]
}
function dandelionSort(){
	let array=[...arr];
	for(let b=0;b<len;){
		let pointer=b;
		let as=0;
		while(pointer<len-1&&compareIndices(array,pointer+1,pointer)<0){
			swap(array,pointer,pointer+1);
			as=1;
			pointer++;
		}
		if(as){
			if(b>0)b--;
			continue;
		}
		b++;
	}
	return[5,0]
}
function floatSort(){
	let array=[...arr];
	let n=1;
	while(n){
		let h=0;
		n=0;
		for(let g=len-1;g>0;g--){
			let i=h;
			let j=h+1;
			while(i>=0&&compareIndices(array,i,j)>0){
				swap(array,i--,j--);
				n=1;
			}
			if(i>=0){
				i++;
				j++;
				while(j<len&&compareIndices(array,i,j)>0){
					swap(array,i++,j++);
					n=1;
				}
			}
			h++;
		}
	}
	return[5,1]
}
function iterativeQuickSort(){
	let array=[...arr];
	let s=0,e=len-1
	let st=new Array(len);
	let top=-1;
	write(st,++top,s,true);
	write(st,++top,e,true);
	while(top>=0){
		e=st[top--];
		s=st[top--];
		let pv=array[e];
		let i=s-1;
		for(let j=s;j<e;j++)
			if(compareValues(array[j],pv)<1)
				swap(array,++i,j);
		swap(array,++i,e);
		let p=i
		if(compareValues(p-1,s)==1){
			write(st,++top,s,true);
			write(st,++top,p-1,true);
		}
		if(compareValues(e,p+1)==1){
			write(st,++top,p+1,true);
			write(st,++top,e,true);
		}
	}
	return[5,1]
}
function indexQuickSort(){
	let array=[...arr];
	const iqs=(array,idx,a,b)=>{
		while(a<b){
			if(compareValues(a,idx[a])!=0){
				let t=array[a];
				let i=a,nxt=idx[a];
				do{
					write(array,i,array[nxt]);
					write(idx,i,i,true);
					i=nxt;
					nxt=idx[nxt];
				}while(compareValues(nxt,a)!=0);
				write(array,i,t);
				write(idx,i,i,true);
			}
			a++;
		}
	}
	const sort=(array,idx,a,b)=>{
		if(b-a<2)return;
		let c0=a,c1=c0,i;
		let m=a+random()*(b-a)|0;
		for(i=a;i<m;i++)
			if(compareIndices(array,i,m)<1)
				c1++;
		i++;
		c1++;
		for(;i<b;i++)
			if(compareIndices(array,i,m)<0)
				c1++;
		let p=c1-1;
		for(i=a;i<m;i++){
			if(compareIndices(array,i,m)<1)
				write(idx,c0++,i,true);
			else write(idx,c1++,i,true);
		}
		write(idx,p,i++,true);
		for(;i<b;i++){
			if(compareIndices(array,i,m)<0)
				write(idx,c0++,i,true);
			else write(idx,c1++,i,true);
		}
		iqs(array,idx,a,b);
		sort(array,idx,a,p);
		sort(array,idx,p+1,b);
	}
	let idx=new Array(len);
	sort(array,idx,0,len);
	return[5,1]
}
function pseudoHeapSort(){
	let array=[...arr];
	function sift_down(array,start,length,root){
		let swapped=0;
		let j=root;
		while(2*j<length){
			let k=2*j;
			if(k<length&&compareIndices(array,start+k-1,start+k)==1)k++;
			if(compareIndices(array,start+j-1,start+k-1)==1){
				swap(array,start+j-1,start+k-1);
				j=k;
				swapped=1;
				continue;
			}
			break;
		}
		return swapped;
	}
	let s=1
	while(s--)for(let i=len-2;i>=0;i--)sift_down(array,i,len-i+1,1)&&(s=1)
	return[1,1]
}
function iterativeCircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(icsr(array,n));
	return[5,1]
}
function recursiveCircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rcsr(array,0,n-1,0,len));
	return[5,1]
}
function LLQuickSortMiddlePivotSort(){
	let array=[...arr];
	function partition(array,a,b){
		let i=a,j=i,m=(a+b)/2|0;
		while(j<m){
			if(compareIndices(array,j,m)<1)
				swap(array,i++,j);
			j++;
		}
		swap(array,i,m);
		j=m+1;
		m=i++;
		while(j<b){
			if(compareIndices(array,j,m)<0)
				swap(array,i++,j);
			j++;
		}
		swap(array,--i,m);
		return i;
	}
	function quickSort(array,a,b){
		if(b-a>1){
			let p=partition(array,a,b);
			quickSort(array,a,p);
			quickSort(array,p+1,b);
		}
	}
	quickSort(array,0,len);
	return[5,1]
}
function pushSort(){
	let array=[...arr];
	let as=1;
	let i=1;
	let gap=1;
	function cf(a,g,i){
		for(let j=1;j<=g;j++)
			swap(a,i-1,i-1+j,1);
	}
	while(as){
		as=0;
		i=1;
		gap=1;
		while(i+gap<=len){
			if(compareIndices(array,i-1,i-1+gap)>0){
				cf(array,gap,i);
				customFunc(cf,[gap,i]);
				as=1;
				gap++;
			}else i++;
		}
	}
	return[5,0]
}
function reflectionSort(){
	let array=[...arr];
	let as=1,i=0;
	while(as){
		i=0;as=0;
		while(i<len){
			if(compareIndices(array,i,i+1)>0){
				swap(array,i,i+1);
				i=(len-1)-i;as=1;
			}else i++;
		}
		i=len;as=0;
		while(i>1){
			if(compareIndices(array,i-1,i)>0){
				swap(array,i-1,i);
				i=(len-1)-i;as=1;
			}else i--;
		}
	}
	return[5,1]
}
function splitCenterSort(){
	let array=[...arr];
	let way=1;
	let i=1;
	for(let r=1;r<len;r++){
		i=len/2|0;
		while(i<len&&i>0){
			if(compareIndices(array,i-1,i)>0)swap(array,i-1,i);
			i+=way;
		}
		way*=-1;
	}
	return[5,1]
}
function wiggleSort(){
	let array=[...arr];
	const ws=(a,l,s,e)=>{
		if(e-s<2)return;
		let lp=s,rp=e,mp=(lp+rp)/2|0,sl=1,j=mp;
		for(let i=lp;i<mp;i++){
			for(let k=mp;k<e;k++){
				if(compareIndices(a,i,j)>=0)swap(a,i,j);
				if(sl)j++;
				else j--;
			}
			if(sl)j--;
			else j++;
			sl=!sl
		}
		ws(a,l,s,mp);
		ws(a,l,mp,e);
	}
	ws(array,len,0,len);
	return[5,1]
}
function zipperSort(){
	let array=[...arr];
	let i=0,gap=2,f=0;
	while(gap>1){
		gap=1;
		i=f>1?f-1:0;
		while(i+gap<len){
			if(compareIndices(array,i,i+gap)>0){
				swap(array,i,i+gap);
				if(gap==1)f=i;
				gap++;
			}else i++;
		}
	}
	return[5,1]
}
function pairwiseCircleSort(){
	let array=[...arr];
	const pairs=(ar,l,r,g)=>{
		if(l+g>=r)return;
		let a=l;
		while(a+g<=r){
			if(compareIndices(ar,a,a+g)==1)
				swap(ar,a,a+g);
			a+=g*2;
		}
		pairs(ar,l,r,g*2);
		pairs(ar,l+g,r,g*2);
	}
	const circle=(ar,l,r)=>{
		let a=l,b=r;
		while(l<r){
			if(compareIndices(ar,l,r)==1)
				swap(ar,l,r);
			l++;r--;
		}
	}
	const pairCircle=(a,l,r)=>{
		if(l>=r)return;
		let m=(l+r)/2|0;
		pairs(a,l,r,1);
		circle(a,l,r);
		pairCircle(a,l,m);
		pairCircle(a,m+1,r);
	}
	pairCircle(array,0,len-1);
	insertSort(array,0,len);
	return[5,1]
}
function iterativeSinkingMergeSort(){
	let array=[...arr];
	const bs=(a,s,e)=>{
		let cs=1;
		for(let i=e-1;i>s;i-=cs){
			cs=1;
			for(let j=s;j<i;j++){
				if(compareIndices(a,j,j+1)>0){
					swap(a,j,j+1);
					cs=1;
				}else cs++;
			}
		}
	}
	let mRun=len;
	for(;mRun>=32;mRun=(mRun+1)/2);
	let i;
	for(i=0;i+mRun<len;i+=mRun)
		bs(array,i,i+mRun);
	bs(array,i,len);
	for(let j=mRun;j<len;j*=2){
		for(i=0;i+2*j<=len;i+=2*j)
			bs(array,i,i+2*j);
		if(i+j<len)
			bs(array,i,len);
	}
	return[5,0]
}
function recursiveSinkingMergeSort(){
	let array=[...arr];
	const bs=(a,s,e)=>{
		let cs=1;
		for(let i=e-1;i>s;i-=cs){
			cs=1;
			for(let j=s;j<i;j++){
				if(compareIndices(a,j,j+1)>0){
					swap(a,j,j+1);
					cs=1;
				}else cs++;
			}
		}
	}
	function sort(a,s,e){
		if(e-s>16){
			let m=s+(e-s)/2|0;
			sort(a,s,m);
			sort(a,m,e);
			bs(a,s,e);
		} else
			bs(a,s,e);
	}
	sort(array,0,len);
	return[5,0]
}
function cocktailShellSort(){
	let array=[...arr];
	let g=len/2;
	let dir=1;
	while(g>=1){
		if(dir){
			for(let i=g;i<len;i++){
				let tmp=array[i],j=i;
				while(j>=g&&compareValues(array[j-g],tmp)==1){
					write(array,j,array[j-g]);
					j-=g;
				}
				write(array,j,tmp);
			}
		}else{
			for(let i=len-g;i>=0;i--){
				let tmp=array[i],j=i;
				while(j<len-g&&compareValues(array[j+g],tmp)==-1){
					write(array,j,array[j+g]);
					j+=g;
				}
				write(array,j,tmp);
			}
		}
		g/=2;
		dir=!dir;
	}
	return[5,1]
}
function indexMergeSort(){
	let array=[...arr];
	function sort(ar,idx,a,b){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		sort(ar,idx,a,m);
		sort(ar,idx,m,b);
		let i=a,j=m,c=a;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<1)write(idx,c++,i++,true);
			else write(idx,c++,j++,true);
		}
		while(i<m)write(idx,c++,i++,true);
		while(j<b)write(idx,c++,j++,true);
		while(a<b){
			if(compareValues(a,idx[a])!=0){
				let t=array[a];
				let i=a,nxt=idx[a];
				do{
					write(array,i,array[nxt]);
					write(idx,i,i,true);
					i=nxt;
					nxt=idx[nxt];
				}while(compareValues(nxt,a)!=0);
				write(array,i,t);
				write(idx,i,i,true);
			}
			a++;
		}
	}
	let idx=new Array(len);
	sort(array,idx,0,len);
	return[5,1]
}
function mobMergeSort(){
	let array=[...arr];
	const bubble=(array,start,end)=>{
		let c=1,s,f=start+((end-start)/2)|0,a=false;
		for(let j=end-1;j>0;j-=c){
			if(f-1<start)s=start;
			else s=f-1;
			a=false;
			c=1;
			for(let i=s;i<j;i++){
				if(compareIndices(array,i,i+1)>0){
					swap(array,i,i+1);
					if(!a)f=i;
					a=true;c=1;
				}else c++;
			}
		}
	}
	let l=2,index=0;
	while(l<=len){
		index=0;
		while(index+l<=len){
			if(l==2){
				if(compareIndices(array,index,index+1)>0)swap(array,index,index+1);
			}else bubble(array,index,index+l);
			index+=l;
		}
		if(index!=len)bubble(array,index,len);
		l*=2;
	}
	bubble(array,0,len);
	return[5,0]
}
function moduloMergeSort(){
	let array=[...arr];
	const mr=(a,s,m,e,mx)=>{
		let l=s,r=m+1,f=s;
		while(l<=m&&r<=e){
			if(compareValues(a[l]%mx,a[r]%mx)<1)write(a,f,a[f]+(a[l++]%mx)*mx);
			else write(a,f,a[f]+(a[r++]%mx)*mx);
			f++;
		}
		while(l<=m)write(a,f,a[f++]+(a[l++]%mx)*mx);
		while(r<=e)write(a,f,a[f++]+(a[r++]%mx)*mx);
		for(let i=s;i<=e;i++)write(a,i,a[i]/mx);
	}
	const ms=(a,s,e,mx)=>{
		if(s>=e)return;
		let m=s+((e-s)/2)|0;
		ms(a,s,m,mx);
		ms(a,m+1,e,mx);
		mr(a,s,m,e,mx);
	}
	ms(array,0,len-1,getMax(array,len)+1);
	return[5,1]
}
function split16MergeSort(){
	let array=[...arr];
	let m16s=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16,1,5,9,13,2,6,10,14,3,7,11,15,4,8,12,16,1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16,6,11,7,10,4,13,14,15,8,12,2,3,5,9,2,5,8,14,3,9,12,15,6,7,10,11,3,5,12,14,4,9,8,13,7,9,11,13,4,6,8,10,4,5,6,7,8,9,10,11,12,13,7,8,9,10];
	const cs1=(a,b,c)=>{
		if(compareIndices(a,b,c)>0)
			swap(a,b,c);
	}
	const cs2=(a,b,c,g,s)=>{
		if(compareIndices(a,s+b*g,s+c*g)>0)
			swap(a,s+b*g,s+c*g);
	}
	const mos=(a,b,g)=>{
		for(let i=0;i<m16s.length;i+=2)
			cs2(a,m16s[i]-1,m16s[i+1]-1,g,b);
	}
	const merge=(a,st,sz)=>{
		let gap=sz/16;
		for(let i=0;i<gap;i++)mos(a,st+i,gap);
		for(let s=gap/2;s>0;s/=2)
			for(let i=0;i<sz-s;i++)
				cs1(a,st+i,st+i+s);
	}
	for(let i=0;i<len-15;i+=16)mos(array,i,1);
	for(let g=32;g<=len;g*=2)
		for(let i=0;i+g<=len;i+=g)
			merge(array,i,g);
	return[5,1]
}
function cbrtQuickSort(){
	let array=[...arr];
	const sort=(a,start,stop)=>{
		let l=stop-start;
		if(l>=2){
			let root=cbrt(l)|0;
			let newStart=start+root;
			sort(a,start,newStart);
			let pivots=new Array(root);
			for(let i=0;i<root;i++)write(pivots,i,i+start,true);
			for(let i=newStart;i<stop;i++){
				let left=0,right=root;
				while(left<right){
					let m=(right-left)/2+left|0;
					if(compareIndices(a,pivots[m],i)==1)right=m;
					else left=m+1;
				}
				let p=i;
				for(let j=root-1;j>=left;j--){
					swap(a,pivots[j]+1,p);
					swap(a,p=pivots[j],pivots[j]+1);
					write(pivots,j,pivots[j]+1,true);
				}
			}
			sort(a,start,pivots[0]);
			for(let i=1;i<root;i++)
				sort(a,pivots[i-1]+1,pivots[i]);
			sort(a,pivots[root-1]+1,stop);
		}
	}
	sort(array,0,len)
	return[5,1]
}
function apollyonSort(){
	let array=[...arr];
	const apm=(A,lo,n,d)=>{
		if(n<=1)return;
		let m=1;
		while(m<<1<n)m<<=1;
		for(let i=lo;i<lo+n-m;i++)
			if(d==(compareIndices(A,i,i+m)==1))
				swap(A,i,i+m)
		apm(A,lo,m,d);
		apm(A,lo+m,n-m,d);
	}
	const aps=(A,lo,n,d)=>{
		if(n<=1)return;
		let m=n/2|0;
		aps(A,lo,m,!d);
		apm(A,lo,n,d);
	}
	aps(array,0,len,1);
	while(rcsr(array,0,len-1,0));
	return[5,1]
}
function optimizedPancakeSort(){
	let array=[...arr];
	function cursedRotate(a,b,m,c){
		reversal(a,0,b-1,0);
		reversal(a,0,m-1,0);
		reversal(a,0,c-1,0);
		reversal(a,0,c-m+b-1,0);
	}
	function bs(ar,a,b,v,l){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(l?compareValues(v,ar[m])<1:compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function pm(array,m,b){
		let m1,m2,m3;
		if(m>=b-m){
			m1=m/2|0;
			m2=bs(array,m,b,array[m1],0);
			m3=m1+(m2-m);
		}else{
			m2=m+(b-m)/2|0;
			m1=bs(array,0,m,array[m2],1);
			m3=(m2++)-(m-m1);
		}
		cursedRotate(array,m1,m,m2);
		if(m1>0&&m3>m1)pm(array,m1,m3);
		m3++;
		if(m2>m3&&b>m2){
			cursedRotate(array,0,m3,b);
			pm(array,m2-m3,b-m3);
			cursedRotate(array,0,b-m3,b);
		}
	}
	function pms(array,n){
		if(n<=1)return;
		if(compareIndices(array,0,1)<1){
			let i=2;
			for(;i<n&&compareIndices(array,i-1,i)<1;i++);
			if(i==n)return;
		}else{
			let i=2;
			for(;i<n&&compareIndices(array,i-1,i)>0;i++);
			if(i==n){
				reversal(array,0,n-1,0);
				return;
			}
		}
		let m=n/2|0;
		pms(array,m);
		cursedRotate(array,0,m,n);
		m=n-m;
		pms(array,m);
		pm(array,m,n);
	}
	pms(array,len);
	return[5,1]
}
function magneticaQuickSort(){
	let array=[...arr];
	let left=0,right=len-1,threshold=17,i,j,pl,pr,entries=right-left+1,stack=new Array(entries),stackptr=2,p,lback=left,rback=right,midmid,gear=0,cmp;
	write(stack,1,left,true);
	write(stack,2,right,true);
	do{
		right=stack[stackptr];
		left=stack[stackptr-1];
		stackptr-=2;
		for(;left+threshold<right;){
			j=right;
			pl=left;
			pr=left;
			if(right-left>31){
				midmid=left+((right-left)>>2);
				if(gear==0){
					insertSort(array,midmid,midmid+3);
					swap(array,midmid+1,pr);
				}else{
					insertSort(array,midmid,midmid+7);
					swap(array,midmid+3,pr);
				}
			}
			p=array[pr];
			for(;pr<j;){
				pr++;
				cmp=compareValues(p,array[pr]);
				if(cmp>0){
					swap(array,pl,pr);
					pl++;
				}else if(cmp<0){
					for(;compareValues(p,array[j])<0;)j--;
					if(pr<j)swap(array,pr,j);
					j--;
					pr--;
				}
			}
			j=pl-1;
			i=pr+1;
			gear=(maxVal(right-i,j-left)>(minVal(right-i,j-left)<<6)?1:0);
			if(i+threshold<right){
				stackptr+=2;
				write(stack,stackptr-1,i,true);
				write(stack,stackptr,right,true);
				stackptr*=(stackptr+2<=entries-1?1:0);
				right*=(stackptr+2<=entries-1?1:0);
			}
			right=j;
		}
	}while(stackptr!=0);
	insertSort(array,lback,rback+1);
	return[5,1]
}
function cocktailPeelSort(){
	let array=[...arr];
	for(let l=0;l<len;l++){
		let s=0;
		for(let r=len-1;r>l;r--){
			if(compareIndices(array,l,r+s)>0){
				let i=array[r+s];
				for(let p=r+s;p>l;p--)write(array,p,array[p-1]);
				write(array,l,i);
				s++;
			}
		}
		l++;
		for(let r=l+1;r<len;r++){
			if(compareIndices(array,l,r)>0){
				let i=array[r];
				for(let p=r;p>l;p--)write(array,p,array[p-1]);
				write(array,l,i);
			}
		}
	}
	return[5,1]
}
function ecoloSort(){
	let array=[...arr];
	let l=1,r=len,w=1,i=1;
	while(l<=r){
		if(w==1)i=l;
		else i=r;
		while((w==1&&i<r)||(w==-1&&i>l)){
			if(compareIndices(array,l-1,i-1)>0)swap(array,l-1,i-1);
			if(compareIndices(array,i-1,r-1)>0)swap(array,i-1,r-1);
			i+=w;
		}
		l++;r--;w*=-1;
	}
	return[5,1]
}
function fallSort(){
	let array=[...arr];
	let l=1;
	let r=2;
	let hl=0;
	while(l<=len){
		r=l+1;
		hl=0;
		while(r<=len){
			if(compareIndices(array,l-1,r-1)>0){
				if(hl==0)hl=r;
				else if(compareIndices(array,hl-1,r-1)<0)hl=r;
			}
			r++;
		}
		if(hl==0)l++;
		else swap(array,l-1,hl-1);
	}
	return[5,1]
}
function heavyHeapSort(){
	let array=[...arr];
	function bitReversal(ar,a,b){
		let len=b-a,m=0;
		let d1=len>>1,d2=d1+(d1>>1);
		for(let i=1;i<len-1;i++){
			let j=d1;
			for(let k=i,n=d2;(k&1)==0;j-=n,k>>=1,n>>=1);
			m+=j;
			if(m>i)swap(ar,a+i,a+m);
		}
	}
	let d=0;
	for(let i=0;i<len;i++){
		heapify(array,i,len,d,1);
		customFunc(heapify,[i,len,d++,1])
		d%=2
	}
	let n=1;
	while(n<=len)n+=2;
	while(n>=0)
		if(compareIndices(array,n,n-2)>0)swap(array,n,n-2,0,n+=2)
		else n-=2
	bitReversal(array,0,len);
	bitReversal(array,0,len/2|0);
	bitReversal(array,len/2|0,len);
	return[15,1]
}
function sandPaperSort(){
	let array=[...arr];
	for(let i=0;i<len-1;i++)
		for(let j=i+1;j<len;j++)
			if(compareIndices(array,i,j)>0)
				swap(array,i,j);
	return[5,1]
}
function recursiveBurningSort(){
	let array=[...arr];
	function sort(array,start,end){
		if(start==end)return;
		let mid=(start+end)/2|0,g0=mid-start;
		if (start==mid)return;
		sort(array,start,mid);
		sort(array,mid,end);
		for(let i=0;i<g0;i++)
			if(i+start!=end-i-1&&compareIndices(array,i+start,end-i-1)==1)
				swap(array,i+start,end-i-1);
		sort(array,start,mid);
		sort(array,mid,end);
	}
	sort(array,0,len,0);
	return[5,1]
}
function corruptSort(){
	let array=[...arr];
	const comp=(a,s,e)=>{
		if(compareIndices(a,s,e)==1)
			swap(a,s,e);
	}
	const pass=(a,s,e,l,g,t)=>{
		for(let i=s;i<e;i++)
			for(let g2=g;g2>t;g2/=2)
				if(i+g2<l)
					comp(a,i,i+g2);
	}
	const merge=(a,s,e,b)=>{
		if(e<=s)return;
		let m=(s+e)/2|0,g0=m-s,g1=g0/2|0;
		if(!b)
			for(let i=s;i<m;i++)
				if(i+g0<e)
					comp(a,i,i+g0);
		if(s==m)return;
		if(e-s>4)
			pass(a,s+g1,m,e,g1,1);
		merge(a,s,m,1);
		merge(a,m,e,1);
	}
	const sort=(a,s,e)=>{
		if(e<=s)return;
		let m=(s+e)/2|0;
		if(s==m)merge(a,s,e,0);
		else{
			sort(a,s,m);
			sort(a,m,e);
			merge(a,s,e,0);
		}
	}
	let n=1;
	while(n*2<=len)n*=2;
	sort(array,0,len);
	pass(array,0,len,len,n-1,0);
	return[5,1]
}
function circleHalverSort(){
	let array=[...arr];
	let end;
	const cs=(a,b,c)=>{
		let m=b<c&&c<len&&compareIndices(a,b,c)>0
		m&&swap(a,b,c);
		return m;
	}
	const bc=(a,b,c)=>{
		let d=0
		for(let i=b,j=c-1;i<j;i++,j--)
			d=cs(a,i,j);
		return d;
	}
	const halver=(a,b,c)=>{
		let n=c-b,e=-1;
		while(1){
			for(let j=1;j<n/2;j*=2)
				for(let i=b;i<minVal(len,c);i+=2*j)
					for(let k=0;k<j;k++)
						cs(a,i+k,i+j+k);
			if(!bc(a,b,c))break;
			e++;
		}
	}
	let l=1<<(log(len-1)/log(2))+1|0;
	halver(array,0,l);
	for(let j=l/2;j>4;j/=2)
		for(let i=0;i+j/2<len;i+=j)
			if(bc(array,i,i+j))
				halver(array,i,i+j);
	for(let i=2;i<len;i+=4)
		cs(array,i-1,i);
	return[5,1]
}
function iterativePairwiseSort(){
	let array=[...arr];
	const sort=(ar,l)=>{
		let a=1,b=0,c=0,d=0,e=0;
		while(a<l){
			b=a;c=0;
			while(b<l){
				if(compareIndices(ar,b-a,b)==1)
					swap(ar,b-a,b);
				c=(c+1)%a;
				b++;
				if(c==0)b+=a;
			}
			a*=2;
		}
		a/=4;e=1;
		while(a>circleDepth){
			d=++e;
			while(d>0){
				b=(d+1)*a;
				c=0;
				while(b<l){
					if(compareIndices(ar,b-d*a,b)==1)
						swap(ar,b-d*a,b);
					c=(c+1)%a;b++;
					if(c==0)b+=a;
				}
				d/=2;
			}
			a/=2;e*=2;
		}
	}
	sort(array,len);
	return[5,1]
}
function iterativeVanVoorhisSort(){
	let array=[...arr];
	const cs=(a,b,c)=>{
		if(compareIndices(array,b,c)>0)swap(a,b,c);
	}
	const cr=(a,b,c,s)=>{
		while(s-->0)cs(a,b++,c++);
	}
	for(let k=4;k/4<=len;k*=4){
		let f=k/4;
		for(let i=0;i<len;i+=k){
			cr(array,i,i+f,f);
			cr(array,i+f+f,i+f+f+f,f);
		}
		for(let i=0;i<len;i+=k){
			cr(array,i,i+f+f,f);
			cr(array,i+f,i+f+f+f,f);
		}
		for(let i=0;i<len;i+=k)cr(array,i+f,i+f+f,f);
		for(let m=16;m<=k;m*=4){
			let s=k/m;
			for(let i=0;i<len;i+=k)
				for(let j=2;j+7<m;j+=4){
					cr(array,i+j*s,i+(j+6)*s,s);
					cr(array,i+(j+1)*s,i+(j+7)*s,s);
				}
			for(let i=0;i<len;i+=k)
				for(let j=1;j+5<m;j+=4){
					cr(array,i+j*s,i+(j+3)*s,s);
					cr(array,i+(j+2)*s,i+(j+5)*s,s);
				}
			for(let i=0;i<len;i+=k)
				for(let j=2;j+3<m;j+=4){
					cr(array,i+j*s,i+(j+2)*s,s);
					cr(array,i+(j+1)*s,i+(j+3)*s,s);
				}
			for(let i=0;i<len;i+=k)
				for(let j=3;j+3<m;j+=2)
					cr(array,i+j*s,i+(j+1)*s,s);
		}
	}
	return[5,1]
}
function rotateLSDRadixSort(){
	let array=[...arr];
	const msw=(a,b,c,l)=>{
		for(let i=0;i<l;i++)swap(a,b+i,c+i);
	}
	function rotate(a,b,c,m){
		let l=m-b,r=c-m;
		while(l>0&&r>0){
			if(r<l){
				msw(a,m-r,m,r);
				c-=r;m-=r;l-=r;
			}else{
				msw(a,b,m,l);
				b+=l;m+=l;r-=l;
			}
		}
	}
	function bs(ar,a,b,d,p){
		while(a<b){
			let m=(a+b)/2|0;
			if(getDigit(ar[m],p,base)>=d)b=m;
			else a=m+1;
		}
		return a;
	}
	function merge(array,a,m,b,da,db,p){
		if(b-a<2||db-da<2)return;
		let dm=(da+db)/2|0;
		let m1=bs(array,a,m,dm,p);
		let m2=bs(array,m,b,dm,p);
		rotate(array,m1,m2,m);
		m=m1+(m2-m);
		merge(array,m,m2,b,dm,db,p);
		merge(array,a,m1,m,da,dm,p);
	}

	function ms(ar,a,b,p){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		ms(ar,a,m,p);
		ms(ar,m,b,p);
		merge(ar,a,m,b,0,base,p);
	}
	let base=10,max=maxLog(array,len,base);
	for(let i=0;i<=max;i++)
		ms(array,0,len,i);
	return[5,1]
}
function digSort(){
	let array=[...arr];
	function par(ar,a,b){
		let mx=new Array(b-a),max=ar[a];
		for(let i=1;i<b-a;i++)
			if(ar[a+i]>max){
				max=ar[a+i];
				mx[i]=1;
			}
		let p=1;
		for(let i=b-a-1,j=b-a-1;j>=0&&i>=p;j--){
			while(!mx[j]&&j>0)j--;
			max=array[a+j];
			while(max<=ar[a+i]&&i>=p)i--;
			if(compareIndices(ar,a+j,a+i)==1&&p<i-j)p=i-j;
		}
		return p;
	}
	let ls=0,le=0,ms=len-2,sw=1;
	for(let i=0;i<len&&sw;i=ls){
		le=par(array,0,len);
		sw=0;
		let msed=0;
		for(let j=ms;j>=i;j--){
			if(compareIndices(array,j,j+1)>0){
				swap(array,ls=j,j+1);
				sw=1
				if(msed){
					msed=1;
					ms=j+1<len-1?j+1:len-2;
				}
			}
		}
		for(let l=ls+1;l<=ms&&sw;l++){
			if(compareIndices(array,l,l+1)>0){
				let bl=l+le<len-1?l+le:len-2;
				for(let r=l+1;r<=bl;r++){
					if(compareIndices(array,l,r)>0){
						swap(array,l++,r);
						if(r>ms)ms=r;
					}
				}
			}
		}
	}
	return[5,1]
}
function cityscapeSort(){
	let array=[...arr];
	function csdep(a,i,j){
		if(i==j)return;
		let b=minVal(i,j),c=maxVal(i,j);
		if(compareIndices(a,b,c)>0)swap(a,b,c);
	}
	function sp(a,s,e,g){
		for(let h=g,i=h+s;i<e;i++){
			let v=a[i],j=i,w=0;
			for(;j>=h&&j-h>=s&&compareValues(a[j-h],v)==1;j-=h)write(a,j,a[j-h],0,w=1);
			if(w)write(a,j,v);
		}
	}
	function sh(a,s,e){
		for(let g=((e-s)/2.25)|0;g>=2;g/=2.25)sp(a,s,e,g|0);
		sp(a,s,e,1);
	}
	function mxs(ar,st,e){
		let a=e-1,b=e-1,sg=1;
		while(sg){
			if(b-1<st)return st;
			if(compareIndices(ar,b-1,b)>0)sg=0;
			else b--;
		}
		let sel=b-1;
		for(let s=b-2;s>=st;s--)
			if(compareIndices(ar,sel,s)<0)sel=s;
		while(compareIndices(ar,sel,a)<1)
			if(--a<st)break;
		return a+1;
	}
	function shuffle(a,s,e){
		for(let i=s;i<e;i++){
			let r=random()*(e-i)+i|0;
			if(r!=i)swap(array,i,r);
		}
	}
	let i=len;
	while(i>0){
		let h=i,j=0;
		for(;j<i;j++){
			csdep(array,j,j+1);
			for(h=i-1;h>i-j-2;h--){
				csdep(array,j,h);
				if(h<=j)break;
			}
			if(h<=j)break;
		}
		sh(array,j,i);
		i=mxs(array,0,i);
		shuffle(array,0,i);
	}
	return[5,1]
}
function iterativeClericSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(iclsr(array,n,len));
	return[5,1]
}
function recursiveClericSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rclsr(array,0,n-1,0));
	return[5,1]
}
function debrisSort(){
	let array=[...arr];
	let i=0,f=1,l=len-1,nl=len-1,ar=true;
	while(ar){
		ar=false;
		let ff=false;
		if(f>0)i=f-1;
		else i=0;
		for(;i<l;i++){
			let s=i;
			for(;compareIndices(array,i,i+1)>0&&i<l;i++){
				if(!ff){
					f=i;ff=true;
				}
				nl=i+1;
			}
			let e=i;
			if(s!=e){
				if(e-s<3)swap(array,s,e,0,ar=true);
				else reversal(array,s,e,0,ar=true);
			}
		}
		if(nl+1<len)l=nl+1;
		else l=len-1;
	}
	return[5,1]
}
function evubSort(){
	let array=[...arr];
	function cs(a,b){
		if(compareIndices(a,b,b+1)>0)swap(a,b,b+1);
	}
	function sort(a,b,bs){
		if(bs==1)for(let c=0;c<=b;c++)cs(a,c);
		else for(let c=0;c<=b;c++)sort(a,c,bs-1);
	}
	let base=3;
	for(let a=len-1;a>0;a--)
		for(let b=0;b+1<=a;b++)
			if(base==2)cs(array,b);
			else sort(array,b,base-2);
	return[5,0]
}
function iterativeFiringSquadSort(){
	let array=[...arr];
	function fs(array,start,end,dir){
		if(dir){
			let left=start,right=start+1,lcycle=1,rcycle=true;
			while(left<right){
				if(compareIndices(array,left,right)>0)swap(array,left,right,0,swaps=1);
				if(++lcycle>2){
					left++;lcycle=0;
				}
				if(rcycle){
					if(++right>end-1){
						right--;rcycle=0;
					}
				}else right--;
			}
		}else{
			let right=end-1,left=end-2,rcycle=1,lcycle=true;
			while(left<right){
				if(compareIndices(array,left,right)>0)swap(array,left,right,0,swaps=1);
				if(++rcycle>2){
					right--;rcycle=0;
				}
				if(lcycle){
					if(--left<start){
						left++;lcycle=false;
					}
				}else left++;
			}
		}
	}
	function init(array,start,end,firstdir){
		fs(array,start,end,firstdir);
		let dir=true;
		for(let l=(end-start)/2;l>1;l/=2)
			for(let i=start;i+l<=end;i+=l)
				fs(array,i,i+l,dir=!dir);
	}
	let swaps=1;
	let l=2;
	for(;l*2<=len;l*=2);
	let cdir=0;
	while(swaps){
		swaps=false;
		if(l==len)init(array,0,len,cdir=!cdir);
		else{
			init(array,0,l,true);
			if(len-l>=l/2)init(array,(len-l)/2|0,(len+l)/2|0,true);
			init(array,len-l,len,false);
		}
	}
	return[5,1]
}
function recursiveFiringSquadSort(){
	let array=[...arr];
	function fs(array,start,end,dir){
		if (dir){
			let left=start,right=start+1,lcycle=1,rcycle=true;
			while(left<right){
				if(compareIndices(array,left,right)>0)swap(array,left,right,0,swaps=1);
				if(++lcycle>2){
					left++;lcycle=0;
				}
				if(rcycle){
					if(++right>end-1){
						right--;rcycle=0;
					}
				}else right--;
			}
		}else{
			let right=end-1,left=end-2,rcycle=1,lcycle=1;
			while(left<right){
				if(compareIndices(array,left,right)>0)swap(array,left,right,0,swaps=1);
				if(++rcycle>2){
					right--;rcycle=0;
				}
				if(lcycle){
					if(--left<start){
						left++;lcycle=0;
					}
				}else left++;
			}
		}
		if(end-start>2){
			fs(array,start,end-(end-start)/2|0,false);
			fs(array,end-(end-start)/2|0,end,true);
		}
	}
	let swaps=1,l=2;
	for(;l*2<=len;l*=2);
	let cdir=0;
	while(swaps){
		swaps=false;
		if(l==len)fs(array,0,len,cdir=!cdir);
		else{
			fs(array,0,l,true);
			if(len-l>=l/2)init(array,(len-l)/2|0,(len+l)/2|0,true);
			fs(array,len-l,len,false);
		}
	}
	return[5,1]
}
function fordSort(){
	let array=[...arr];
	let q=0;
	while(!rangeSorted(array,len)){
		for(let k=len/2;k>0;k--){
			for(let i=q;i<len;i+=2*k){
				let l=i,change=0;
				while(l>0&&compareIndices(array,l,l-1)==-1){
					swap(array,l,l-1);
					l-=2;
					if(i>0)i--;
					change=1;
				}
				if(change)i++;
				else i--;
			}
		}
		q=(q+1)&1;
	}
	return[5,1]
}
function futureSort(){
	let array=[...arr];
	let as=1,tl=2;
	for(;tl*2<=len;tl*=2);
	let l=len;
	while(as){
		as=0;
		let ls=0;
		for(let o=0,m=1;o!=l-1;o++){
			if(tl>1){
				while(o+m*2<l)m*=2;
				while(m>=tl)m/=2;
			}
			for(;m>=1;m/=2)
				if(compareIndices(array,o,o+m)>0)
					swap(array,ls=o,o+m,0,as=1);
		}
		l=ls+2<l?ls+1:l-1;
		if(tl>1)tl/=2;
	}
	return[5,1]
}
function iterativePopSort(){
	let array=[...arr];
	function cf(a,d,s,j,b,f,c){
		for(let i=s;i<j;i++){
			if(compareIndices(a,i,i+1)==d){
				swap(a,i,i+1,1);
				if(!b)f=i;
				b=1;
				c=1;
			}else c++;
		}
		return[f,b,c]
	}
	const bubble=(a,st,e,d)=>{
		let s,c=1,f=1;
		for(let j=e-1;j>0;j-=c){
			if(f-1<st)s=st;
			else s=f-1;
			let b=0;
			c=1;
			let f1=1,b1=b,c1=c;
			[f,b,c]=cf(a,d,s,j,b1,f1,c1)
			if(b)customFunc(cf,[d,s,j,b1,f1,c1]);
		}
	}
	for(let l=2;l<len;l*=2){
		let i=0,d=-1;
		for(;i+l<=len;i+=l,d*=-1)bubble(array,i,i+l,d);
		if(i!=len)bubble(array,i,len,d);
	}
	bubble(array,0,len,1);
	return[5,1]
}
function jumpDownSort(){
	let array=[...arr];
	for(let i=len-1;i>0;i--)
		for(let j=0;j<i;j++)
			if(compareIndices(array,i,j)<0)
				swap(array,i,j);
	return[5,1]
}
function monolithicClurgeSort(){
	let array=[...arr];
	const mc=(a,s,m,e,b)=>{
		if(m<=s||e<=m)return;
		if(b==0){
			mc(a,s,s+(m-s)/2|0,m,0);
			mc(a,m,m+(e-m)/2|0,e,0);
			mc(a,s,m,e,1);
		}else{
			let c=0;
			if((c=compareIndices(a,s,m))==1)
				swap(a,s,m);
			mc(a,s+1,m,e,2);
			if(b!=2)
				mc(a,s+(c==-1?2:1),m+1,e,1);
		}
	}
	mc(array,0,len/2|0,len,0);
	return[5,1]
}
function pairwiseCombSort(){
	let array=[...arr];
	const i3s=n=>{
		while((n&1)==0)n>>=1;
		return(n&++n)==0;
	}
	for(let g=len/2;g>0;g--)
		if(i3s(g))
			for(let i=g;i<len;i++)
				if(compareIndices(array,i-g,i)==1)
					swap(array,i-g,i);
	return[5,1]
}
function pancakeQuickSort(){
	let array=[...arr];
	const flip=(a,i)=>{
		reversal(a,0,i,0);
	}
	const rot=(a,c1,c2)=>{
		flip(a,c1-1);
		flip(a,c2-1);
		flip(a,c2-c1-1);
	}
	const medOf3=(a,p1,p2,p3)=>{
		if(p1==p2)return p1;
		if(p2==p3)return p2;
		if(compareIndices(a,p1,p2)<1){
			if(compareIndices(a,p2,p3)<1)return p2;
			if(compareIndices(a,p1,p3)<1)return p3;
			return p1;
		}
		if(compareIndices(a,p2,p3)<1)return p2;
		if(compareIndices(a,p1,p3)<1)return p1;
		return p3;
	}
	function pancakeLLQS(a,l){
		if(l==2){
			if(compareIndices(a,0,l-1)>0)flip(a,l-1);
			return;
		}else if(l<2)return;
		let j=0,m=(l-1)/2|0,piv=a[medOf3(a,0,m,l-1)];
		for(let i=0;i<l;i++){
			let k=i;
			while(k<l&&compareValues(piv,a[k])>=0){
				k++;j++;
			}
			if(k>i){
				flip(a,i-1);
				flip(a,k-1);
				i=k-1;
			}
		}
		pancakeLLQS(a,j);
		rot(a,j,l);
		pancakeLLQS(a,l-j);
		rot(a,l-j,l);
	}
	pancakeLLQS(array,len);
	return[5,1]
}
function popPopSort(){
	let array=[...arr];
	function cf(a,s,e,d){
		j=s
		for(let i=s;i<=e-1;i++)
			if(compareIndices(a,i-1,i)==d)
				swap(a,i-1,j=i,1);
		return j
	}
	const bb=(a,s,e,d)=>{
		while(1){
			customFunc(cf,[s,e,d]);
			if(cf(a,s,e,d)<s+1)break;
		}
	}
	const p=(a,s,e,d)=>{
		bb(a,s,s+(e-s)/4|0,0-d);
		bb(a,s+(e-s)/4+1|0,(s+e)/2|0,d);
		bb(a,(s+e)/2+1|0,s+(e-s)*3/4|0,0-s);
		bb(a,s+(e-s)*3/4+1|0,e,d);
		bb(a,s,(s+e)/2|0,0-d);
		bb(a,(s+e)/2+1|0,e,d);
		bb(a,s,e,d);
	}
	p(array,1,(len+1)/4|0,-1);
	p(array,(len+1)/4+1|0,(len+1)/2|0,1);
	p(array,(len+1)/2+1|0,(len+1)*3/4|0,-1);
	p(array,(len+1)*3/4+1|0,len,1);
	p(array,1,len,1);
	return[5,0]
}
function inPlaceLSDRadixSort(){
	let array=[...arr];
	let pos=0;
	let base=10;
	let vregs=new Array(base-1);
	let maxpower=maxLog(array,len,base);
	for(let p=0;p<=maxpower;p++){
		for(let i=0;i<vregs.length;i++)
			write(vregs,i,len-1,true);
		pos=0;
		for(let i=0;i<len;i++){
			let digit=getDigit(array[pos],p,base);
			if(digit==0)
				pos++;
			else{
				for(let j=0;j<vregs.length;j++)
					swap(array,vregs[j],vregs[j]);
				multiSwap(array,pos,vregs[digit-1]);
				for(let j=digit-1;j>0;j--)
					write(vregs,j-1,vregs[j-1]-1,true);
			}
		}
	}
	return[5,1]
}
function swaplessPushSort(){
	let array=[...arr];
	let as=1,i,f=1;
	while(as){
		as=0;
		if(f>1)i=f-1;
		else i=1;
		let g=1;
		while(i+g<=len){
			if(compareIndices(array,i-1,i-1+g)>0){
				if(!as)f=i;
				insertTo(array,i-1+g,i-1);
				g++;as=1
			}else i++;
		}
	}
	return[5,1]
}
function reboundSort(){
	let array=[...arr];
	let st=0,s=0;
	for(let d=1;!s;d*=-1){
		let i=d==1||!st?0:len-2;
		st=1;s=1;
		for(;i>=0&&i<len-1;i+=d)
			if(compareIndices(array,i,i+1)>0){
				swap(array,i,i+1,0,s=0);
				d=-d;
			}
	}
	return[5,1]
}
function rubbleSort(){
	let array=[...arr];
	const sig=(a,b,d)=>((a+d)+d*abs(a-b))/2|0;
	function run(a,s,e){
		if(s>=e-1)return s+1;
		let c=-compareIndices(a,s++,s)|1,k=s-1,d;
		do d=compareIndices(a,s++,s);while(s<e&&d!=c);
		let m=(s-k)/2|0,q=sig(k,s-1,-c);
		for(let i=0;i<m;i++)swap(a,k+i,q+c*i);
		return s;
	}
	let runs=new Array(len/2|0+1);
	let rf=0,r=0;
	while(r<len)write(runs,rf++,(r=run(array,r,len))-1,true);
	function cf(ar,rs,rf){
		for(let i=2;i<rf;i++){
			if(compareIndices(ar,rs[i-1],rs[i])>0){
				let t=ar[rs[i-1]],temp=rs[i-1]-1;
				while(temp>=(i-2<0?0:rs[i-2]+1)){
					if(compareIndices(ar,temp,rs[i])<1)break;
					write(ar,temp+1,ar[temp--],true);
				}
				write(ar,temp+1,ar[rs[i]],true);
				write(ar,rs[i],t,true);
			}
		}
	}
	while(rf>1){
		customFunc(cf,[[...runs],rf])
		cf(array,[...runs],rf)
		if(runs[rf-1]==runs[rf-2])write(runs,--rf,0,true);
		else write(runs,rf-1,runs[rf-1]-1,true);
	}
	binDoubleInsert(array,0,len)
	arraycopy([...arr].sort((a,b)=>a-b),0,array,0,len)
	return[5,1]
}
function searchSort(){
	let array=[...arr];
	const bs=(a,b,c,v)=>{
		while(b<c){
			let m=b+((c-b)/2)|0;
			if(compareValues(v,a[m])<0)c=m;
			else b=m+1;
		}
		return b;
	}
	let i=0;
	while(i+1<len){
		let ver=1;
		while(i+1<len&&ver){
			if(compareIndices(array,i,i+1)<1)i++;
			else ver=0;
		}
		if(i+1<len)swap(array,i+1,bs(array,0,i,array[i+1]));
	}
	return[5,1]
}
function selectionSort(){
	let array=[...arr];
	for(let i=0;i<len-1;i++){
		let l=i;
		for(let j=i+1;j<len;j++)
			if(compareIndices(array,j,l)==-1)
				l=j;
		swap(array,i,l);
	}
	return[5,1]
}
function iterativeShircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(ishsr(array,n));
	return[5,1]
}
function recursiveShircleSort(){
	let array=[...arr];
	let n=1;
	for(;n<len;n*=2);
	while(rshsr(array,0,n-1,0));
	return[5,1]
}
function XSort(){
	let array=[...arr];
	let gap=len;
	function cf(ar,g,l){
		let as=0
		for(let i=1;i-1+g<l;i++){
			if(compareIndices(ar,i-1,i-1+g)>0){
				swap(ar,i-1,i-1+g,true);
				as=true;
				let xleft=i+1;
				let xright=i+g-1;
				if(g!=1){
					for(let r=0;r<g-1;r++){
						if(compareIndices(ar,xleft-1,xright-1)>0)
							swap(ar,xleft-1,xright-1,1);
						xleft++;xright--;
					}
				}
			}
		}
		return[g,as]
	}
	let as=0;
	while(1){
		[gap,as]=cf(array,gap,len)
		customFunc(cf,[gap,len])
		if(!as){
			if(gap==1)break;
			else gap--;
		}
	}
	return[5,1]
}
function blockShellSort(){
	let array=[...arr];
	function gappedBinary(A,P,l,K,G,i){
		let L=-1,R=l,C,M;
		while(L<R-1){
			M=L+((R-L)>>1);
			C=compareIndices(A,P+M*G,K);
			if(C==1||(i&&C==0))R=M;
			else L=M;
		}
		return R;
	}
	function GSFW(A,P,L,G){
		let t=A[P];
		for(let i=0;i<L;i++)write(A,P+i*G,A[P+(i+1)*G]);
		write(A,P+L*G,t);
	}
	function GSBW(A,P,L,G){
		let t=A[P+L*G];
		for(let i=L;i>0;i--)write(A,P+i*G,A[P+(i-1)*G]);
		write(A,P,t);
	}
	function GMSFW(A,lA,lB,L,G){
		for(let i=0;i<L;i++)swap(A,lA+i*G,lB+i*G);
	}
	function GMSBW(A,lA,lB,L,G){
		for(let i=0;i<L;i++)swap(A,lA+i*G,lB+i*G);
	}
	function rotate(A,P,L,R,G){
		while(L>1&&R>1){
			if(L<=R){
				GMSFW(A,P,P+L*G,L,G);
				P+=L*G;
				R-=L;
			}else{
				GMSBW(A,P+(L-R)*G,P+L*G,R,G);
				L-=R;
			}
		}
		if(L>0&&R>0){
			if(L==1)GSFW(A,P,R,G);
			else if(R==1)GSBW(A,P,L,G);
		}
	}
	function merge(array,P,L0,L1,G){
		let S;
		if(L0<L1){
			while(L0!=0){
				S=gappedBinary(array,P+L0*G,L1,P,G,true);
				if(S!=0){
					rotate(array,P,L0,S,G);
					P+=S*G;
					L1-=S;
				}
				if(L1==0)break;
				do{P+=G;L0--;}while(L0!=0&&compareIndices(array,P,P+L0*G)<1);
			}
		}else{
			while(L1!=0){
				S=gappedBinary(array,P,L0,P+(L0+L1-1)*G,G,false);
				if(S!=L0){
					rotate(array,P+S*G,L0-S,L1,G);
					L0=S;
				}
				if(L0==0)break;
				do L1--;while(L1!=0&&compareIndices(array,P+(L0-1)*G,P+(L0+L1-1)*G)<1);
			}
		}
	}
	function gappedReverse(a,s,e,g){
		for(;s<=e-g;s+=g,e-=g)swap(a,s,e);
	}
	function getRun(array,start,end,gap){
		let t=start,iD=-compareIndices(array,start,start+gap),len=1;
		if(end-start<gap)return 1;
		if(iD==0)iD=1;
		do{len++;start+=gap;}while(start<=end-gap&&compareIndices(array,start,start+gap)!=iD);
		if(iD==-1)gappedReverse(array,t,start,gap);
		return len;
	}
	let gaps=[1,4,10,23,57,132,301,701];
	function ciura(n){
		if(n<=gaps.length)return gaps[n-1];
		return pow(2.25,n)|0;
	}
	function shellPass(array,start,end,gap){
		if(end-start<gap)return;
		let done,starts=new Array(gap),lens=new Array(gap),ends=new Array(gap);
		for(let i=0;i<gap;i++){
			starts[i]=start+i;
			lens[i]=0;
			ends[i]=(end-(end%gap))+i;
			if(ends[i]>=end)
				ends[i]-=gap;
		}
		do{
			done=true;
			for(let i=0;i<gap;i++){
				let v=starts[i]+lens[i]*gap;
				if(v>ends[i]||ends[i]==-1)continue;
				done=false;
				let r=getRun(array,v,ends[i],gap);
				merge(array,starts[i],lens[i],r,gap);
				write(lens,i,lens[i]+r,true);
			}
		}while(!done);
	}
	let k=1;
	while(ciura(k++)<len);
	while(--k>1)shellPass(array,0,len,ciura(k-1));
	return[5,1]
}
function rotateMSDRadixSort(){
	let array=[...arr];
	function shift(n,q){
		while(q>0){
			n/=base;q--;
		}
		return n|0;
	}
	function ms(ar,a,b,l){
		for(let i=0;i<l;i++)
			swap(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				ms(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				ms(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function bs(ar,a,b,d,p){
		while(a<b){
			let m=(a+b)/2|0;
			if(getDigit(ar[m],p,base)>=d)b=m;
			else a=m+1;
		}
		return a;
	}
	function merge(ar,a,m,b,da,db,p){
		if(b-a<2||db-da<2)return;
		let dm=(da+db)/2|0;
		let m1=bs(ar,a,m,dm,p);
		let m2=bs(ar,m,b,dm,p);
		rot(ar,m1,m,m2);
		m=m1+(m2-m);
		merge(ar,m,m2,b,dm,db,p);
		merge(ar,a,m1,m,da,dm,p);
	}
	function mrs(ar,a,b,p){
		if(b-a<2)return;
		let m=(a+b)/2|0;
		mrs(ar,a,m,p);
		mrs(ar,m,b,p);
		merge(ar,a,m,b,0,base,p);
	}
	function dist(ar,a,b,p){
		mrs(ar,a,b,p);
		return bs(ar,a,b,1,p);
	}
	let base=4;
	let q=maxLog(array,len,base);
	let m=0,i=0,b=len;
	while(i<len){
		let p=b-i<1?i:dist(array,i,b,q);
		if(q==0){
			m+=base;
			let t=m/base;
			while(t%base==0){
				t/=base;
				q++;
			}
			i=b;
			while(b<len&&shift(array[b],q+1)==shift(m,q+1))b++;
		}else{
			b=p;q--;
		}
	}
	return[5,1]
}
function recursivePairwiseSort(){
	let array=[...arr];
	function psr(ar,s,e,g){
		if(s==e-g)return;
		let a=1,b=s+g;
		while(b<e){
			if(compareIndices(ar,b-g,b)>0)
				swap(ar,b-g,b);
			b+=2*g;
		}
		if(((e-s)/g)%2==0){
			psr(ar,s,e,g*2);
			psr(ar,s+g,e+g,g*2);
		}else{
			psr(ar,s,e+g,g*2);
			psr(ar,s+g,e,g*2);
		}
		while(a<((e-s)/g))a=a*2+1;
		b=s+g;
		while(b+g<e){
			let c=a;
			while(c>1){
				c/=2;c|=0;
				if(b+c*g<e)
					if(compareIndices(ar,b,b+c*g)>0)
						swap(ar,b,b+c*g);
			}
			b+=2*g;
		}
	}
	psr(array,0,len,1);
	return[5,1]
}
function flashSort(){
	let array=[...arr];
	function sort(array,len){
		let m=(.2*len)+2|0,min,max,mi;
		min=max=array[0];
		mi=0;
		for(let i=1;i<len-1;i+=2){
			let small,big,bi;
			if(compareIndices(array,i,i+1)<0){
				small=array[i];
				big=array[i+1];
				bi=i+1;
			}else{
				big=array[i];
				bi=i;
				small=array[i+1];
			}
			if(big>max){
				max=big;
				mi=bi;
			}
			if(small<min)min=small;
		}
		if(compareValues(array[len-1],min)<0)min=array[len-1];
		else if(compareValues(array[len-1],max)>0){
			max=array[len-1];
			mi=len-1;
		}
		if(max==min)return;
		let L=new Array(m+1);
		for(let t=1;t<=m;t++)write(L,t,0,true)
		let c=(m-1)/(max-min);
		let K;
		for(let h=0;h<len;h++){
			K=((array[h]-min)*c)+1|0;
			write(L,K,L[K]+1,true);
		}
		for(K=2;K<=m;K++)write(L,K,L[K]+L[K-1],true);
		swap(array,mi,0);
		let j=0;
		K=m;
		let moves=0;
		while(moves<len){
			while(j>=L[K]){
				j++;
				K=((array[j]-min)*c)+1|0;
			}
			let evicted=array[j];
			while(j<L[K]){
				K=((evicted-min)*c)+1|0;
				let loc=L[K]-1;
				let temp=array[loc];
				write(array,loc,evicted);
				evicted=temp;
				write(L,K,L[K]-1,true);
				moves++;
			}
		}
		insertSort(array,0,len);
	}
	sort(array,len)
	return[5,1]
}
function americanFlagSort(){
	let array=[...arr];
	let base=(len/4|0)+1;
	function gmnod(a,l){
		let m=-1/0,t=0;
		for(let i=0;i<l;i++){
			t=log(a[i])/log(base)+1;
			if(t>m)m=t;
		}
		return m|0;
	}
	const getd=(i,d)=>(i/d|0)%base;
	function sort(a,s,e,dv){
		let cnt=new Array(base),offset=new Array(base),digit=0;
		for(let i=s;i<e;i++){
			let d=a[i];
			digit=getd(d,dv);
			write(cnt,digit,cnt[digit]+1,true);
		}
		write(offset,0,s,true);
		for(let i=1;i<base;i++)write(offset,i,cnt[i-1]+offset[i-1],true);
		for(let b=0;b<base;b++){
			while(cnt[b]>0){
				let origin=offset[b],fr=origin,num=a[fr];
				a[fr]=-1
				do{
					digit=getd(num,dv);
					let to=offset[digit];
					write(offset,digit,offset[digit]+1,true);
					write(cnt,digit,cnt[digit]-1,true);
					let temp=a[to];
					write(a,to,num);
					num=temp;fr=to;
				}while(fr!=origin);
			}
		}
		if(dv>1){
			for(let i=0;i<base;i++){
				let begin=(i>0)?offset[i-1]:s;
				let end=offset[i];
				if(end-begin>1)sort(a,begin,end,dv/base|0);
			}
		}
	}
	let nod=gmnod(array,len);
	let max=1;
	for(let i=0;i<nod-1;i++)max*=base;
	sort(array,0,len,max);
	insertSort(array,0,len)
	return[5,1]
}
function classic3SmoothCombSort(){
	let array=[...arr];
	const i3s=n=>{
		while(n%6==0)n/=6;
		while(n%3==0)n/=3;
		while(n%2==0)n/=2;
		return n==1;
	}
	for(let g=len-1;g>0;g--)
		if(i3s(g))
			for(let i=g;i<len;i++)
				if(compareIndices(array,i-g,i)>0)
					swap(array,i-g,i);
	return[5,1];
}
function iterative3SmoothCombSort(){
	let array=[...arr];
	let pow2=log(len-1)/log(2)|0;
	for(let k=pow2;k>=0;k--){
		let pow3=(log(len)-k*log(2))/log(3)|0;
		for(let j=pow3;j>=0;j--){
			let gap=pow(2,k)*pow(3,j)|0;
			for(let i=0;i+gap<len;i++)
				if(compareIndices(array,i,i+gap)>0)
					swap(array,i,i+gap)
		}
	}
	return[5,1]
}
function recursive3SmoothCombSort(){
	let array=[...arr];
	function rc(a,p,g,e){
		if(p+g>e)return;
		rc(a,p,g*2,e);
		rc(a,p+g,g*2,e);
		pot(a,p,g,e);
	}
	function pot(a,p,g,e){
		if(p+g>e)return;
		pot(a,p,g*3,e);
		pot(a,p+g,g*3,e);
		pot(a,p+2*g,g*3,e);
		for(let i=p;i+g<e;i+=g)
			if(compareIndices(a,i,i+g)>0)
				swap(array,i,i+g);
	}
	rc(array,0,1,len);
	return[5,1]
}
function binaryDoubleInsertionSort(){
	let array=[...arr];
	binDoubleInsert(array,0,len)
	return[5,1]
}
function ectaSort(){
	let array=[...arr];
	const gmr=(n)=>{
		let mr=n;
		for(;mr>=32;mr=(mr+1)/2);
		return mr|0;
	}
	function shift(ar,a,m,b){
		while(m<b)write(ar,a++,ar[m++]);
	}
	function shiftBW(ar,a,m,b){
		while(m>a)write(ar,--b,ar[--m]);
	}
	function mergeTo(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<1)write(ar,p++,ar[i++]);
			else write(ar,p++,ar[j++]);
		}
		while(i<m)write(ar,p++,ar[i++]);
		while(j<b)write(ar,p++,ar[j++]);
	}
	function ppm(ar,a,m1,m2,m3,b,p){
		let p1=p+m2-a,pE=p+b-a;
		mergeTo(ar,a,m1,m2,p);
		mergeTo(ar,m2,m3,b,p1);
		mergeTo(ar,p,p1,pE,a);
	}
	function merge(ar,a,m,b,p){
		let l=b-m,pE=p+l-1;
		arraycopy(ar,m--,ar,p,l);
		while(m>=a&&pE>=p){
			if(compareIndices(ar,m,pE)>0)write(ar,--b,ar[m--]);
			else write(ar,--b,ar[pE--]);
		}
		while(pE>=p)write(ar,--b,ar[pE--]);
	}
	function mergeFromBuf(ar,buf,a,m,b,bufLen){
		let i=0;
		while(i<bufLen&&m<b){
			if(compareValues(buf[i],ar[m])<1)write(ar,a++,buf[i++]);
			else write(ar,a++,ar[m++]);
		}
		while(i<bufLen)write(ar,a++,buf[i++]);
	}
	function dualMergeFromBufBW(ar,buf,a,a1,m,b,bufLen){
		let i=bufLen-1;
		bufLen-=b-(m--);
		while(i>=bufLen&&m>=a1){
			if(compareValues(buf[i],ar[m])>0)write(ar,--b,buf[i--]);
			else write(ar,--b,ar[m--]);
		}
		if(m<a1)while(i>=0)write(ar,--b,buf[i--]);
		else mergeFromBuf(ar,buf,a,a1,b,bufLen);
	}
	function mrs(ar,a,b,p,mRun,bufLen){
		let i=a,j=mRun;
		for(;i+j<=b;i+=j)binDoubleInsert(ar,i,i+j);
		binDoubleInsert(ar,i,b);
		while(4*j<=bufLen){
			for(i=a;i+4*j<=b;i+=4*j)ppm(ar,i,i+j,i+2*j,i+3*j,i+4*j,p);
			if(i+3*j<b)ppm(ar,i,i+j,i+2*j,i+3*j,b,p);
			else if(i+2*j<b)ppm(ar,i,i+j,i+2*j,b,b,p);
			else if(i+j<b)merge(ar,i,i+j,b,p);
			j*=4;
		}
		while(j<=bufLen){
			for(i=a;i+2*j<=b;i+=2*j)merge(ar,i,i+j,i+2*j,p);
			if(i+j<b)merge(ar,i,i+j,b,p);
			j*=2;
		}
		return j;
	}
	function blockCycle(ar,keys,a,bL,t,p,excl,fw){
		let s=fw?bL:-bL;
		for(let i=0;i<t;i++){
			if(compareValues(i,keys[i])!=0){
				arraycopy(ar,a+i*s,ar,p,bL);
				let j=i,next=keys[i];
				do{
					if(!(excl&&j==t-1))arraycopy(ar,a+next*s,ar,a+j*s,bL);
					write(keys,j,j,true);
					j=next;
					next=keys[next];
				}while(compareValues(next,i)!=0);
				arraycopy(ar,p,ar,a+j*s,bL);
				write(keys,j,j,true);
			}
		}
	}
	function ectaMergeFW(ar,tags,a,m,b,bL){
		let i=a,j=m,t=0,tc=0,s=[2*bL,0],p=[a-2*bL,m];
		do{
			let c=s[0]<bL?1:0;
			for(let k=0;k<bL;k++){
				if(i<m&&j<b){
					if(compareIndices(ar,i,j)<1){
						write(ar,p[c]+k,ar[i++]);
						s[0]++;
					}else{
						write(ar,p[c]+k,ar[j++]);
						s[1]++;
					}
				}else if(i<m){
					write(ar,p[c]+k,ar[i++]);
					s[0]++;
				}else{
					write(ar,p[c]+k,ar[j++]);
					s[1]++;
				}
			}
			p[c]+=bL;s[c]-=bL;
			write(tags,tc++,c==0?t++:-1,true);
		}while(i<m||j<b);
		if(s[0]>0)write(tags,tc,t++,true);
		for(let k=2;k<tc;k++)
			if(tags[k]==-1)write(tags,k,t++,true);
		blockCycle(ar,tags,a-2*bL,bL,t,b-bL,s[0]>0,true);
	}
	function ectaMergeBW(ar,tags,a,m,b,bL){
		let i=b-1,j=m-1,t=0,tc=0,s=[2*bL,0],p=[b+2*bL,m];
		do{
			let c=s[0]<bL?1:0;
			for(let k=1;k<=bL;k++){
				if(i>=m&&j>=a){
					if(compareIndices(ar,i,j)>=0){
						write(ar,p[c]-k,ar[i--]);
						s[0]++;
					}else{
						write(ar,p[c]-k,ar[j--]);
						s[1]++;
					}
				}else if(i>=m){
					write(ar,p[c]-k,ar[i--]);
					s[0]++;
				}else{
					write(ar,p[c]-k,ar[j--]);
					s[1]++;
				}
			}
			p[c]-=bL;s[c]-=bL;
			write(tags,tc++,c==0?t++:-1,true);
		}while(i>=m||j>=a);
		if(s[0]>0)write(tags,tc,t++,true);
		for(let k=2;k<tc;k++)
			if(tags[k]==-1)write(tags,k,t++,true);
		blockCycle(ar,tags,b+bL,bL,t,a,s[0]>0,false);
	}
	if(len<256){
		if(len<=32)binDoubleInsert(array,0,len);
		else{
			let mRun=gmr(len),bufLen=len/2|0;
			let buf=new Array(bufLen);
			arraycopy(array,bufLen,buf,0,bufLen,true);
			mrs(array,0,bufLen,bufLen,mRun,bufLen);
			arraycopy(buf,0,array,bufLen,bufLen);
			arraycopy(array,0,buf,0,bufLen,true);
			mrs(array,bufLen,len,0,mRun,bufLen);
			mergeFromBuf(array,buf,0,bufLen,len,bufLen);
		}
	}else{
		let mRun=gmr(len),bL=mRun;
		for(;bL*bL<len/2;bL*=2);
		let bufLen=2*bL+len%bL,a=bufLen,b=len,l=b-a,buf=new Array(bufLen),tags=new Array(l/bL+1|0);
		arraycopy(array,a,buf,0,bufLen,true);
		mrs(array,0,a,a,gmr(bufLen),bufLen);
		arraycopy(buf,0,array,a,bufLen);
		arraycopy(array,0,buf,0,bufLen,true);
		let i=a,j=mrs(array,a,b,0,mRun,bufLen),bw=false;
		while(j<l){
			for(i=a;i+2*j<=b;i+=2*j)
				ectaMergeFW(array,tags,i,i+j,i+2*j,bL);
			if(i+j<b)ectaMergeFW(array,tags,i,i+j,b,bL);
			else shift(array,i-2*bL,i,b);
			j*=2;
			a-=2*bL;
			b-=2*bL;
			if(j>=l){
				bw=true;
				break;
			}
			for(i=a;i+2*j<=b;i+=2*j);
			if(i+j<b)ectaMergeBW(array,tags,i,i+j,b,bL);
			else shiftBW(array,i,b,b+2*bL);
			for(i-=2*j;i>=a;i-=2*j)
				ectaMergeBW(array,tags,i,i+j,i+2*j,bL);
			j*=2;
			a+=2*bL;
			b+=2*bL;
		}
		if(bw)dualMergeFromBufBW(array,buf,0,a,b,len,bufLen);
		else mergeFromBuf(array,buf,0,a,b,bufLen);
	}
	return[15,1];
}
function flanSort(){
	let array=[...arr];
	let G=14,R=4;
	let mwms=new MWMS();
	function mot(ar,a,m,b){
		if(compareIndices(ar,m,a)>0){
			if(compareIndices(ar,m,b)<0)return m;
			if(compareIndices(ar,a,b)>0)return a;
			else return b;
		}else{
			if(compareIndices(ar,m,b)>0)return m;
			if(compareIndices(ar,a,b)<0)return a;
			else return b;
		}
	}
	function ninther(ar,a,b){
		let s=(b-a)/9|0;
		let a1=mot(ar,a,a+s,a+2*s);
		let m1=mot(ar,a+3*s,a+4*s,a+5*s);
		let b1=mot(ar,a+6*s,a+7*s,a+8*s);
		return mot(ar,a1,m1,b1);
	}
	function motn(ar,a,b){
		let s=(b-a)/3|0;
		let a1=ninther(ar,a,a+s);
		let m1=ninther(ar,a+s,a+2*s);
		let b1=ninther(ar,a+2*s,b);
		return mot(ar,a1,m1,b1);
	}
	function shiftBW(ar,a,m,b){
		while(m>a)swap(ar,--b,--m);
	}
	function lbls(ar,a,b,v){
		let s=G+1;
		while(a<b){
			let m=a+(((b-a)/s|0)/2|0)*s;
			if(compareValues(v,ar[m])<1)b=m;
			else a=m+s;
		}
		return a;
	}
	function rbls(ar,a,b,v){
		let s=G+1;
		while(a<b){
			let m=a+(((b-a)/s|0)/2|0)*s;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+s;
		}
		return a;
	}
	function rbs(ar,a,b,v,bw){
		let cmp=bw?1:-1;
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])==cmp)b=m;
			else a=m+1;
		}
		return a;
	}
	function insto(ar,t,a,b){
		while(a>b)write(ar,a,ar[--a]);
		write(ar,b,t);
	}
	function bininsert(ar,a,b){
		for(let i=a+1;i<b;i++)
			insto(ar,ar[i],i,rbs(ar,a,i,ar[i]));
	}
	function kWayMerge(ar,heap,pa,s,b,p,sz){
		if(sz<2){
			if(sz==1)while(pa[0]<b)swap(ar,p++,pa[0]++);
			return;
		}
		let a=pa[0];
		for(let i=0;i<sz;i++)write(heap,i,i,true);
		for(let i=(sz-1)/2|0;i>=0;i--)mwms.siftDown(ar,heap,pa,heap[i],i,sz);
		while(sz>0){
			let min=heap[0];
			swap(ar,p++,pa[min]);
			write(pa,min,pa[min]+1,true);
			if(pa[min]==minVal(a+(min+1)*s,b))mwms.siftDown(ar,heap,pa,heap[--sz],0,sz);
			else mwms.siftDown(ar,heap,pa,heap[0],0,sz);
		}
	}
	function retrieve(ar,i,p,pE,bsv,bw){
		let j=i-1,m;
		for(let k=pE-(G+1);k>p+G;){
			m=rbs(ar,k-G,k,bsv,bw)-1;
			k-=G+1;
			while(m>=k)swap(ar,j--,m--);
		}
		m=rbs(ar,p,p+G,bsv,bw)-1;
		while(m>=p)swap(ar,j--,m--);
	}
	function lib(ar,a,b,p,bsv,bw){
		let l=b-a;
		if(l<32){
			bininsert(ar,a,b);
			return;
		}
		let s=l;
		while(s>=32)s=(s-1)/R+1|0;
		let i=a+s,j=a+R*s,pE=p+(s+1)*(G+1)+G;
		bininsert(ar,a,i);
		for(let k=0;k<s;k++)
			swap(ar,a+k,p+k*(G+1)+G);
		while(i<b){
			if(i==j){
				retrieve(ar,i,p,pE,bsv,bw);
				s=i-a;
				pE=p+(s+1)*(G+1)+G;
				j=a+(j-a)*R;
				for(let k=0;k<s;k++)
					swap(ar,a+k,p+k*(G+1)+G);
			}
			let bLoc=lbls(ar,p+G,pE-(G+1),ar[i]);
			if(compareIndices(ar,i,bLoc)==0){
				let eqEnd=rbls(ar,bLoc+(G+1),pE-(G+1),ar[i]);
				bLoc+=(random()*((eqEnd-bLoc)/(G+1)|0)|0)*(G+1);
			}
			let loc=rbs(ar,bLoc-G,bLoc,bsv,bw);
			if(loc==bLoc){
				do bLoc+=G+1;while(bLoc<pE&&rbs(ar,bLoc-G,bLoc,bsv,bw)==bLoc);
				if(bLoc==pE){
					retrieve(ar,i,p,pE,bsv,bw);
					s=i-a;
					pE=p+(s+1)*(G+1)+G;
					j=a+(j-a)*R;
					for(let k=0;k<s;k++)swap(ar,a+k,p+k*(G+1)+G);
				}else{
					let rotP=rbs(ar,bLoc-G,bLoc,bsv,bw);
					let rotS=bLoc-maxVal(rotP,bLoc-G/2|0);
					shiftBW(ar,loc-rotS,bLoc-rotS,bLoc);
				}
			}else{
				let t=ar[i];
				write(ar,i++,ar[loc]);
				insto(ar,t,loc,rbs(ar,bLoc-G,loc,t,false));
			}
		}
		retrieve(ar,b,p,pE,bsv,bw);
	}
	let pa=new Array(G+2);
	let heap=new Array(G+2);
	let a=0,b=len;
	while(b-a>=32){
		let piv=array[motn(array,a,b)];
		let i1=a,i=a-1,j=b,j1=b;
		for(;;){
			while(++i<j){
				let cmp=compareValues(array[i],piv);
				if(cmp==0)swap(array,i1++,i);
				else if(cmp<0)break;
			}
			while(--j>i){
				let cmp=compareValues(array[j],piv);
				if(cmp==0)swap(array,--j1,j);
				else if(cmp>0)break;
			}
			if(i<j)swap(array,i,j);
			else{
				if(i1==b)return;
				else if(j<i)j++;
				while(i1>a)swap(array,--i,--i1);
				while(j1<b)swap(array,j++,j1++);
				break;
			}
		}
		let left=i-a,right=b-j,m,kCnt=0;
		if(left<=right){
			m=b-left;
			left=maxVal((right+1)/(G+1),16)|0;
			for(let k=a;k<i;k+=left){
				lib(array,k,minVal(k+left,i),j,piv,true);
				write(pa,kCnt++,k,true);
			}
			kWayMerge(array,heap,pa,left,i,m,kCnt);
			if(j-i<m-j){
				while(i<j)swap(array,i++,--m);
				b=m;
			}else{
				while(m>j)swap(array,i++,--m);
				b=i;
			}
		}else{
			m=a+right;
			right=maxVal((left+1)/(G+1),16)|0;
			for(let k=j;k<b;k+=right){
				lib(array,k,minVal(k+right,b),a,piv,false);
				write(pa,kCnt++,k,true);
			}
			kWayMerge(array,heap,pa,right,b,a,kCnt);
			if(i-m<j-i){
				while(m<i)swap(array,m++,--j);
				a=j;
			}else{
				while(j>i)swap(array,m++,--j);
				a=m;
			}
		}
	}
	bininsert(array,a,b);
	return[5,1]
}
function circularGrailSort(){
	let array=[...arr];
	const csw=(ar,a,b)=>swap(ar,a%n,b%n);
	const cci=(ar,a,b)=>compareIndices(ar,a%n,b%n);
	const sFW=(ar,a,m,b)=>{while(m<b)csw(ar,a++,m++)}
	const sBW=(ar,a,m,b)=>{while(m>a)csw(ar,--b,--m)}
	function ins(ar,a,b){
		for(let i=a+1;i<b;i++)
			while(i>a&&cci(ar,i-1,i)>0)
				csw(ar,i,--i);
	}
	function msw(ar,a,b,l){
		for(let i=0;i<l;i++)
			csw(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				msw(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function ipm(ar,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(cci(ar,i,j)>0){
				k=j;
				while(++k<b&&cci(ar,i,k)>0);
				rot(ar,i,j,k);
				i+=k-j;j=k;
			}else i++;
		}
	}
	function merge(ar,p,a,m,b,f){
		let i=a,j=m;
		while(i<m&&j<b){
			if(cci(ar,i,j)<=0)csw(ar,p++,i++);
			else csw(ar,p++,j++);
		}
		if(i<m){
			if(i>p)sFW(ar,p,i,m);
		}else if(f)sFW(ar,p,j,b);
		return i<m?i:j;
	}
	function blt(ar,a,b,bl){
		let c=cci(ar,a,b);
		return c==-1||(c==0&&cci(ar,a+bl-1,b+bl-1)==-1);
	}
	function bmr(ar,a,m,b,bL){
		let b1=b-(b-m-1)%bL-1|0;
		if(b1>m){
			let b2=b1;
			for(let i=m-bL;i>a&&blt(ar,b1,i,bL);i-=bL,b2-=bL);
			for(let j=a;j<b1-bL;j+=bL){
				let min=j;
				for(let i=min+bL;i<b1;i+=bL)
					if(blt(ar,i,min,bL))min=i;
				if(min!=j)msw(ar,j,min,bL);
			}
			let f=a;
			for(let i=a+bL;i<b2;i+=bL){
				f=merge(ar,f-bL,f,i,i+bL,false);
				if(f<i){
					sBW(ar,f,i,i+bL);
					f+=bL;
				}
			}
			merge(ar,f-bL,f,b1,b,true);
		}else merge(ar,a-bL,a,m,b,true);
	}
	let n=len;
	if(len<=16)ins(array,0,len);
	else{
		let bL=1;
		for(;bL*bL<len;bL*=2);
		let i=bL,j=1,l=len-i,b=len;
		while(j<=bL){
			for(;i+2*j<b;i+=2*j)merge(array,i-j,i,i+j,i+2*j,true);
			if(i+j<b)merge(array,i-j,i,i+j,b,true);
			else sFW(array,i-j,i,b);
			i=b+bL-j;b=i+l;j*=2;
		}
		while(j<l){
			for(;i+2*j<b;i+=2*j)bmr(array,i,i+j,i+2*j,bL);
			if(i+j<b)bmr(array,i,i+j,b,bL);
			else sFW(array,i-bL,i,b);
			i=b;b+=l;j*=2;
		}
		ins(array,i-bL,i);
		ipm(array,i-bL,i,b);
		rot(array,0,(i-bL)%n,len);
	}
	return[5,1]
}
function poplarHeapSort(){
	let array=[...arr];
	const hf=n=>pow(2,floor(log(n)/log(2)));
	function uis(ar,f,l){
		for(let i=f+1;i!=l;++i){
			let s=i,s1=i-1;
			if(compareIndices(ar,s,s1)<0){
				let t=ar[s];
				do write(ar,s,ar[s1]);while(--s!=f&&compareValues(t,ar[--s1])<0);
				write(ar,s,t);
			}
		}
	}
	function ins(ar,f,l){
		if(f==l)return;
		uis(ar,f,l);
	}
	function sift(ar,f,sz){
		if(sz<2)return;
		let rt=f+sz-1,cr1=rt-1,cr2=f+(sz/2-1)|0;
		while(1){
			let mr=rt;
			if(compareIndices(ar,mr,cr1)<0)mr=cr1;
			if(compareIndices(ar,mr,cr2)<0)mr=cr2;
			if(mr==rt)return;
			swap(ar,rt,mr);
			sz/=2;
			if(sz<2)return;
			rt=mr;cr1=rt-1;cr2=mr-sz/2|0;
		}
	}
	function phws(ar,f,l,sz){
		let prs=hf(sz+1)-1,lrt=l-1,bg=lrt,bgs=prs,it=f;
		while(1){
			let rt=it+prs-1;
			if(rt==lrt)break;
			if(compareIndices(ar,bg,rt)<0){
				bg=rt;bgs=prs;
			}
			it=rt+1;sz-=prs;prs=hf(sz+1)-1;
		}
		if(bg!=lrt){
			swap(ar,bg,lrt);
			sift(ar,bg-(bgs-1),bgs);
		}
	}
	function mkhp(ar,f,l){
		let sz=l-f;
		if(sz<2)return;
		let sps=15;
		if(sz<=sps)return uis(ar,f,l);
		let prl=1,it=f,nx=it+sps;
		while(1){
			uis(ar,it,nx);
			let prs=sps;
			for(let i=(prl&(-prl))>>1;i!=0;i>>=1){
				it-=prs;prs=2*prs+1;
				sift(ar,it,prs);
				++nx;
			}
			if((l-nx)<=sps)return ins(ar,nx,l);
			it=nx;nx+=sps;
			++prl;
		}
	}
	function shp(ar,f,l){
		let sz=l-f;
		if(sz<2)return;
		do phws(ar,f,l--,sz--);while(sz>1);
	}
	function hs(a,s,e){
		mkhp(a,s,e);
		shp(a,s,e);
	}
	hs(array,0,len);
	return[5,1]
}
function adaptiveGrailSort(){
	let array=[...arr];
	const subarray={LEFT:"L",RIGHT:"R"}
	let minRun;
	const msw=(ar,a,b,l)=>{
		for(let i=0;i<l;i++)
			swap(ar,a+i,b+i);
	}
	const mts=(ar,a,b,c,l)=>{
		for(let i=0;i<l;i++){
			let t=ar[a+i];
			write(ar,a+i,ar[b+i]);
			write(ar,b+i,ar[c+i]);
			write(ar,c+i,t);
		}
	}
	function insto(ar,a,b){
		let t=ar[a];
		while(a>b)write(ar,a,ar[(a--)-1]);
		write(ar,b,t);
	}
	function instoBW(ar,a,b){
		let t=ar[a];
		while(a<b)write(ar,a,ar[(a++)+1]);
		write(ar,a,t);
	}
	function shft(ar,a,m,b){
		while(m<b)swap(ar,a++,m++);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>1&&r>1){
			if(r<l){
				msw(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
		if(r==1)insto(ar,m,a);
		else if(l==1)instoBW(ar,a,b-1);
	}
	function lbs(ar,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	function rbs(ar,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function burn(ar,a,n){
		let nk=1,i=a+1;
		if(compareIndices(ar,i-1,i)==-1){
			i++;nk++;
			while(nk<n&&compareIndices(ar,i-1,i)<0){
				i++;nk++;
			}
		}else if(compareIndices(ar,i-1,i)>0){
			i++;nk++;
			while(nk<n&&compareIndices(ar,i-1,i)>0){
				i++;nk++;
			}
			reversal(ar,a,i-1,0);
		}
		return nk;
	}
	function burnBW(ar,b,n){
		let nk=1,i=b-1;
		if(compareIndices(ar,i-1,i)<0){
			i--;nk++;
			while(nk<n&&compareIndices(ar,i-1,i)<0){
				i--;nk++;
			}
		}else if(compareIndices(ar,i-1,i)>0){
			i--;nk++;
			while(nk<n&&compareIndices(ar,i-1,i)>0){
				i--;nk++;
			}
			reversal(ar,i,b-1,0);
		}
		return nk;
	}
	function fkys(ar,a,b,nk,n){
		let p=a,pE=a+nk;
		for(let i=pE;i<b&&nk<n;i++){
			let loc=lbs(ar,p,pE,ar[i]);
			if(pE==loc||compareIndices(ar,i,loc)!=0){
				rot(ar,p,pE,i);
				let inc=i-pE;
				loc+=inc;p+=inc;pE+=inc;
				insto(ar,pE,loc);
				nk++;pE++;
			}
		}
		rot(ar,a,p,pE);
		return nk;
	}
	function fkysBW(ar,a,b,nk,n){
		let p=b-nk,pE=b;
		for(let i=p-1;i>=a&&nk<n;i--){
			let loc=lbs(ar,p,pE,ar[i]);
			if(pE==loc||compareIndices(ar,i,loc)!=0){
				rot(ar,i+1,p,pE);
				let inc=p-(i+1);
				loc-=inc;pE-=inc;p-=inc+1;nk++;
				instoBW(ar,i,loc-1);
			}
		}
		rot(ar,p,pE,b);
		return nk;
	}
	function buildRuns(ar,a,b){
		let i=a+1,j=a;
		while(i<b){
			if(compareIndices(ar,i-1,i++)==1){
				while(i<b&&compareIndices(ar,i-1,i)==1)i++;
				reversal(ar,j,i-1,0);
			}else while(i<b&&compareIndices(ar,i-1,i)<1)i++;
			if(i<b)j=i-(i-j-1)%minRun-1;
			while(i-j<minRun&&i<b)
				insto(ar,i,rbs(ar,j,i,ar[i++]));
			j=i++;
		}
	}
	function binins(ar,a,b){
		for(let i=a+1;i<b;i++)insto(ar,i,rbs(ar,a,i,ar[i]));
	}
	function mwbr(ar,a,m,b,p,pL){
		let i=0,j=m,k=a;
		while(i<pL&&j<b){
			if(compareIndices(ar,p+i,j)<1)swap(ar,k++,p+(i++));
			else swap(ar,k++,j++);
		}
		while(i<pL)swap(ar,k++,p+(i++));
	}
	function mwb(ar,a,m,b,p){
		let l=m-a;
		msw(ar,p,a,l);
		mwbr(ar,a,m,b,p,l);
	}
	function mwbBW(ar,a,m,b,p){
		let pL=b-m;
		msw(ar,m,p,pL);
		let i=pL-1,j=m-1,k=b-1;
		while(i>=0&&j>=a){
			if(compareIndices(ar,p+i,j)>=0)swap(ar,k--,p+(i--));
			else swap(ar,k--,j--);
		}
		while(i>=0)swap(ar,k--,p+(i--));
	}
	function ipm(ar,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(compareIndices(ar,i,j)>0){
				k=lbs(ar,j+1,b,ar[i]);
				rot(ar,i,j,k);
				i+=k-j;j=k;
			}else i++;
		}
	}
	function ipmBW(ar,a,m,b){
		let i=m-1,j=b-1,k;
		while(j>i&&i>=a){
			if(compareIndices(ar,i,j)>0){
				k=rbs(ar,a,i,ar[j]);
				rot(ar,k,i+1,j+1);
				j-=(i+1)-k;i=k-1;
			}else j--;
		}
	}
	function mwob(ar,a,m,b){
		if(m-a>b-m)ipmBW(ar,a,m,b);
		else ipm(ar,a,m,b);
	}
	const csrt=(ar,a,m,b)=>compareIndices(ar,m-1,m)>0;
	function ckrbd(ar,a,m,b){
		if(compareIndices(ar,a,b-1)==1){
			rot(ar,a,m,b);
			return false;
		}
		return true;
	}
	const ckbd=(ar,a,m,b)=>csrt(ar,a,m,b)&&ckrbd(ar,a,m,b);
	const grlgetsub=(a,t,m)=>compareIndices(a,t,m)<0?subarray.LEFT:subarray.RIGHT;
	function blslsrt(ar,p,t,r,d,lCount,bCount,bL){
		let mKey=lCount;
		for(let j=0,k=lCount+1;j<k-1;j++){
			let min=j;
			for(let i=maxVal(lCount-r,j+1);i<k;i++){
				let cmp=compareIndices(ar,p+d+i*bL,p+d+min*bL);
				if(cmp<0||(cmp==0&&compareIndices(ar,t+i,t+min)<0))min=i;
			}
			if(min!=j){
				msw(ar,p+j*bL,p+min*bL,bL);
				swap(ar,t+j,t+min);
				if(k<bCount&&min==k-1)k++;
			}
			if(min==mKey)mKey=j;
		}
		return t+mKey;
	}
	function grlsrtkys(ar,b,p,mKey){
		swap(ar,p,mKey);
		let i=mKey,j=i+1,k=p+1;
		while(j<b){
			if(compareIndices(ar,j,p)<0)swap(ar,i++,j);
			else swap(ar,k++,j);
			j++;
		}
		msw(ar,i,p,b-i);
	}
	function grlsrtkyswob(ar,b,mKey){
		let i=mKey,j=i+1;
		while(j<b){
			if(compareIndices(ar,j,i)<0)insto(ar,j,i++);
			j++;
		}
	}
	function grlmbl(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<1)swap(ar,p++,i++);
			else swap(ar,p++,j++);
		}
		if(i>p)while(i<m)swap(ar,p++,i++);
		return j;
	}
	function grlmblRev(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<0)swap(ar,p++,i++);
			else swap(ar,p++,j++);
		}
		if(i>p)while(i<m)swap(ar,p++,i++);
		return j;
	}
	function grlblm(ar,a,m,b,t,p,bL){
		let b1=b-(b-m-1)%bL-1,i=a+bL,j=a,key=t-1,lCount=(m-i)/bL|0,bCount=(b1-i)/bL|0,l=-1,r=lCount-1;
		mts(ar,p,m-bL,a,bL);
		instoBW(ar,t,t+lCount-1);
		let mKey=blslsrt(ar,i,t,1,bL-1,lCount,bCount,bL);
		let frag=subarray.LEFT;
		while(l<lCount&&r<bCount){
			if(frag==subarray.LEFT){
				do{j+=bL;l++;key++;}while(l<lCount&&grlgetsub(ar,key,mKey)==subarray.LEFT);
				if(l==lCount){
					i=grlmbl(ar,i,j,b,i-bL);
					mwbr(ar,i-bL,i,b,p,bL);
				}else i=grlmbl(ar,i,j,j+bL-1,i-bL);
				frag=subarray.RIGHT;
			}else{
				do{j+=bL;r++;key++;}while(r<bCount&&grlgetsub(ar,key,mKey)==subarray.RIGHT);
				if(r==bCount){
					shft(ar,i-bL,i,b);
					msw(ar,p,b-bL,bL);
				}else i=grlmblRev(ar,i,j,j+bL-1,i-bL);
				frag=subarray.LEFT;
			}
		}
		grlsrtkys(ar,t+bCount,p,mKey);
	}
	function grlblmwob(ar,a,m,b,t,bL){
		let a1=a+(m-a)%bL,b1=b-(b-m)%bL,i=a,j=a1,key=t,lCount=(m-j)/bL+1|0,bCount=(b1-j)/bL+1|0,l=0,r=lCount;
		let mKey=blslsrt(ar,j,t,0,0,lCount-1,bCount-1,bL);
		let frag=subarray.LEFT;
		while(l<lCount&&r<bCount){
			let next=grlgetsub(ar,key++,mKey);
			if(next==frag){
				if(frag==subarray.LEFT)l++;
				else r++;
				i=j;
			}else{
				let m2=j,b2=j+bL,k;
				if(frag==subarray.LEFT){
					while(i<m2&&m2<b2){
						if(compareIndices(ar,i,m2)>0){
							k=lbs(ar,m2+1,b2,ar[i]);
							rot(ar,i,m2,k);
							i+=k-m2;
							m2=k;
						}else i++;
					}
				}else{
					while(i<m2&&m2<b2){
						if(compareIndices(ar,i,m2)>=0){
							k=rbs(ar,m2+1,b2,ar[i]);
							rot(ar,i,m2,k);
							i+=k-m2;
							m2=k;
						}else i++;
					}
				}
				if(i<m2){
					if(next==subarray.LEFT)l++;
					else r++;
				}else{
					if(frag==subarray.LEFT)l++;
					else r++;
					frag=next;
				}
			}
			j+=bL;
		}
		if(l<lCount)ipmBW(ar,a,b1,b);
		grlsrtkyswob(ar,t+bCount-1,mKey);
	}
	function smtm(ar,a,m,b,p){
		if(ckbd(ar,a,m,b)){
			a=rbs(ar,a,m-1,ar[m]);
			mwb(ar,a,m,b,p);
		}
	}
	function smtmBW(ar,a,m,b,p){
		if(ckbd(ar,a,m,b)){
			b=lbs(ar,m+1,b,ar[m-1]);
			mwbBW(ar,a,m,b,p);
		}
	}
	function smtblm(ar,a,m,b,t,p,bL){
		if(ckbd(ar,a,m,b)){
			let n=rbs(ar,a,m-1,ar[m]);
			b=lbs(ar,m+1,b,ar[m-1]);
			if(ckrbd(ar,n,m,b)){
				if(m-n<=bL||b-m<=bL){
					if(b-m<m-n)mwbBW(ar,n,m,b,p);
					else mwb(ar,n,m,b,p);
				}else{
					n-=(n-a)%bL;
					grlblm(ar,n,m,b,t,p,bL);
				}
			}
		}
	}
	function smtblmwob(ar,a,m,b,t,bL){
		if(ckbd(ar,a,m,b)){
			a=rbs(ar,a,m-1,ar[m]);
			if(m-a<=bL)ipm(ar,a,m,b);
			else grlblmwob(ar,a,m,b,t,bL);
		}
	}
	function smtipm(ar,a,m,b){
		if(csrt(ar,a,m,b))ipmBW(ar,a,m,b);
	}
	function rbuf(ar,a,m,b){
		let rPos=lbs(ar,m,b,ar[a]);
		rot(ar,a,m,rPos);
		let dist=rPos-m;
		a+=dist;
		m+=dist;
		let a1=a+(m-a)/2|0;
		rPos=lbs(ar,m,b,ar[a1]);
		rot(ar,a1,m,rPos);
		dist=rPos-m;
		a1+=dist;
		m+=dist;
		mwob(ar,a,a1-dist,a1);
		mwob(ar,a1,m,b);
	}
	function rbufBW(ar,a,m,b){
		let rPos=rbs(ar,a,m,ar[b-1]);
		rot(ar,rPos,m,b);
		let dist=m-rPos;
		b-=dist;
		m-=dist;
		let b1=m+(b-m)/2|0;
		rPos=rbs(ar,a,m,ar[b1-1]);
		rot(ar,rPos,m,b1);
		dist=m-rPos;
		b1-=dist;
		m-=dist;
		mwob(ar,b1,b1+dist,b);
		mwob(ar,a,m,b1);
	}
	function ipms(ar,a,b){
		buildRuns(ar,a,b);
		let l=b-a;
		for(let i,j=minRun;j<l;j*=2){
			for(i=a;i+2*j<=b;i+=2*j)smtipm(ar,i,i+j,i+2*j);
			if(i+j<b)smtipm(ar,i,i+j,b);
		}
	}
	function grladswob(ar,a,b,keys,ideal,bwBuf){
		let l=b-a,bL;
		for(bL=minVal(keys,minRun);2*bL<=keys;bL*=2);
		let tLen=keys-bL;
		let i,j=minRun,t,p,a1,b1;
		if(bwBuf){
			p=b-bL;a1=a;b1=p-tLen;t=b1;
		}else{
			p=a+tLen;a1=p+bL;b1=b;t=a;
		}
		buildRuns(ar,a1,b1);
		while(j<=bL&&j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtm(ar,i,i+j,i+2*j,p);
			if(i+j<b1)
				smtmBW(ar,i,i+j,b1,p);
			j*=2;
		}
		if(bL/2>=minRun&&bL/2>=(keys+1)/2){
			binins(ar,p,p+bL|0);
			bL/=2;
			tLen=keys-bL|0;
			p+=bL|0;
		}
		bL|=0
		while(tLen>=2*j/bL-1&&j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtblm(ar,i,i+j,i+2*j,t,p,bL);
			if(i+j<b1){
				if(b1-(i+j)>bL)smtblm(ar,i,i+j,b1,t,p,bL);
				else smtmBW(ar,i,i+j,b1,p);
			}
			j*=2;
		}
		binins(ar,p,p+bL);
		tLen=keys-keys%2;
		while(j<l){
			bL=2*j/tLen;
			for(i=a1;i+2*j<=b1;i+=2*j)
				smtblmwob(ar,i,i+j,i+2*j,t,bL);
			if(i+j<b1){
				if(b1-(i+j)>bL)smtblmwob(ar,i,i+j,b1,t,bL);
				else smtipm(ar,i,i+j,b1);
			}
			j*=2;
		}
		if(bwBuf){
			a=rbs(ar,a,b1,ar[b1]);
			if(keys>=ideal/2)rbufBW(ar,a,b1,b);
			else mwob(ar,a,b1,b);
		}else{
			b=lbs(ar,a1,b,ar[a1-1]);
			if(keys>=ideal/2)rbuf(ar,a,a1,b);
			else mwob(ar,a,a1,b);
		}
	}
	function grlasd(ar,a,b){
		let l=b-a;
		if(l<31)return binins(ar,a,b);
		if(l<63){
			minRun=(l+1)/2|0;
			buildRuns(ar,a,b);
			let m=a+minRun;
			if(ckbd(ar,a,m,b))rbufBW(ar,a,m,b);
			return;
		}
		for(minRun=l;minRun>=32;minRun=(minRun+1)/2);
		minRun|=0;
		let bL;
		for(bL=minRun;bL*bL<l;bL*=2);
		let tLen=l/bL-2,ideal=tLen+bL,bwBuf,rRun=burnBW(ar,b,ideal),lRun=0;
		if(rRun==ideal)bwBuf=true;
		else{
			lRun=burn(ar,a,ideal);
			if(lRun==ideal)bwBuf=false;
			else bwBuf=(rRun<16&&lRun<16)||rRun>=lRun;
		}
		let keys=bwBuf?fkysBW(ar,a,b,rRun,ideal):fkys(ar,a,b,lRun,ideal);
		if(keys<ideal){
			if(keys==1)return;
			else if(keys<=4)ipmSort(ar,a,b);
			else grladswob(ar,a,b,keys,ideal,bwBuf);
			return;
		}
		let i,j=minRun,t,p,a1,b1;
		if(bwBuf){p=b-bL;a1=a;b1=p-tLen;t=b1;
		}else{p=a+tLen;a1=p+bL;b1=b;t=a;}
		buildRuns(ar,a1,b1);
		while(j<=bL&&j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)smtm(ar,i,i+j,i+2*j,p);
			if(i+j<b1)smtmBW(ar,i,i+j,b1,p);
			j*=2;
		}
		while(j<l){
			for(i=a1;i+2*j<=b1;i+=2*j)smtblm(ar,i,i+j,i+2*j,t,p,bL);
			if(i+j<b1){
				if(b1-(i+j)>bL)smtblm(ar,i,i+j,b1,t,p,bL);
				else smtmBW(ar,i,i+j,b1,p);
			}
			j*=2;
		}
		binins(ar,p,p+bL);
		if(bwBuf){
			a=rbs(ar,a,b1,ar[b1]);
			rbufBW(ar,a,b1,b);
		}else{
			b=lbs(ar,a1,b,ar[a1-1]);
			rbuf(ar,a,a1,b);
		}
	}
	grlasd(array,0,len);
	return[5,1]
}
function introSort(){
	let array=[...arr];
	const flbt=a=>floor(log(a)/log(2));
	function gm3(ar,a,m,b){
		if(compareIndices(ar,a,m)<0){
			if(compareIndices(ar,m,b)<0)swap(ar,a,m);
			else if(compareIndices(ar,a,b)<0)swap(ar,a,b);
		}else if(compareIndices(ar,a,b)<0)return ar[a];
		else if (compareIndices(ar,m,b)<0)swap(ar,a,b);
		else swap(ar,a,m);
		return ar[a];
	}
	function m3(ar,a,m,b){
		if(compareIndices(ar,b,a)<0)swap(ar,a,b);
		if(compareIndices(ar,m,b)<0)swap(ar,m,a);
		if(compareIndices(ar,b,m)<0)swap(ar,b,m);
		return ar[m];
	}
	function par(a,lo,hi,x){
		let i=lo,j=hi;
		while(1){
			while(compareValues(a[i],x)<0)i++;
			do j--;while(compareValues(x,a[j])<0);
			if(i>=j)return i;
			swap(a,i++,j);
		}
	}
	function sort(a,lo,hi,d){
		while(hi-lo>16){
			if(d==0)return heapSort(a,lo,hi,true);
			let p=par(a,lo,hi,m3(a,lo,lo+(hi-lo)/2|0,hi-1));
			sort(a,p,hi,--d);
			hi=p;
		}
	}
	sort(array,0,len,2*flbt(len));
	insertSort(array,0,len);
	return[5,1]
}
function triangularHeapSort(){
	let array=[...arr];
	const trt=v=>sqrt((8*v+1)-1)/2|0;
	function sd(a,e,r){
		let t=a[r],ln=trt(r),l=r+ln+1,ri=l+1;
		while(l<e){
			if(ri>=e){
				if(compareValues(a[l],t)>0)write(a,r,a[l]);
				break;
			}
			let mx=compareIndices(a,l,ri)>=0?l:ri;
			if(compareValues(a[mx],t)>0){
				write(a,r,a[mx]);
				r=mx;ln=trt(r);l=r+ln+1;ri=l+1;
				continue;
			}
			break;
		}
		write(a,r,t);
	}
	function trheap(a,l){
		for(let i=l-1;i>=0;i--)sd(a,l,i);
	}
	trheap(array,len);
	for(let i=1;i<len-1;i++){ 
		swap(array,0,len-i);
		sd(array,len-i,0);
	}
	if(compareIndices(array,0,1)>0)swap(array,0,1);
	return[5,1]
}
function laziestStableSort(){
	let array=[...arr];
	const insto=(ar,a,b)=>{
		let t=ar[a];
		while(a>b)write(ar,a,ar[--a]);
		write(ar,b,t);
	}
	const msw=(ar,a,b,l)=>{
		for(let i=0;i<l;i++)
			swap(ar,a+i,b+i);
	}
	const rot=(ar,a,m,b)=>{
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				msw(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(ar,a,m,l);
				a+=l;m+= l;r-=l;
			}
		}
	}
	const lbs=(ar,a,b,v)=>{
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	const rbs=(ar,a,b,v)=>{
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	const les=(ar,a,b,v)=>{
		let i=1;
		while(a-1+i<b&&compareValues(v,ar[a-1+i])>0)i*=2;
		return lbs(ar,a+i/2|0,minVal(b,a-1+i),v);
	}
	const binsert=(ar,a,b)=>{
		for(let i=a+1;i<b;i++)
			insto(ar,i,rbs(ar,a,i,ar[i]));
	}
	const ipm=(ar,a,m,b)=>{
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(compareIndices(ar,i,j)>0){
				k=les(ar,j+1,b,ar[i]);
				rot(ar,i,j,k);
				i+=k-j;j=k;
			}else i++;
		}
	}
	let l=len;
	if(l<=16)binsert(array,0,len);
	else{
		let i,bL=maxVal(16,sqrt(l)|0);
		for(i=0;i+2*bL<len;i+=bL)
			binsert(array,i,i+bL);
		binsert(array,i,len);
		while(i-bL>=0){
			ipm(array,i-bL,i,len);
			i-=bL;
		}
	}
	return[5,1]
}
function lazierestSort(){
	let array=[...arr];
	const cc=n=>{
		let a=0,b=minVal(1291,n);
		while(a<b){
			let m=(a+b)/2|0;
			if(m*m*m>=n)b=m;
			else a=m+1;
		}
		return a;
	}
	function insto(ar,a,b){
		let t=ar[a];
		while(a>b)write(ar,a,ar[--a]);
		write(ar,b,t);
	}
	function ms(ar,a,b,l){
		for(let i=0;i<l;i++)
			swap(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				ms(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				ms(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function lbs(ar,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	function rbs(ar,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,ar[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	function les(ar,a,b,v){
		let i=1;
		while(a-1+i<b&&compareValues(v,ar[a-1+i])>0)i*=2;
		return lbs(ar,a+i/2|0,minVal(b,a-1+i),v);
	}
	function res(ar,a,b,v){
		let i=1;
		while(b-i>=a&&compareValues(v,ar[b-i])<0)i*=2;
		return rbs(ar,maxVal(a,b-i+1),b-i/2|0,v);
	}
	function binsert(ar,a,b){
		for(let i=a+1;i<b;i++)
			insto(ar,i,rbs(ar,a,i,ar[i]));
	}
	function ipmFW(ar,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(compareIndices(ar,i,j)>0){
				k=les(ar,j+1,b,ar[i]);
				IndexRots.cycleReverse(ar,i,j,k,false);
				i+=k-j;j=k;
			}else i++;
		}
	}
	function ipmBW(ar,a,m,b){
		let i=m-1,j=b-1,k;
		while(j>i&&i>=a){
			if(compareIndices(ar,i,j)>0){
				k=res(ar,a,i,ar[j]);
				rot(ar,k,i+1,j+1);
				j-=i+1-k;i=k-1;
			}else j--;
		}
	}
	function ipm(ar,a,m,b){
		if(b-m<m-a)ipmBW(ar,a,m,b);
		else ipmFW(ar,a,m,b);
	}
	function fm(ar,a,m,b,s){
		let i=a+(m-a)%s;
		while(i<m){
			let j=les(ar,m,b,ar[i]);
			IndexRots.cycleReverse(ar,i,m,j,false);
			let rLen=j-m;
			j=i;i+=rLen;m+=rLen;
			ipm(ar,a,j,i);
			a=i;i+=s;
		}
		ipm(ar,maxVal(a,i-s),i,b);
	}
	function lss(ar,a,b){
		let l=b-a,s=cc(l),s1=s*s;
		for(let i=l%s;i<=b;i+=s)binsert(ar,maxVal(a,i-s),i);
		for(let i=b-s,j=b;i>a;i-=s){
			if(j-i==s1){j-=s1;i-=s;}
			ipmFW(ar,maxVal(a,i-s),i,j);
		}
		for(let i=b-s1;i>a;i-=s1)fm(ar,maxVal(a,i-s1),i,b,s);
	}
	if(len<=16)binsert(array,0,len);
	else lss(array,0,len);
	return[5,1]
}
function binaryQuickSort(){
	let array=[...arr];
	function bqsr(a,p,r,b){
		if(p>=r||b<0)return;
		let q=par(a,p,r,b--);
		bqsr(a,p,q,b);
		bqsr(a,q+1,r,b);
	}
	function par(a,p,r,b){
		let i=p-1,j=r+1;
		while(1){
			do i++;while(i<=r&&!getBit(a[i],b));
			do j--;while(j>=p&&getBit(a[j],b));
			if(i<j)swap(a,i,j);
			else return j;
		}
	}
	let msb=analyzeBit(array,len);
	bqsr(array,0,len-1,msb);
	return[5,1]
}
function staticSort(){
	let array=[...arr];
	function mnmx(ar,a,b){
		let mn=ar[a],mx=mn;
		for(let i=a+1;i<b;i++){
			if(compareValues(ar[i],mn)<0)mn=ar[i];
			else if(compareValues(ar[i],mx)>0)mx=ar[i];
		}
		return[mn,mx];
	}
	function sts(ar,a,b){
		let mmx=mnmx(ar,a,b);
		let aul=b-a;
		let cn=new Array(aul+1).fill(0),ofs=new Array(aul+1).fill(0);
		let C=aul/(mmx[1]-mmx[0]+1);
		let idx;
		for(let i=a;i<b;i++){
			idx=((ar[i]-mmx[0])*C)|0;
			write(cn,idx,cn[idx]+1,true);
		}
		write(ofs,0,a,true);
		for(let i=1;i<aul;i++)write(ofs,i,cn[i-1]+ofs[i-1],true);
		for(let v=0;v<aul;v++){
			while(cn[v]>0){
				let og=ofs[v],fr=og,n=ar[fr];
				do{
					idx=((n-mmx[0])*C)|0;
					let t=ofs[idx];
					write(ofs,idx,ofs[idx]+1,true);
					write(cn,idx,cn[idx]-1,true);
					let tm=ar[t];
					write(ar,t,n);
					n=tm;
					fr=t;
				}while(fr!=og);
			}
		}
		for(let i=0;i<aul;i++){
			let s=(i>1)?ofs[i-1]:a,
				e=ofs[i];
			if(e-s<=1)continue;
			if(e-s>16)heapSort(ar,s,e,true);
			else insertSort(ar,s,e);
		}
	}
	sts(array,0,len);
	return[5,1]
}
function binaryGnomeSort(){
	let array=[...arr];
	for(let i=1;i<len;i++){
		let n=array[i],lo=0,hi=i;
		while(lo<hi){
			let m=lo+((hi-lo)/2)|0;
			if(compareValues(n,array[m])<0)hi=m;
			else lo=m+1;
		}
		let j=i;
		while(j>lo)swap(array,j,--j);
	}
	return[5,1]
}
function dualPivotQuickSort(){
	let array=[...arr];
	function dpqs(ar,lf,ri,dv){
		let ln=ri-lf;
		if(ln<4)return insertSort(ar,lf,ri+1);
		let th=ln/dv|0,m1=lf+th,m2=ri-th;
		if(m1<=lf)m1=lf+1;
		if(m2>=ri)m2=ri-1;
		if(compareIndices(ar,m1,m2)<0){
			swap(ar,m1,lf);
			swap(ar,m2,ri);
		}else{
			swap(ar,m1,ri);
			swap(ar,m2,lf);
		}
		let p1=ar[lf],p2=ar[ri],ls=lf+1,gr=ri-1;
		for(let k=ls;k<=gr;k++){
			if(compareValues(ar[k],p1)<0)swap(ar,k,ls++);
			else if(compareValues(ar[k],p2)>0){
				while(k<gr&&compareValues(ar[gr],p2)>0)gr--;
				swap(ar,k,gr--);
				if(compareValues(ar[k],p1)<0)swap(ar,k,ls++);
			}
		}
		let ds=gr-ls;
		if(ds<13)dv++;
		swap(ar,ls-1,lf);
		swap(ar,gr+1,ri);
		dpqs(ar,lf,ls-2,dv);
		if(p1<p2)dpqs(ar,ls,gr,dv);
		dpqs(ar,gr+2,ri,dv);
	}
	dpqs(array,0,len-1,3);
	return[5,1]
}
function shoveSort(){
	let array=[...arr];
	function cf(a,i,e){
		for(let k=i;k<e-1;k++)swap(a,k,k+1,true);
	}
	function ssr(a,s,e){
		for(let i=s;i<e-1;){
			if(compareIndices(a,i,i+1)>0){
				customFunc(cf,[i,e])
				cf(a,i,e)
				if(i>s)i--;
				continue;
			}
			i++
		}
	}	
	ssr(array,0,len);
	return[5,1]
}
function quadStoogeSort(){
	let array=[...arr];
	function qss(a,p,l){
		if(l>=2&&compareIndices(a,p,p+l-1)>0)swap(a,p,p+l-1);
		if(l<3)return;
		let l1=l/2|0,l2=(l+1)/2|0,l3=(l1+1)/2+(l2+1)/2|0;
		qss(a,p,l1);
		qss(a,p+l1,l2);
		qss(a,p+l1/2|0,l3);
		qss(a,p+l1,l2);
		qss(a,p,l1);
		if(l>3)qss(a,p+l1/2|0,l3);
	}
	qss(array,0,len);
	return[5,1]
}
function insertionSort(){
	let array=[...arr];
	insertSort(array,0,len)
	return[5,1]
}
function forcedStableQuickSort(){
	let array=[...arr];
	function mot(ar,k,a,b){
		let m=a+(b-1-a)/2|0;
		if(sc(ar,k,a,m))ss(ar,k,a,m);
		if(sc(ar,k,m,b-1)){
			ss(ar,k,m,b-1);
			if(sc(ar,k,a,m))return;
		}
		ss(ar,k,a,m);
	}
	const sc=(ar,k,a,b)=>{
		let c=compareIndices(ar,a,b);
		return c>0||(c==0&&compareIndices(k,a,b)>0);
	}
	function ss(ar,k,a,b){
		swap(ar,a,b,false);
		swap(k,a,b,true);
	}
	function par(ar,k,a,b,p){
		let i=a-1,j=b;
		while(1){
			do i++;while(i<j&&!sc(ar,k,i,p));
			do j--;while(j>=i&&sc(ar,k,j,p));
			if(i<j)ss(ar,k,i,j);
			else return j;
		}
	}
	function qks(ar,k,a,b){
		if(b-a<3){
			if(b-a==2&&sc(ar,k,a,a+1))ss(ar,k,a,a+1);
			return;
		}
		mot(ar,k,a,b);
		let p=par(ar,k,a+1,b,a);
		ss(ar,k,a,p);
		qks(ar,k,a,p);
		qks(ar,k,p+1,b);
	}
	let k=new Array(len);
	for(let i=0;i<len;i++)
		write(k,i,i,true);
	qks(array,k,0,len);
	return[5,1]
}
function optimizedStoogeSort(){
	let array=[...arr];
	const cs=(ar,a,b)=>{
		if(compareIndices(ar,a,b)>0){
			swap(ar,a,b);
			return true;
		}
		return false;
	}
	function sss(ar,a,m,b,mr){
		if(a>=m)return false;
		if(b-a==2)return cs(ar,a,m);
		let lc=false,rc=false,a2=(a+a+b)/3|0,b2=(a+b+b+2)/3|0;
		if(m<b2){
			lc=sss(ar,a,m,b2,mr);
			if(mr){
				rc=sss(ar,maxVal(a+b2-m,a2),b2,b,true);
				if(rc)sss(ar,a+b2-m,a2,2*a2-a,true);
			}else{
				rc=sss(ar,a2,b2,b,false);
				if(rc)sss(ar,a,a2,2*a2-a,true);
			}
		}else{
			rc=sss(ar,a2,m,b,mr);
			if(rc)sss(ar,a,a2,a2+b-m,true);
		}
		return lc||rc;
	}
	sss(array,0,1,len,false);
	return[5,1]
}
function swaplessBubbleSort(){
	let array=[...arr];
	let ls;
	for(let i=len;i>0;i=ls){
		ls=0;
		let p=0,c=array[0];
		for(let j=1;j<i;j++){
			if(compareValues(c,array[j])>0){
				write(array,j-1,array[j]);
				ls=j;
			}else{
				if(p+1<j)write(array,j-1,c);
				p=j;
				c=array[j];
			}
		}
		write(array,i-1,c);
	}
	return[5,1]
}
function gravitySort(){
	let array=[...arr];
	let aux=new Array(len),s=0,e=len;
	for(let i=0;i<len;i++)write(aux,i,array[i],true);
	let min=aux[s],max=min;
	for(let i=s+1;i<e;i++)if(aux[i]<min)min=aux[i];else if(aux[i]>max)max=aux[i];
	let sz=max-min+1,h=new Array(sz).fill(0);
	for(let i=s;i<e;i++)h[aux[i]-min]++
	for(let i=0,j=s;i<sz;i++)while(h[i]-->0)write(aux,j++,i+min,true);
	let c=1;
	while(c){
		c=0;
		for(let i=0;i<len;i++){
			let inc=sign(aux[i]-array[i]);
			if(inc==0)continue;
			write(array,i,array[i]+=inc);
			c=1;
		}
	}
	return[5,1]
}
function tableSort(){
	let array=[...arr];
	const sc=(ar,t,a,b)=>{
		let c=compareIndices(ar,t[a],t[b]);
		return c>0||(c==0&&compareIndices(t,a,b)>0);
	}
	function mot(ar,t,a,b){
		let m=a+(b-1-a)/2|0;
		if(sc(ar,t,a,m))swap(t,a,m,true);
		if(sc(ar,t,m,b-1)){
			swap(t,m,b-1,true);
			if(sc(ar,t,a,m))return;
		}
		swap(t,a,m,true);
	}
	function par(ar,t,a,b,p){
		let i=a-1,j=b;
		swap(ar,p,p)
		while(1){
			do i++;while(i<j&&!sc(ar,t,i,p));
			do j--;while(j>=i&&sc(ar,t,j,p));
			if(i<j){swap(t,i,j,true);swap(ar,i,i)}
			else return j;
		}
	}
	function qs(ar,t,a,b){
		if(b-a<3){
			if(b-a==2&&sc(ar,t,a,a+1))swap(t,a,a+1,true);
			return;
		}
		mot(ar,t,a,b);
		let p=par(ar,t,a+1,b,a);
		swap(t,a,p,true);
		qs(ar,t,a,p);
		qs(ar,t,p+1,b);
	}
	let tb=new Array(len);
	for(let i=0;i<len;i++)write(tb,i,i,true);
	qs(array,tb,0,len);
	for(let i=0;i<tb.length;i++){
		if(compareValues(i,tb[i])!=0){
			let t=array[i],j=i,nx=tb[i];
			do{
				write(array,j,array[nx]);
				write(tb,j,j,true);
				j=nx;
				nx=tb[nx];
			}
			while(compareValues(nx,i)!=0);
			write(array,j,t);
			write(tb,j,j,true);
		}
	}
	return[5,1]
}
function binaryMergeSort(){
	let array=[...arr];
	mergeSortTemp(array,len,true)
	return[5,1]
}
function bufferPartitionMergeSort(){
	let array=[...arr];
	const shiftBW=(a,b,m,c)=>{
		while(m>b)swap(a,--c,--m);
	}
	const msw=(ar,a,b,c)=>{
		for(let i=0;i<c;i++)
			swap(ar,a+i,b+i);
	}
	function rot(ar,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0){
			if(r<l){
				msw(ar,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(ar,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
	}
	function ipm(ar,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b){
			if(compareIndices(ar,i,j)>0){
				k=j;
				while(++k<b&&compareIndices(ar,i,k)>0);
				rot(ar,i,j,k);
				i+=k-j;j=k;
			}else i++;
		}
	}
	function mot(ar,a,b){
		let m=a+(b-1-a)/2|0;
		if(compareIndices(ar,a,m)>0)swap(ar,a,m);
		if(compareIndices(ar,m,b-1)>0){
			swap(ar,m,b-1);
			if(compareIndices(ar,a,m)>0)return;
		}
		swap(ar,a,m);
	}
	function mofm(ar,a,b,s){
		let e=b,st=a,i,j,ad=true;
		while(e-st>1){
			j=st;
			for(i=st;i+2*s<=e;i+=s){
				insSort(ar,i,i+s);
				swap(ar,j++,i+s/2|0);
			}
			if(i<e){
				insSort(ar,i,e);
				swap(ar,j++,i+(e-(ad?1:0)-i)/2|0);
				if((e-i)%2==0)ad=!ad;
			}
			end=j;
		}
	}
	function par(ar,a,b){
		let i=a,j=b;
		while(1){
			do i++;while(i<j&&compareIndices(ar,i,a)>0);
			do j--;while(j>=i&&compareIndices(ar,j,a)<0);
			if(i<j)swap(ar,i,j);
			else return j;
		}
	}
	function qsel(ar,a,b,m){
		let bp=false,mom=false,m1=(m+b+1)/2|0;
		while(1){
			if(bp){
				mofm(ar,a,b,5);
				mom=true;
			}else mot(ar,a,b);
			let p=par(ar,a,b);
			swap(ar,a,p);
			let l=maxVal(1,p-a),r=maxVal(1,b-(p+1));
			bp=!mom&&(l/r>=16||r/l>=16);
			if(p>=m&&p<m1)return p;
			else if(p<m)a=p+1;
			else b=p;
		}
	}
	function merge(ar,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<1)swap(ar,p++,i++);
			else swap(ar,p++,j++);
		}
		while(i<m)swap(ar,p++,i++);
		while(j<b)swap(ar,p++,j++);
	}
	function mergeFW(ar,p,a,m,b){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(ar,i,j)<1)swap(ar,p++,i++);
			else swap(ar,p++,j++);
		}
		return i<m?i:j
	}
	const gml=n=>{
		while(n>=32)n=(n+3)/4;
		return n|0;
	}
	function mrs(ar,a,b,p){
		let l=b-a;
		if(l<2)return;
		let i,ps,j=gml(l);
		for(i=a;i+j<=b;i+=j)binInsSort(ar,i,i+j);
		binInsSort(ar,i,b);
		while(j<l){
			ps=p;
			for(i=a;i+2*j<=b;i+=2*j,ps+=2*j)merge(ar,i,i+j,i+2*j,ps);
			if(i+j<b)merge(ar,i,i+j,b,ps);
			else while(i<b)swap(ar,i++,ps++);
			j*=2;
			ps=a;
			for(i=p;i+2*j<=p+l;i+=2*j,ps+=2*j)merge(ar,i,i+j,i+2*j,ps);
			if(i+j<p+l)merge(ar,i,i+j,p+l,ps);
			else while(i<p+l)swap(ar,i++,ps++);
			j*=2;
		}
	}
	function sort(ar,a,b){
		let minLvl=sqrt(b-a)|0;
		let m=(a+b+1)/2|0;
		mrs(ar,m,b,a);
		while(m-a>minLvl){
			let m1=(a+m+1)/2|0;
			m1=qsel(ar,a,m,m1);
			mrs(ar,m1,m,a);
			let bSize=m1-a,m2=minVal(m1+bSize,b);
			m1=mergeFW(ar,a,m1,m,m2);
			while(m1<m){
				shiftBW(ar,m1,m,m2);
				m1=m2-(m-m1);a=m1-bSize;m=m2;
				if(m==b)break;
				m2=minVal(m2+bSize,b);
				m1=mergeFW(ar,a,m1,m,m2);
			}
			m=m1;a=m1-bSize;
		}
		binInsSort(ar,a,m);
		ipm(ar,a,m,b);
	}
	let insSort=insertSort,binInsSort=binInsertSort
	sort(array,0,len);
	return[5,1]
}
function binaryInsertionSort(){
	let array=[...arr];
	binInsertSort(array,0,len)
	return[5,1]
}
function fifthMergeSort(){
	let array=[...arr];
	class IndexPair{
		constructor(a,b){this.aE=a;this.bE=b;}
	}
	function ipmFW(a,b,s,m,e){
		let l=s,r=m;
		while(l<m&&r<e){
			if(compareIndices(a,l,r)<1)write(a,b++,a[l++]);
			else write(a,b++,a[r++]);
		}
		while(l<m)write(a,b++,a[l++]);
		while(r<e)write(a,b++,a[r++]);
	}
	function ipmBW(a,b,bl,m,e){
		let l=m-1,r=e-1;
		while(b>r&&r>=m){
			if(compareIndices(a,l,r)>0)write(a,b--,a[l--]);
			else write(a,b--,a[r--]);
		}
		if(r==l)while(r>=0)write(a,b--,a[r--]);
		else if(r<m)while(l>=0)write(a,b--,a[l--]);
		return new IndexPair(l+1,r+1);
	}
	function mwbFW(a,b,d,l,le,m,e){
		let r=m;
		while(l<le&&r<e){
			if(compareValues(b[l],a[r])<1)write(a,d++,b[l++]);
			else write(a,d++,a[r++]);
		}
		while(l<le)write(a,d++,b[l++]);
	}
	function merge(a,b,cs,s,m,e,fb){
		let f,t,p;
		if(fb){f=b;t=a;p=s;s-=cs;m-=cs;e-=cs;
		}else{f=a;t=b;p=s-cs;}
		let l=s,r=m;
		while(l<m&&r<e){
			if(compareIndices(f,l,r)<1)write(t,p++,f[l++],!fb);
			else write(t,p++,f[r++],!fb);
		}
		while(l<m)write(t,p++,f[l++],!fb);
		while(r<e)write(t,p++,f[r++],!fb);
	}
	function pp(a,b,s,e){
		let i;
		for(i=s;i+8<e;i+=8)binInsertSort(a,i,i+8);
		if(e-i>1)binInsertSort(a,i,e);
		let ln=e-s,fb=false;
		for(let g=8;g<ln;g*=2,fb=!fb){
			let fm=g*2;
			for(i=s;i+fm<e;i+=fm)merge(a,b,s,i,i+g,i+fm,fb);
			if(i+g<e)merge(a,b,s,i,i+g,e,fb);
			else{
				if(fb)arraycopy(b,i-s,a,i,e-i);
				else arraycopy(a,i,b,i-s,e-i,1);
			}
		}
		if(fb)arraycopy(b,0,a,s,ln);
	}
	let l5th=len/5|0,bl=len-l5th*4,b=new Array(bl),two5th=2*l5th;
	pp(array,b,0,bl);
	for(let i=0,s=bl;i<4;i++)pp(array,b,s,s+=l5th);
	arraycopy(array,0,b,0,bl,true);
	for(let i=0,s=bl;i<2;i++,s+=two5th)ipmFW(array,s-bl,s,s+l5th,s+two5th);
	let fm=ipmBW(array,len-1,bl,two5th,2*two5th);
	if(fm.bE>0)mwbFW(array,array,bl,0,fm.aE,two5th,len);
	mwbFW(array,b,0,0,bl,bl,len);
	return[5,1]
}
function chaliceSort(){
	let array=[...arr];
	const Bms=new BMS();
	const CEILCBRT=n=>{
		let a=0,b=11;
		while(a<b){
			let m=(a+b)/2|0;
			if((1<<3*m)>=n)b=m;
			else a=m+1;
		}
		return 1<<a;
	}
	function CALCKEYS(bL,n){
		let a=1,b=n/4|0;
		while(a<b){
			let m=(a+b)/2|0;
			if((n-4*m-1)/bL-2|0<m)b=m;
			else a=m+1;
		}
		return a;
	}
	function LAZIESTSORTEXT(ar,t,a,b){
		for(let i=a,s=t.length;i<b;i+=s){
			let j=minVal(b,i+s);
			Bms.binaryInsertion(ar,i,j);
			if(i>a)Bms.mergeBWExt(ar,t,a,i,j);
		}
	}
	function FINDKEYSSM(ar,a,b,a1,b1,full,n){
		let p=a,pE=0;
		if(full){
			for(;p<b;p++){
				let loc=Bms.leftBinSearch(ar,a1,b1,ar[p]);
				if(loc==b1||compareIndices(ar,p,loc)!=0){
					pE=p+1;
					break;
				}
			}
			if(pE!=0){
				for(let i=pE;i<b&&pE-p<n;i++){
					let loc=Bms.leftBinSearch(ar,a1,b1,ar[i]);
					if(loc==b1||compareIndices(ar,i,loc)!=0){
						loc=Bms.leftBinSearch(ar,p,pE,ar[i]);
						if(loc==pE||compareIndices(ar,i,loc)!=0){
							Bms.rotate(ar,p,pE,i);
							let len1=i-pE;
							p+=len1;loc+=len1;pE=i+1;
							Bms.insertTo(ar,i,loc);
						}
					}
				}
			}else pE=p;
		}else{
			pE=p+1;
			for(let i=pE;i<b&&pE-p<n;i++){
				let loc=Bms.leftBinSearch(ar,p,pE,ar[i]);
				if(loc==pE||compareIndices(ar,i,loc)!=0){
					Bms.rotate(ar,p,pE,i);
					let len1=i-pE;
					p+=len1;loc+=len1;pE=i+1;
					Bms.insertTo(ar,i,loc);
				}
			}
		}
		return[p,pE];
	}
	function FINDKEYS(ar,tmp,a,b,n,s){
		let t=FINDKEYSSM(ar,a,b,0,0,false,minVal(n,s)),p=t[0],pE=t[1];
		if(s<n&&pE-p==s){
			for(n-=s;;n-=s){
				t=FINDKEYSSM(ar,pE,b,p,pE,true,minVal(s,n));
				let keys=t[1]-t[0];
				if(keys==0)break;
				if(keys<s||n==s){
					Bms.rotate(ar,pE,t[0],t[1]);
					t[0]=pE;pE+=keys;
					Bms.mergeBWExt(ar,tmp,p,t[0],pE);
					break;
				}else{
					Bms.rotate(ar,p,pE,t[0]);
					p+=t[0]-pE;pE=t[1];
					Bms.mergeBWExt(ar,tmp,p,t[0],pE);
				}
			}
		}
		Bms.rotate(ar,a,p,pE);
		return pE-p;
	}
	function FINDBITSSM(ar,a,b,a1,bw,n){
		let p=a,pE,cmp=bw?-1:1;
		while(p<b&&compareIndices(ar,p,a1)!=cmp)p++;
		a1++;
		if(p<b){
			pE=p+1;
			for(let i=pE;i<b&&pE-p<n;i++){
				if(compareIndices(ar,i,a1)==cmp){
					Bms.rotate(ar,p,pE,i);
					p+=i-pE;pE=i+1;a1++;
				}
			}
		}else pE=p;
		return[p,pE];
	}
	function FINDBITS(ar,tmp,a,b,n,s){
		LAZIESTSORTEXT(ar,tmp,a,a+n);
		let a0=a,a1=a+n,c=0,c0=0;
		for(let i=0;c<n&&i<2;i++){
			let p=a1,pE=p;
			while(1){
				let t=FINDBITSSM(ar,pE,b,a0,i==1,minVal(s,n-c)),bits=t[1]-t[0];
				if(bits==0)break;
				a0+=bits;c+=bits;
				if(bits<s||c==n){
					Bms.rotate(ar,pE,t[0],t[1]);
					t[0]=pE;pE+=bits;
					break;
				}else{
					Bms.rotate(ar,p,pE,t[0]);
					p+=t[0]-pE;pE=t[1];
				}
			}
			Bms.rotate(ar,a1,p,pE);
			a1+=pE-p;
			if(i==0)c0=c;
		}
		if(c<n)return-1;
		else{
			Bms.multiSwap(ar,a+c0,a+n+c0,n-c0);
			return c0;
		}
	}
	function BITREVERSAL(ar,a,b){
		let len=b-a,m=0;
		let d1=len>>1,d2=d1+(d1>>1);
		for(let i=1;i<len-1;i++){
			let j=d1;
			for(let k=i,n=d2;(k&1)==0;j-=n,k>>=1,n>>=1);
			m+=j;
			if(m>i)swap(ar,a+i,a+m);
		}
	}
	function UNSHUFFLE(ar,a,b){
		let len=(b-a)>>1,c=0;
		for(let n=2;len>0;len>>=1,n*=2){
			if((len&1)==1){
				let a1=a+c;
				BITREVERSAL(ar,a1,a1+n);
				BITREVERSAL(ar,a1,a1+n/2|0);
				BITREVERSAL(ar,a1+n/2|0,a1+n);
				Bms.rotate(ar,a+c/2|0,a1,a1+n/2|0);
				c+=n;
			}
		}
	}
	function REDISTBUFFER(ar,tmp,a,m,b){
		let s=tmp.length;
		while(m-a>s&&m<b){
			let i=Bms.leftBinSearch(ar,m,b,ar[a+s]);
			Bms.rotate(ar,a+s,m,i);
			let t=i-m;m=i;
			Bms.mergeFWExt(ar,tmp,a,a+s,m);
			a+=t+s;
		}
		if(m<b)Bms.mergeFWExt(ar,tmp,a,m,b);
	}
	function DUALMERGEBW(ar,a,m,b,p){
		let i=m-1;b--;
		while(p>b+1&&b>=m){
			if(compareIndices(ar,b,i)>=0)swap(ar,--p,b--);
			else swap(ar,--p,i--);
		}
		if(b<m)Bms.shiftBW(ar,a,i+1,p);
		else{
			i++;b++;p=m-(i-a);
			while(a<i&&m<b){
				if(compareIndices(ar,a,m)<1)swap(ar,p++,a++);
				else swap(ar,p++,m++);
			}
			while(a<i)swap(ar,p++,a++);
		}
	}
	function DUALMERGEBWExt(ar,a,m,b,p){
		let i=m-1;b--;
		while(p>b+1&&b>=m){
			if(compareIndices(ar,b,i)>=0)write(ar,--p,ar[b--]);
			else write(ar,--p,ar[i--]);
		}
		if(b<m)Bms.shiftBWExt(ar,a,i+1,p);
		else{
			i++;b++;p=m-(i-a);
			while(a<i&&m<b){
				if(compareIndices(ar,a,m)<1)write(ar,p++,ar[a++]);
				else write(ar,p++,ar[m++]);
			}
			while(a<i)write(ar,p++,ar[a++]);
		}
	}
	function SMARTMERGE(ar,p,a,m,rev){
		let i=m,cmp=rev?0:1;
		while(a<m){
			if(compareIndices(ar,a,i)<cmp)write(ar,p++,ar[a++]);
			else write(ar,p++,ar[i++]);
		}		
		return i;
	}
	function SMARTTAILMERGE(ar,tmp,p,a,m,b){
		let i=m,bL=tmp.length;
		while(a<m&&i<b){
			if(compareIndices(ar,a,i)<1)write(ar,p++,ar[a++]);
			else write(ar,p++,ar[i++]);
		}
		if(a<m){
			if(a>p)Bms.shiftFWExt(ar,p,a,m);
			arraycopy(tmp,0,ar,b-bL,bL);
		}else{
			a=0;
			while(a<bL&&i<b){
				if(compareValues(tmp[a],ar[i])<1)write(ar,p++,tmp[a++]);
				else write(ar,p++,ar[i++]);
			}
			while(a<bL)write(ar,p++,tmp[a++]);
		}
	}
	function BLOCKCYCLE(ar,a,t,tIdx,tLen,bL){
		for(let i=0;i<tLen-1;i++){
			if(compareIndices(ar,t+i,tIdx+i)>0||(i>0&&compareIndices(ar,t+i,tIdx+i-1)<0)){
				arraycopy(ar,a+i*bL,ar,a-bL,bL);
				let val=i,next=Bms.leftBinSearch(ar,tIdx,tIdx+tLen,ar[t+i])-tIdx;
				do{
					arraycopy(ar,a+next*bL,ar,a+val*bL,bL);
					swap(ar,t+i,t+next);
					val=next;
					next=Bms.leftBinSearch(ar,tIdx,tIdx+tLen,ar[t+i])-tIdx;
				}while(next!=i);
				arraycopy(ar,a-bL,ar,a+val*bL,bL);
			}
		}
	}
	function BLOCKMERGE(ar,tmp,a,m,b,tl,tLen,t,tIdx,bp1,bp2,bL){
		if(b-m<=bL)return Bms.mergeBWExt(ar,tmp,a,m,b);
		Bms.insertTo(ar,t+tl-1,t);
		let i=a+bL-1,j=m+bL-1,ti=t,tj=t+tl,tp=tIdx;
		while(ti<t+tl&&tj<t+tLen){
			if(compareIndices(ar,i,j)<1){
				swap(ar,tp++,ti++);
				i+=bL;
			}else{
				swap(ar,tp++,tj++);
				swap(ar,bp1,bp2);
				j+=bL;
			}
			bp1++;bp2++;
		}
		while(ti<t+tl){
			swap(ar,tp++,ti++);
			bp1++;bp2++;
		}
		while(tj<t+tLen){
			swap(ar,tp++,tj++);
			swap(ar,bp1++,bp2++);
		}
		t^=tIdx;tIdx^=t;t^=tIdx;
		heapSort(ar,tIdx,tIdx+tLen,true);
		arraycopy(ar,m-bL,tmp,0,bL,true);
		arraycopy(ar,a,ar,m-bL,bL);
		BLOCKCYCLE(ar,a+bL,t,tIdx,tLen,bL);
		Bms.multiSwap(ar,t,tIdx,tLen);
		bp1-=tLen;bp2-=tLen;
		let f=a+bL,a1=f,bp3=bp2+tLen,rev=compareIndices(ar,bp1,bp2)>0;
		while(true){
			do{
				if(rev)swap(ar,bp1,bp2);
				bp1++;bp2++;a1+=bL;
			}while(bp2<bp3&&compareIndices(ar,bp1,bp2)==(rev?1:-1));
			if(bp2==bp3){
				SMARTTAILMERGE(ar,tmp,f-bL,f,rev?f:a1,b);
				return;
			}
			f=SMARTMERGE(ar,f-bL,f,a1,rev);
			rev=!rev;
		}
	}
	function BLOCKCYCLEEasy(ar,a,t,tIdx,tLen,bL){
		for(let i=0;i<tLen-1;i++){
			if(compareIndices(ar,t+i,tIdx+i)>0||(i>0&&compareIndices(ar,t+i,tIdx+i-1)<0)){
				let next=Bms.leftBinSearch(ar,tIdx,tIdx+tLen,ar[t+i])-tIdx;
				do{
					Bms.multiSwap(ar,a+i*bL,a+next*bL,bL);
					swap(ar,t+i,t+next);
					next=Bms.leftBinSearch(ar,tIdx,tIdx+tLen,ar[t+i])-tIdx;
				}while(next!=i);
			}
		}
	}
	function INPLACEMERGEBW(ar,a,m,b,rev){
		let f=rev?Bms.rightBinSearch(ar,m,b,ar[m-1]):Bms.leftBinSearch(ar,m,b,ar[m-1]);
		b=f;
		while(b>m&&m>a){
			let i=rev?Bms.leftBinSearch(ar,a,m,ar[b-1]):Bms.rightBinSearch(ar,a,m,ar[b-1]);
			Bms.rotate(ar,i,m,b);
			let t=m-i;
			m=i;b-=t+1;
			if(m==a)break;
			b=rev?Bms.rightBinSearch(ar,m,b,ar[m-1]):Bms.leftBinSearch(ar,m,b,ar[m-1]);
		}
		return f;
	}
	function BLOCKMERGEEasy(ar,a,m,b,lenA,lenB,tl,tLen,t,tIdx,bp1,bp2,bL){
		if(b-m<=bL)return INPLACEMERGEBW(ar,a,m,b,false);
		let a1=a+lenA,b1=b-lenB,i=a1+bL-1,j=m+bL-1,ti=tIdx,tj=tIdx+tl,tp=t;
		while(ti<tIdx+tl&&tj<tIdx+tLen){
			if(compareIndices(ar,i,j)<1){
				swap(ar,ti++,tp++);
				i+=bL;
			}else{
				swap(ar,tj++,tp++);
				swap(ar,bp1,bp2);
				j+=bL;
			}
			bp1++;bp2++;
		}
		while(ti<tIdx+tl){
			swap(ar,ti++,tp++);
			bp1++;bp2++;
		}
		while(tj<tIdx+tLen){
			swap(ar,tj++,tp++);
			swap(ar,bp1++,bp2++);
		}
		t^=tIdx;tIdx^=t;t^=tIdx;
		heapSort(ar,tIdx,tIdx+tLen,true);
		BLOCKCYCLEEasy(ar,a1,t,tIdx,tLen,bL);
		Bms.multiSwap(ar,t,tIdx,tLen);
		bp1-=tLen;bp2-=tLen;
		let f=a1,a2=f,bp3=bp2+tLen,rev=compareIndices(ar,bp1,bp2)>0;
		while(true){
			do{
				if(rev)swap(ar,bp1,bp2);
				bp1++;bp2++;
				a2+=bL;
			}while(bp2<bp3&&compareIndices(ar,bp1,bp2)==(rev?1:-1));
			if(bp2==bp3){
				if(!rev)INPLACEMERGEBW(ar,a1,b1,b,false);
				Bms.inPlaceMerge(ar,a,a1,b);
				return;
			}
			f=INPLACEMERGEBW(ar,f,a2,a2+bL,rev);
			rev=!rev;
		}
	}
	function run(ar,len){
		let a=0,b=len,n=b-a;
		if(n<128){
			if(n<32)Bms.binaryInsertion(ar,a,b);
			else fifthMergeSort()
			return;
		}
		let cbrt=2*CEILCBRT(n/4|0),bL=2*cbrt,kLen=CALCKEYS(bL,n);
		let tmp=new Array(bL),keys=FINDKEYS(ar,tmp,a,b,2*kLen,cbrt);
		if(keys<8){
			for(let j=1;j<n;j*=2)for(let i=a+j;i<b;i+=2*j)INPLACEMERGEBW(ar,i-j,i,minVal(i+j,b),false);return;
		}else if(keys<2*kLen){keys-=keys%4;kLen=keys/2|0;}
		let a1=a+keys,a2=a1+keys,bSep=FINDBITS(ar,tmp,a1,b,kLen,cbrt);
		if(bSep==-1){
			LAZIESTSORTEXT(ar,tmp,a,a2);
			Bms.inPlaceMerge(ar,a,a2,b);
			return;
		}
		let a3=a2+bL,i,j=1;n=b-a3;
		Bms.binaryInsertion(ar,a2,a3);
		arraycopy(ar,a2,tmp,0,bL,true);
		for(;j<cbrt;j*=2){
			let p=maxVal(2,j);
			for(i=a3;i+2*j<b;i+=2*j)Bms.mergeWithBufFWExt(ar,i,i+j,i+2*j,i-p);
			if(i+j<b)Bms.mergeWithBufFWExt(ar,i,i+j,b,i-p);
			else Bms.shiftFWExt(ar,i-p,i,b);
			a3-=p;b-=p;
		}
		i=b-n%(2*j);
		if(i+j<b)Bms.mergeWithBufBWExt(ar,i,i+j,b,b+j);
		else Bms.shiftBWExt(ar,i,b,b+j);
		for(i-=2*j;i>=a3;i-=2*j)Bms.mergeWithBufBWExt(ar,i,i+j,i+2*j,i+3*j);
		a3+=j;b+=j;j*=2;
		for(i=a3;i+2*j<b;i+=2*j)Bms.mergeWithBufFWExt(ar,i,i+j,i+2*j,i-j);
		if(i+j<b)Bms.mergeWithBufFWExt(ar,i,i+j,b,i-j);
		else Bms.shiftFWExt(ar,i-j,i,b);
		a3-=j;b-=j;j*=2;i=b-n%(2*j);
		if(i+j<b)DUALMERGEBWExt(ar,i,i+j,b,b+j/2|0);
		else Bms.shiftBWExt(ar,i,b,b+j/2|0);
		for(i-=2*j;i>=a3;i-=2*j)DUALMERGEBWExt(ar,i,i+j,i+2*j,i+2*j+j/2|0);
		a3+=j/2|0;b+=j/2|0;j*=2;
		if(keys>=j){
			Bms.rotate(ar,a,a1,a3);
			a2=a1+bL;
			if(kLen>=j){
				for(let mLvl=2*j;j<kLen;j*=2){
					let p=maxVal(mLvl,j);
					for(i=a3;i+2*j<b;i+=2*j)Bms.mergeWithBufFW(ar,i,i+j,i+2*j,i-p);
					if(i+j<b)Bms.mergeWithBufFW(ar,i,i+j,b,i-p);
					else Bms.shiftFW(ar,i-p,i,b);
					a3-=p;b-=p;
				}
				i=b-n%(2*j);
				if(i+j<b)Bms.mergeWithBufBW(ar,i,i+j,b,b+j);
				else Bms.shiftBW(ar,i,b,b+j);
				for(i-=2*j;i>=a3;i-=2*j)Bms.mergeWithBufBW(ar,i,i+j,i+2*j,i+3*j);
				a3+=j;b+=j;j*=2;
			}
			if(keys>=j){
				for(i=a3;i+2*j<b;i+=2*j)Bms.mergeWithBufFW(ar,i,i+j,i+2*j,i-j);
				if(i+j<b)Bms.mergeWithBufFW(ar,i,i+j,b,i-j);
				else Bms.shiftFW(ar,i-j,i,b);
				a3-=j;b-=j;j*=2;i=b-n%(2*j);
				if(i+j<b)DUALMERGEBW(ar,i,i+j,b,b+j/2|0);
				else Bms.shiftBW(ar,i,b,b+j/2|0);
				for(i-=2*j;i>=a3;i-=2*j)DUALMERGEBW(ar,i,i+j,i+2*j,i+2*j+j/2|0);
				a3+=j/2|0;b+=j/2|0;j*=2;
			}
			Bms.rotate(ar,a,a2,a3);
			a2=a1+keys;
			heapSort(ar,a,a1,true);
		}
		arraycopy(tmp,0,ar,a2,bL);
		UNSHUFFLE(ar,a,a1);
		let limit=bL*(kLen+2);
		for(let k=j/bL-1|0;j<n&&minVal(2*j,n)<=limit;j*=2,k=2*k+1){
			for(i=a3;i+2*j<=b;i+=2*j)BLOCKMERGE(ar,tmp,i,i+j,i+2*j,k,2*k,a,a+kLen,a1,a1+kLen,bL);
			if(i+j<b)BLOCKMERGE(ar,tmp,i,i+j,b,k,(b-i-1)/bL-1|0,a,a+kLen,a1,a1+kLen,bL);
		}
		for(;j<n;j*=2){
			bL=(2*j)/kLen|0;
			let lenA=j%bL,lenB=lenA;
			for(i=a3;i+2*j<=b;i+=2*j)BLOCKMERGEEasy(ar,i,i+j,i+2*j,lenA,lenB,kLen/2|0,kLen,a,a+kLen,a1,a1+kLen,bL);
			if(i+j<b)BLOCKMERGEEasy(ar,i,i+j,b,lenA,(b-i-j)%bL,kLen/2|0,kLen/2+(b-i-j)/bL|0,a,a+kLen,a1,a1+kLen,bL);
		}
		Bms.multiSwap(ar,a1+bSep,a1+kLen+bSep,kLen-bSep);
		LAZIESTSORTEXT(ar,tmp,a,a3);
		REDISTBUFFER(ar,tmp,a,a3,b);
	}
	run(array,len)
	return[5,1]
}
function blockSelectionSort(){
	let array=[...arr];
	const sqr=n=>{
		let i=1;
		for(;i*i<n;i*=2);
		return i;
	}
	function msw(c,a,b,l){
		for(let i=0;i<l;i++)
			swap(c,a+i,b+i);
	}
	function rot(c,a,m,b){
		let l=m-a,r=b-m;
		while(l>0&&r>0)
			if(r<l){
				msw(c,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				msw(c,a,m,l);
				a+=l;m+=l;r-=l;
			}
	}
	function imp(c,a,m,b){
		let i=a,j=m,k;
		while(i<j&&j<b)
			if(compareIndices(c,i,j)>0){
				k=j;
				do k++;while(k<b&&compareIndices(c,i,k)>0);
				rot(c,i,j,k);
				i+=k-j;j=k;
			}else i++;
		return i;
	}
	function ipmBW(c,a,m,b){
		let i=m-1,j=b-1,k;
		while(j>i&&i>=a)
			if(compareIndices(c,i,j)>0){
				k=i;
				do k--;while(k>=a&&compareIndices(c,k,j)>0);
				rot(c,k+1,i+1,j+1);
				j-=i-k;i=k;
			}else j--;
	}
	function ser(c,a,b,l){
		let m=a;
		a+=l;
		while(a<b){
			let o=compareIndices(c,a,m);
			if(o<0||(o==0&&compareIndices(c,a+l-1,m+l-1)<0))m=a;
			a+=l;
		}
		return m;
	}
	function seb(c,a,m,b,l){
		let k=a,j=m;
		while(k<m&&compareIndices(c,k,m)<1)k+=l;
		if(k==m)return;
		let i=m;
		msw(array,k,j,l);
		k+=l;j+=l;
		while(k<j&&j<b)
			if(compareIndices(c,i,j)<1){
				if(k!=i)msw(c,k,i,l);
				k+=l;i=ser(c,maxVal(m,k),j,l);
			}else{
				if(i==k)i=j;
				if(k!=j)msw(c,k,j,l);
				k+=l;j+=l;
			}
		while(k<j){
			i=ser(c,k,b,l);
			if(k!=i)msw(c,k,i,l);
			k+=l;
		}
	}
	for(let i,j=1;j<len;j*=2){
		let l=sqr(j),n=j,b=len-len%l;
		while(n>16){
			for(i=0;i+j<b;i+=2*j)
				for(let k=i;k+n<minVal(i+2*j,b);k+=n)
					seb(array,k,k+n,minVal(k+2*n,b),l);
			n=l;l=sqr(l);
		}
		for(i=0;i+j<b;i+=2*j)
			for(let k=i,f=i;k+n<minVal(i+2*j,b);k+=n)
				f=imp(array,f,k+n,minVal(k+2*n,b));
		ipmBW(array,len-len%(2*j),b,len);
	}
	return[5,1]
}
function iterativeIntroCircleSort(){
	let array=[...arr];
	let t=0,n=1,i=0;
	for(;n<len;n*=2,t+=.5);
	do{
		if(++i<t|0)continue;
		binInsertSort(array,0,len);
		break;
	}while(icsr(array,n));
	return[5,1]
}
function recursiveIntroCircleSort(){
	let array=[...arr];
	let t=0,n=1,i=0;
	for(;n<len;n*=2,t+=.5);
	do{
		if(++i<t|0)continue;
		binInsertSort(array,0,len);
		break;
	}while(rcsr(array,0,n-1,0));
	return[5,1]
}
function medianMergeSort(){
	let array=[...arr];
	function mot(c,a,b){
		let m=a+(b-1-a)/2|0;
		if(compareIndices(c,a,m)>0)swap(c,a,m);
		if(compareIndices(c,m,b-1)>0){
			swap(c,m,b-1);
			if(compareIndices(c,a,m)>0)return;
		}
		swap(c,a,m);
	}
	function mom(c,a,b,s){
		let e=b,t=a,i,j,d=true;
		while(e-t>1){
			j=t;
			for(i=t;i+2*s<=e;i+=s){
				insSort(c,i,i+s);
				swap(c,j++,i+s/2|0);
			}
			if(i<e){
				insSort(c,i,e);
				swap(c,j++,i+(e-(d?1:0)-i)/2|0);
				if((e-i)%2==0)d=!d;
			}
			e=j;
		}
	}
	function par(c,a,b,p){
		let i=a-1,j=b;
		while(1){
			do i++;while(i<j&&compareIndices(c,i,p)<0);
			do j--;while(j>=i&&compareIndices(c,j,p)>0);
			if(i<j)swap(c,i,j);
			else return j;
		}
	}
	function mer(c,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(c,i,j)<1)swap(c,p++,i++);
			else swap(c,p++,j++);
		}
		while(i<m)swap(c,p++,i++);
		while(j<b)swap(c,p++,j++);
	}
	const gml=n=>{
		while(n>31)n=(n+3)/4|0;
		return n;
	}
	function mrs(c,a,b,p){
		let l=b-a;
		if(l<2)return;
		let i,o,j=gml(l);
		for(i=a;i+j<=b;i+=j)binInsSort(c,i,i+j);
		binInsSort(c,i,b);
		while(j<l){
			o=p;
			for(i=a;i+2*j<=b;i+=2*j,o+=2*j)mer(c,i,i+j,i+2*j,o);
			if(i+j<b)mer(c,i,i+j,b,o);
			else while(i<b)swap(c,i++,o++);
			j*=2;o=a;
			for(i=p;i+2*j<=p+l;i+=2*j,o+=2*j)mer(c,i,i+j,i+2*j,o);
			if(i+j<p+l)mer(c,i,i+j,p+l,o);
			else while(i<p+l)swap(c,i++,o++);
			j*=2;
		}
	}
	function mms(c,a,b){
		let s=a,e=b,d=false,mom=false;
		while(e-s>16){
			if(d){
				mom(c,s,e,5);
				mom=true;
			}else mot(c,s,e);
			let p=par(c,s+1,e,s);
			swap(c,s,p);
			let l=p-s,r=e-(p+1);
			d=!mom&&((l==0||r==0)||(l/r>=16||r/l>=16));
			if(l<=r){
				mrs(c,s,p,p+1);
				s=p+1;
			}else{
				mrs(c,p+1,e,2*p+1-e);
				e=p;
			}
		}
		binInsSort(c,s,e);
	}
	let insSort=insertSort,binInsSort=binInsertSort;
	mms(array,0,len);
	return[5,1]
}
function mergeInsertionSort(){
	let array=[...arr];
	function bsw(a,b,c,s){
		while(s-->0)swap(a,b--,c--);
	}
	function bin(a,b,c,s){
		while(b-s>=c){
			bsw(a,b-s,b,s);
			b-=s;
		}
	}
	function brv(a,b,c,s){
		c-=s;
		while(c>b){
			bsw(a,b,c,s);
			b+=s;c-=s;
		}
	}
	function bsr(a,b,c,s,v){
		while(b<c){
			let m=b+(((c-b)/s|0)/2|0)*s;
			if(compareValues(v,a[m])<0)c=m;
			else b=m+s;
		}
		return b;
	}
	function ord(a,b,c,s){
		for(let i=b,j=i+s;j<c;i+=s,j+=2*s)bin(a,j,i,s);
		brv(a,b+(((c-b)/s|0)/2|0)*s,c,s);
	}
	let k=1;
	for(;2*k<=len;k*=2)for(let i=2*k-1;i<len;i+=2*k)if(compareIndices(array,i-k,i)>0)bsw(array,i-k,i,k,1);
	for(;k>0;k/=2,k|=0){
		let a=k-1,i=a+2*k,g=2,p=4;
		while(i+2*k*g-k<=len){
			ord(array,i,i+2*k*g-k,k);
			let b=a+k*(p-1);i+=k*g-k;
			for(let j=i;j<i+k*g;j+=k)bin(array,j,bsr(array,a,b,k,array[j]),k);
			i+=k*g+k;g=p-g;p*=2;
		}
		for(;i<len;i+=2*k)bin(array,i,bsr(array,a,i,k,array[i]),k);
	}
	return[5,1]
}
function hyrbidCombSort(){
	let array=[...arr];
	combSortTemp(array,len,1.3,true);
	return[5,1]
}
function fluxSort(){
	let array=[...arr];
	const Fo=24,qds=new QdS();
	function fA(a,n){
		let cnt=n,b=0,pta=0;
		while(--cnt>0)if(compareIndices(a,pta,++pta)>0)b++;
		if(b==0)return false;
		if(b==n-1)return !!reversal(a,0,n-1,0);
		if(b<=(n/6|0)||b>=(n/6|0)*5){
			qds.quadSort(a,0,n);
			return false;
		}
		return true;
	}
	function mo5(a,v0,v1,v2,v3,v4){
		let t=new Array(4),v;
		v=(compareIndices(a,v0,v1)+1)/2|0;t[0]=v;t[1]=v^1;
		v=(compareIndices(a,v0,v2)+1)/2|0;t[0]+=v;t[2]=v^1;
		v=(compareIndices(a,v0,v3)+1)/2|0;t[0]+=v;t[3]=v^1;
		v=(compareIndices(a,v0,v4)+1)/2|0;t[0]+=v;
		if(t[0]==2)return v0;
		v=(compareIndices(a,v1,v2)+1)/2|0;t[1]+=v;t[2]+=v^1;
		v=(compareIndices(a,v1,v3)+1)/2|0;t[1]+=v;t[3]+=v^1;
		v=(compareIndices(a,v1,v4)+1)/2|0;t[1]+=v;
		if(t[1]==2)return v1;
		v=(compareIndices(a,v2,v3)+1)/2|0;t[2]+=v;t[3]+=v^1;
		v=(compareIndices(a,v2,v4)+1)/2|0;t[2]+=v;
		if(t[2]==2)return v2;
		v=(compareIndices(a,v3,v4)+1)/2|0;t[3]+=v;
		return t[3]==2?v3:v4;
	}
	function mo3(a,v0,v1,v2){
		let t=new Array(2),v;
		v=(compareIndices(a,v0,v1)+1)/2|0;t[0]=v;t[1]=v^1;
		v=(compareIndices(a,v0,v2)+1)/2|0;t[0]+=v;
		if(t[0]==1)return v0;
		v=(compareIndices(a,v1,v2)+1)/2|0;t[1]+=v;
		return t[1]==1?v1:v2;
	}
	function mo15(a,ptx,n){
		let v0,v1,v2,v3,v4,div=n/16|0;
		v0=mo3(a,ptx+div*2,ptx+div*1,ptx+div*3);
		v1=mo3(a,ptx+div*5,ptx+div*4,ptx+div*6);
		v2=mo3(a,ptx+div*8,ptx+div*7,ptx+div*9);
		v3=mo3(a,ptx+div*11,ptx+div*10,ptx+div*12);
		v4=mo3(a,ptx+div*14,ptx+div*13,ptx+div*15);
		return mo5(a,v2,v0,v1,v3,v4);
	}
	function mo9(a,ptx,n){
		let v0,v1,v2,div=n/16|0;
		v0=mo3(a,ptx+div*2,ptx+div*1,ptx+div*4);
		v1=mo3(a,ptx+div*8,ptx+div*6,ptx+div*10);
		v2=mo3(a,ptx+div*14,ptx+div*12,ptx+div*15);
		return mo3(a,v0,v1,v2);
	}
	function fP(a,sw,m,s,n){
		let v,aSz,sSz,pta,pts,ptx,pte,piv;
		ptx=m.every((e,i)=>e==a[i])?s:0;piv=m[n>1024?mo15(m,ptx,n):mo9(m,ptx,n)];pte=ptx+n;pta=s;pts=0;
		while(ptx<pte){
			v=(compareValues(m[ptx],piv)+1)/2|0;
			write(a,pta,m[ptx]);pta+=v^1;
			write(sw,pts,m[ptx++],true);pts+=v;
		}
		sSz=pts;aSz=n-sSz;
		if(aSz<=(sSz/16|0)||sSz<=Fo){
			arraycopy(sw,0,a,pta,sSz);
			qds.quadSortSwap(a,sw,pta,sSz);
		}else fP(a,sw,sw,pta,sSz);
		if(sSz<=(aSz/16|0)||aSz<=Fo)qds.quadSortSwap(a,sw,s,aSz);
		else fP(a,sw,a,s,aSz);
	}
	function fs(a,n){
		if(n<32)qds.quadSort(a,0,n);
		else if(fA(a,n))fP(a,new Array(n),a,0,n);
	}
	fs(array,len);
	insertSort(array,0,len)
	return[5,1]
}
function quadSort(){
	let array=[...arr];
	new QdS().quadSort(array,0,len)
	return[5,1]
}
function weaveMergeSort(){
	let array=[...arr];
	function win(a,s,e){
		for(let j=s;j<e;j++){
			let p=j
			while(p>s&&compareIndices(a,p,p-1)<1)swap(a,p,--p);
		}
	}	
	function wem(a,n,x,m){
		let i=1,t=m-n;
		while(i<=t)multiSwap(a,m+i,n+(i++*2)-1);
		win(a,n,x+1);
	}
	function wms(a,n,x){
		if(x-n==0)0;
		else if(x-n==1){
			if(compareIndices(a,n,x)>0)swap(a,n,x);
		}else{
			let m=(n+x)/2|0
			wms(a,n,m);
			wms(a,m+1,x);
			wem(a,n,x,m);
		}
	}
	wms(array,0,len-1);
	return[5,1]
}
function testSort(){
	let array=[...arr];
	class SqSt{
		constructor(l,f){
			this.l=l;this.f=f;
		}
		getLoL(){return l}
		getLoF(){return f}
	}
	function msw(ar,a,b,l,x){
		while(l--!=0)swap(ar,a++,b++,x);
	}
	function sqmr(ar,p,lL,rL,d,x){
		let mP=lL+rL+d-1;
		let r=lL+rL-1;
		let l=lL-1;
		while(l>=0)
			if(r<lL||compareIndices(ar,p+l,p+r)>0)write(ar,p+(mP--),ar[p+(l--)],x);
			else write(ar,p+(mP--),ar[p+(r--)],x);
		if(r!=mP){
			while(r>=lL)write(ar,p+(mp--),ar[p+(r--)],x);
		}
	}
	function sqmlwb(ar,p,lE,rE,d,x){
		let l=0;
		let r=lE;
		rE+=lE;
		while(r<rE)
			if(l==lE||compareIndices(ar,p+l,p+r)>0)write(ar,p+d++,ar[p+r++],x);
			else write(ar,p+d++,ar[p+l++],x)
		if(d!=l){
			while(l<lE)write(ar,p+d++,ar[p+l++],x);
		}
	}
	function sqmd(ar,aP,buf,bP,lL,rL,x){
		let aM=0,bM=0;
		let d=-rL;
		while(bM<rL)
			if(aM==lL||compareValues(ar[aP+aM],buf[bP+bM])>=0)write(ar,aP+d++,buf[bP+bM++],x);
			else write(ar,aP+d++,ar[aP+aM++],x);
		if(d!=aM){
			while(aM<lL)write(ar,aP+d++,ar[aP+aM++],x);
		}
	}
	function sqsmwb(ar,p,lol,lof,bL,x) {
		let d=-bL,l=0,r=lol,lE=r,rE=r+bL;
		let tF=1-lof;
		while(l<lE&&r<rE)
			if(compareValues(ar,p+l,p+r)-tF<0)write(ar,p+d++,ar[p+l++],x);
			else write(ar,p+d++,ar[p+right++],x);
		let ln,fr=lof;
		if(l<lE){
			ln=lE-l;
			while(l<lE)write(ar,p+--rE,ar[p+--lE],x);
		}else{
			ln=rE-r;
			fr=tF;
		}
		return new SqSt(ln,fr);
	}
	function smbflwb(keys,mK,ar,p,bC,rBL,aBC,lL,x){
		if(bC==0)return sqmlwb(ar,p,aBC*rBL,lL,-rBL,x);
		let lol=rBL;
		let lof=compareValues(keys[0],mK)<0?0:1;
		let pI=rBL,rTP;
		for(let kI=1;kI<bC;kI++,pI+=rBL){
			rTP=pI-lol;
			let nF=compareValues(keys[kI],mK)<0?0:1;
			if(nF==lof){
				arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,x);
				rTP=pI;lol=rBL;
			}else{
				let rs=sqsmwb(ar,p+rTP,lol,lof,rBL,x);
				lol=rs.getLoL();
				lof=rs.getLoF();
			}
		}
		rTP=pI-lol;
		if(lL!=0){
			if(lof!=0){
				arraycopy(ar,p rTP,ar,p+rTP-rBL,lol,x);
				rTP=pI;lol=rBL*aBC;lof=0;
			}else lol+=rBL*aBC;
			sqmlwb(ar,p+rTP,lol,lL,-rBL,x);
		}else arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,x);
	}
	function sBBls(ar,p,ln,bL,x){
		let eD,pt;
		for(let d=1;d<ln;d+=2){
			eD=0;
			if(compareIndices(ar,p+(d-1),p+d)>0)eD=1;
			write(ar,p+d-3,ar[p+d-1+eD],x);
			write(ar,p+d-2,ar[p+d-eD],x);
		}
		if(ln % 2 != 0) Writes.write(ar,p + ln - 3,ar[p + ln - 1],1,true,x);

		p -= 2;

		for(pt = 2; pt < bL; pt *= 2) {
			int left = 0;
			int right = ln - 2 * pt;

			while(left <= right) {
				this.sqmlwb(ar,p + left,pt,pt,0 - pt,x);
				left += 2 * pt;
			}

			int rest = ln - left;

			if(rest > pt) {
				this.sqmlwb(ar,p + left,pt,rest - pt,0 - pt,x);
			}
			else {
				while(left < ln) Writes.write(ar,p + left - pt,ar[p + left++],1,true,x);
			}

			p -= pt;
		}
		int restToBuild = ln % (2 * bL);
		int leftOverPos = ln - restToBuild;

		if(restToBuild <= bL) {
			Writes.arraycopy(ar,p + leftOverPos,ar,p + leftOverPos + bL,restToBuild,1,true,x);
		}
		else this.sqmr(ar,p + leftOverPos,bL,restToBuild - bL,bL,x);

		while(leftOverPos > 0) {
			leftOverPos -= 2 * bL;
			this.sqmr(ar,p + leftOverPos,bL,bL,bL,x);
		}
	}

	// keys are on the left of arr. Blocks of length bL2 combined. We'll combine them in pairs
	// bL2 and numKeys are powers of 2. (2 * bL2 / rBL) keys are guaranteed
	private void sqrtCombineBlocks(int[] ar,int p,int len,int bL,int rBL,int[] tags,boolean x) {
		int combineLen = len / (2 * bL);
		int leftOver = len % (2 * bL);

		if(leftOver <= bL) {
			len -= leftOver;
			leftOver = 0;
		}

		int leftIndex = 0;

		for(int i = 0; i <= combineLen; i++) {
			if(i == combineLen && leftOver == 0) break;

			int blockPos = p + i * 2 * bL;
			int bC = (i == combineLen ? leftOver : 2 * bL) / rBL;

			int tagIndex = bC + (i == combineLen ? 1 : 0);
			for(int j = 0; j <= tagIndex; j++) Writes.write(tags,j,j,1,true,true);

			int mK = bL / rBL;

			for(tagIndex = 1; tagIndex < bC; tagIndex++) {
				leftIndex = tagIndex - 1;

				for(int rightIndex = tagIndex; rightIndex < bC; rightIndex++) {
					int rightComp = Reads.compareValues(ar[blockPos + leftIndex * rBL],
											ar[blockPos + rightIndex * rBL]);
					if(rightComp > 0 || (rightComp == 0 && tags[leftIndex] > tags[rightIndex])) leftIndex = rightIndex;
				}

				if(leftIndex != tagIndex - 1) {
					this.msw(ar,blockPos + (tagIndex - 1) * rBL,blockPos + leftIndex * rBL,rBL,x);
					this.swap(tags,tagIndex - 1,leftIndex,true);
				}
			}
			int aBC = 0;
			int lL = 0;

			if(i == combineLen) lL = leftOver % rBL;

			if(lL != 0) {
				while(aBC < bC && Reads.compareValues(ar[blockPos + bC * rBL],
						ar[blockPos + (bC - aBC - 1) * rBL]) < 0) {
					aBC++;
				}
			}
			this.smbflwb(tags,mK,ar,blockPos,bC - aBC,rBL,aBC,lL,x);
		}
		for(leftIndex = len - 1; leftIndex >= 0; leftIndex--) Writes.write(ar,p + leftIndex,ar[p + leftIndex - rBL],1,true,x);
	}

	private void sqrtCommonSort(int[] ar,int p,int len,int[] extBuf,int extBufPos,int[] tags,boolean x) {
		insertSorter = new InsertionSort(this.arrayVisualizer);

		if(len <= 16) {
			this.insertSort(ar,p,len,x);
			Highlights.clearAllMarks();
			return;
		}

		int bL = 1;
		while((bL * bL) < len) bL *= 2;

		Writes.arraycopy(ar,p,extBuf,extBufPos,bL,1,true,x);

		this.sqrtCommonSort(extBuf,extBufPos,bL,ar,p,tags,!x);

		this.sBBls(ar,p + bL,len - bL,bL,x);

		int bL2 = bL;

		while(len > (bL2 *= 2)) {
			this.sqrtCombineBlocks(ar,p + bL,len - bL,bL2,bL,tags,x);
		}
		this.sqmd(ar,p + bL,extBuf,extBufPos,len - bL,bL,x);

		Highlights.clearAllMarks();
	}

	@Override
	public void runSort(int[] array,int len,int bucketCount) {
		int bufferLen = 1;

		while(bufferLen * bufferLen < len) bufferLen *= 2;
		int numKeys = (len - 1) / bufferLen + 2;

		int[] extBuf = Writes.createExternalArray(bufferLen);
		int[] tags = Writes.createExternalArray(numKeys);

		this.sqrtCommonSort(array,0,len,extBuf,0,tags,false);

		Writes.deleteExternalArray(extBuf);
		Writes.deleteExternalArray(tags);
	}
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function Sort(){
	let array=[...arr];
	
	return[5,1]
}
function s(m=0,i=0){
	arr=create(count).sort((a,b)=>a-b);
	let stp=shuf.start(arr,i),tck=0;
	if(shufflesholder.style.height=="300px")shufflesholder.click();
	swaps=0;writes=0;canq2=0
	names.innerText="Shuffling...";
	let ostpl=stp.length;
	let shuffling=setInterval(()=>{
		tck++%5==0&&display(arr)
		tck%15==0&&(names.innerText=rotateText(names.innerText))
		if(stp.length){
			canskip=0
			inputdisplay.innerText=""
			for(let i=0;i<=ostpl*.002&&stp.length;i++){
				let c=stp.shift()
				switch(c[0]){
					case"swap":swap(arr,c[1],c[2],true);mark(c[1]);mark(c[2]);break;
					case"set":write(arr,c[1],c[2],true);mark(c[1]);break;
					case"custom":eval(atob(c[1]))(arr,...c.splice(2,1/0));break;
				}
			}
		}else{
			markarray.checked=0;
			clearInterval(shuffling);
			canskip=1;canq2=1;
			names.innerText="currently frozen/crashed";
			setTimeout(()=>{
				names.innerText=sn[m][0]+" ("+(m+1)+"/"+Object.keys(sn).length+")";
				inputdisplay.innerText=inputs[i]
				inputdisplay2.innerText=1+i+" / "+Object.keys(inputs).length
				rdisp([...sn[m][1](),function(){
					didskip=0
					display(arr)
					let stat=finalresult.innerText=="true";
					let z=-1,y=setInterval(()=>{
						if(z>=len){
							clearInterval(y);
							setTimeout(()=>{
								if(!loopsort.checked){
									let snl=Object.keys(sn).length
									if(++m==snl){
										if(queue==null)i++;
										i%=Object.keys(inputs).length
										m%=snl
									}
								}
								if(nextshuffle.checked){
									i++
									if((i%=Object.keys(inputs).length)==0){
										m++
										if(queue!=null){
											m=queue+1;
											queue=null;
											nextsort.innerText="Next: ...";
										}
									}
									if(queue2!=null){
										i=queue2
										queue2=null
									}
									s(--m,i)
									return;
								}
								if(queue2!=null){
									i=queue2
									queue2=null
								}
								if(queue==null){
									s(m,i)
								}else{
									s(queue,i)
									queue=null;
									nextsort.innerText="Next: ...";
								}
							},3e2)
						}
						for(let n=0;n<len*.04;n++){
							mark(++z+1,stat?"lime":"red")
							ctx.fillRect(z*bw,count-arr[z],bw,arr[z])
						}
					},1e3/45)
				}])
			},5);
			display(arr)
		}
	})
}
function set(v){sn.push(v)}
function get(n,cs=0){
	if(n.trim().length==0)return 0;
	if(!isNaN(n))return parseInt(n)-1;
	for(let i=0;i<sn.length;i++){
		let v=sn[i][0].toLowerCase();
		if(v==n.toLowerCase())return i
	}
	n=cs?n:n.toLowerCase();
	let offset=[];
	for(let i=0;i<sn.length;i++){
		let v=cs?sn[i][0]:sn[i][0].toLowerCase();
		offset[i]=[0,i];
		if(n.match(v))return i
		for(let j=0;j<n.length;j++)
			if(n[j]==v[j])
				offset[i][0]++
		offset[i][0]/=n.length
		offset[i][0]*=100;
	}
	return offset.sort((a,b)=>b[0]-a[0])[0][1]
}
set(["Iterative Bitonic Sort",iterativeBitonicSort])
set(["Batcher's Bitonic Sort",batcherBitonicSort])
set(["Iterative Bose-Nelson Sort",iterativeBoseNelsonSort])
set(["Recursive Bose-Nelson Sort",recursiveBoseNelsonSort])
set(["Crease Sort",creaseSort])
set(["Iterative Diamond Sort",iterativeDiamondSort])
set(["Recursive Diamond Sort",recursiveDiamondSort])
set(["Fold Sort",foldSort])
set(["Batcher's Merge-Exchange Sort",batcherMergeExchangeSort])
set(["Recursive Odd-Even Merge Sort",recursiveOddEvenMergeSort])
set(["Iterative Pairwise Merge Sort",iterativePairwiseMergeSort])
set(["Recursive Pairwise Merge Sort",recursivePairwiseMergeSort])
set(["Iterative Weave Sort",iterativeWeaveSort])
set(["Recursive Weave Sort",recursiveWeaveSort])
set(["LSD Radix Sort",LSDRadixSort])
set(["MSD Radix Sort",MSDRadixSort])
set(["In-Place LSD Radix Sort",inPlaceLSDRadixSort])
set(["In-Place MSD Radix Sort",inPlaceMSDRadixSort])
set(["L/MSD Radix Sort",LMSDRadixSort])
set(["Index Sort",indexSort])
set(["Bubble Sort",bubbleSort])
set(["Circloid Sort",circloidSort])
set(["Comb Sort",combSort])
set(["Complete Graph Sort",completeGraphSort])
set(["Cocktail Shaker Sort",cocktailShakerSort])
set(["Gnome Sort",gnomeSort])
set(["Left/Left Quick Sort",LLQuickSort])
set(["Left/Right Quick Sort",LRQuickSort])
set(["Odd-Even Sort",oddEvenSort])
set(["Stooge Sort",stoogeSort])
set(["Slope Sort",slopeSort])
set(["Shell Sort",shellSort])
set(["Recursive Shell Sort",recursiveShellSort])
set(["Andrey Astrelin's In-Place Merge Sort",andreySort])
set(["Block-Swap Merge Sort",blockSwapMergeSort])
set(["In-Place Merge Sort",inPlaceMergeSort])
set(["Rotate Merge Sort",rotateMergeSort])
set(["Strand Sort",strandSort])
set(["Weaved Merge Sort",weavedMergeSort])
set(["Weave Merge Sort",weaveMergeSort])
set(["Pancake Sort",pancakeSort])
set(["Max Heap Sort",maxHeapSort])
set(["Min Heap Sort",minHeapSort])
set(["Cycle Sort",cycleSort])
set(["Fun Sort",funSort])
set(["Asteraceae Sort",asteraceaeSort])
set(["Awkward Sort",awkwardSort])
set(["Chinotto Sort",chinottoSort])
set(["Circle Merge Sort",circleMergeSort])
set(["Clamber Sort",clamberSort])
set(["Cocktail Grate Sort",cocktailGrateSort])
set(["Cocktail Push Sort",cocktailPushSort])
set(["Dandelion Sort",dandelionSort])
set(["Float Sort",floatSort])
set(["Iterative Quick Sort",iterativeQuickSort])
set(["Index Quick Sort",indexQuickSort])
set(["Pseudo Heap Sort",pseudoHeapSort])
set(["Iterative Circle Sort",iterativeCircleSort])
set(["Recursive Circle Sort",recursiveCircleSort])
set(["Left/Left Quick Sort (Middle Pivot)",LLQuickSortMiddlePivotSort])
set(["Push Sort",pushSort])
set(["Reflection Sort",reflectionSort])
set(["Split Center Sort",splitCenterSort])
set(["Wiggle Sort",wiggleSort])
set(["Zipper Sort",zipperSort])
set(["Pairwise Circle Sort",pairwiseCircleSort])
set(["Iterative Sinking Merge Sort",iterativeSinkingMergeSort])
set(["Recursive Sinking Merge Sort",recursiveSinkingMergeSort])
set(["Cocktail Shell Sort",cocktailShellSort])
set(["Index Merge Sort",indexMergeSort])
set(["Mob Merge Sort",mobMergeSort])
set(["Modulo Merge Sort",moduloMergeSort])
set(["Split-16 Merge Sort",split16MergeSort])
set(["Cube Root Quick Sort",cbrtQuickSort])
set(["Apollyon Sort",apollyonSort])
set(["Optimized Pancake Sort",optimizedPancakeSort])
set(["Magnetica Quick Sort",magneticaQuickSort])
set(["Cocktail Peel Sort",cocktailPeelSort])
set(["Ecolo Sort",ecoloSort])
set(["Fall Sort",fallSort])
set(["Heavy Heap Sort",heavyHeapSort])
set(["Sandpaper Sort",sandPaperSort])
set(["Recursive Burning Sort",recursiveBurningSort])
set(["Corrupt Sort",corruptSort])
set(["Circle Halver Sort",circleHalverSort])
set(["Iterative Pairwise Sort",iterativePairwiseSort])
set(["Recursive Pairwise Sort",recursivePairwiseSort])
set(["Iterative [4,4] Van Voorhis Sort",iterativeVanVoorhisSort])
set(["Rotate LSD Radix Sort",rotateLSDRadixSort])
set(["Dig Sort",digSort])
set(["Cityscape Sort",cityscapeSort])
set(["Iterative Cleric Sort",iterativeClericSort])
set(["Recursive Cleric Sort",recursiveClericSort])
set(["Debris Sort",debrisSort])
set(["Evub Sort",evubSort])
set(["Iterative Firing Squad Sort",iterativeFiringSquadSort])
set(["Recursive Firing Squad Sort",recursiveFiringSquadSort])
set(["Ford Sort",fordSort])
set(["Future Sort",futureSort])
set(["Iterative Pop Sort",iterativePopSort])
set(["Jump Down Sort",jumpDownSort])
set(["Monolithic Clurge Sort",monolithicClurgeSort])
set(["Pairwise Comb Sort",pairwiseCombSort])
set(["Pancake Quick Sort",pancakeQuickSort])
set(["Pop Pop Sort",popPopSort])
set(["Swapless Push Sort",swaplessPushSort])
set(["Rebound Sort",reboundSort])
set(["Rubble Sort",rubbleSort])
set(["Search Sort",searchSort])
set(["Selection Sort",selectionSort])
set(["Iterative Shircle Sort",iterativeShircleSort])
set(["Recursive Shircle Sort",recursiveShircleSort])
set(["X Pattern Sort",XSort])
set(["Block Shell Sort",blockShellSort])
set(["Rotate MSD Radix Sort",rotateMSDRadixSort])
set(["Flash Sort",flashSort])
set(["American Flag Sort",americanFlagSort])
set(["Classic 3-Smooth Comb Sort",classic3SmoothCombSort])
set(["Iterative 3-Smooth Comb Sort",iterative3SmoothCombSort])
set(["Recursive 3-Smooth Comb Sort",recursive3SmoothCombSort])
set(["Binary Double Insertion Sort",binaryDoubleInsertionSort])
set(["Ecta Sort",ectaSort])
set(["Flan Sort",flanSort])
set(["Circular Grail Sort",circularGrailSort])
set(["Poplar Heap Sort",poplarHeapSort])
set(["Adaptive Grail Sort",adaptiveGrailSort])
set(["Intro Sort",introSort])
set(["Triangular Heap Sort",triangularHeapSort])
set(["Laziest Stable Sort",laziestStableSort])
set(["Lazierest Stable Sort",lazierestSort])
set(["Binary Quick Sort",binaryQuickSort])
set(["Static Sort",staticSort])
set(["Binary Gnome Sort",binaryGnomeSort])
set(["Dual-Pivot Quick Sort",dualPivotQuickSort])
set(["Shove Sort",shoveSort])
set(["Quad Stooge Sort",quadStoogeSort])
set(["Insertion Sort",insertionSort])
set(["Forced Stable Quick Sort",forcedStableQuickSort])
set(["Optimized Stooge Sort",optimizedStoogeSort])
set(["Swapless Bubble Sort",swaplessBubbleSort])
set(["Gravity Sort(Revised)",gravitySort])
set(["Table Sort",tableSort])
set(["Binary Merge Sort",binaryMergeSort])
set(["Buffer Partition Merge (BPM) Sort",bufferPartitionMergeSort])
set(["Binary Insertion Sort",binaryInsertionSort])
set(["Fifth Merge Sort",fifthMergeSort])
set(["Chalice Sort",chaliceSort])
set(["Block Selection Sort",blockSelectionSort])
set(["Iterative Intro Circle Sort",iterativeIntroCircleSort])
set(["Recursive Intro Circle Sort",recursiveIntroCircleSort])
set(["Median Merge Sort",medianMergeSort])
set(["Merge-Insertion Sort",mergeInsertionSort])
set(["Hyrbid Comb Sort",hyrbidCombSort])
set(["Flux Sort",fluxSort])
set(["Quad Sort",quadSort])
//set(["test Sort",testSort])
sn.sort((a,b)=>a[0].localeCompare(b[0]))
const inputs={
	0:"Random",1:"Reversed",2:"Slightly",3:"Sorted",4:"Naive Random",5:"Shuffled Tail",6:"Shuffled Head",7:"Shifted Element",8:"Noisy",9:"Shuffled Odds",10:"Final Merge Pass",11:"Shuffled Final Merge",12:"Shuffled Half",13:"Partitioned",14:"Sawtooth",15:"Pipe Organ",16:"Final Bitonic Pass",17:"Interlaced",18:"Double Layered",19:"Final Radix Pass",20:"Real Final Radix",21:"Recursive Final Radix",22:"Half Rotation",23:"Half Reversed",24:"Logarithmic Slopes",25:"Heapified",26:"Triangular Heapified",27:"Circle Pass",28:"Final Pairwise Pass",29:"Recursive Reversal",30:"Gray Code Fractal",31:"Sierpinski Triangle",32:"Triangular",33:"Quicksort Adversary",34:"Grailsort Adversary",35:"Modulo",36:"Quadratic",37:"Cubic",38:"Bit Reversal",39:"Random Block",40:"Block Reverse",41:"Sine Wave",42:"Partial Merge"
}
function hold(e){
	["touchstart","mousedown"].forEach(m=>e.addEventListener(m,v=>e.style.opacity=.5));
	["touchend","mouseup","mouseout"].forEach(m=>e.addEventListener(m,v=>e.style.opacity=1));
}
function appendTo(parent,text,func){
	let a=document.createElement("div");
	a.className="selectbtn";
	a.textContent=text;
	hold(a)
	if(typeof func=="function")a.onclick=func
	else{
		a.onclick=function(){
			queue=get(text)
			nextsort.innerText="Next: "+text;
			cancel=1;
			setTimeout(()=>cancel=0);
		}
	}
	parent.appendChild(a)
}
sn.forEach(e=>{
	let name=e[0].toLowerCase();
	appendTo(sortsholder,e[0]);
	if(name.match("merge"))appendTo(mergesortsholder,e[0]);
	if(name.match("quick"))appendTo(quicksortsholder,e[0]);
	if(name.match("recur"))appendTo(recursortsholder,e[0]);
	if(name.match("itera"))appendTo(itersortsholder,e[0]);
	if(name.match("cocktail"))appendTo(cocktailsortsholder,e[0]);
	if(name.match("binary"))appendTo(binarysortsholder,e[0]);
})
Object.values(inputs).forEach((e,i)=>{
	appendTo(shufflesholder,e,function(){
		inputdisplay2.innerText=(i+1)+" / "+Object.keys(inputs).length;
		queue2=i;
		cancel=1;
		setTimeout(()=>cancel=0);
	})
})
Array.from(document.querySelectorAll("div.topicname")).map((e,i)=>{
	let ch=document.querySelectorAll("div.btnholder")[i]
	e.onclick=function(){
		if(cancel)return;
		if(!canq2&&e.textContent.substr(0,8)=="Shuffles")return;
		let h=parseFloat(window.getComputedStyle(ch).getPropertyValue("opacity"))==1
		ch.style.height=(h?0:300)+"px";
		ch.style.opacity=h?0:1;
		ch.style.padding=(h?0:3)+"px 0px";
		document.querySelectorAll("div.space")[i].style.display=h?"none":"block";
	}
})
let req=get("Weave Merge Sort")
if(Object.values(sn).map(e=>e[0].toLowerCase()).indexOf("test sort")>=0)req=get("test")
s(req)
/*
to do: format flux sort
look for optimizations
to add: skip SOME hybrids if necessary
at 200 sorts do a cleaning
*/
		</script>
	</body>
</html>