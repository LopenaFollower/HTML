<!DOCTYPE html>
<html>
	<head>
		<title></title>
		<meta name="viewport"content="width=device-width,initial-scale=1">
		<style>
		</style>
	</head>
	<body>
		<input id=num></input><button onclick='display()'>Info</button>
		<table border=1 style="border-collapse:collapse"><tbody id=tb></tbody></table>
		<script>
const{ceil,sqrt,log2}=Math;
const{isInteger}=Number;
async function factors(n){
	if(n==1)return[1];
	let fs=[n];
	for(let i=ceil(n/2);i>0;i--){
		if(n%i<1)
			fs.unshift(i);
		await new Promise(r=>setTimeout(r));
	}
	return fs;
}
async function divisors(n){
	return await factors(n).length;
}
async function isAntiPrime(n){
	let f=await divisors(n);
	for(let i=0;i<n;i++)
		if(await divisors(i)>=f)
			return false;
	return true;
}
async function isPrime(n){
	if(n<2)return false;
	return await divisors(n)<3;
}
async function nextPrime(n){
	for(let i=n+1;;i++)
		if(await isPrime(i))
			return i;
}
async function primeFactors(n){
	let q=n;
	let p=2;
	let pfs=[];
	while(1){
		if(p>q)break;
		if(isInteger(q/p)){
			pfs.push(p);
			q=q/p;
		}else p=await nextPrime(p);
	}
	return pfs;
}
async function isSemiprime(n){
	return await primeFactors(n).length==2;
}
async function isMersennePrime(n){
	if(!await isPrime(n))return false;
	if(isInteger(log2(n+1)))return true;
}
async function isHappy(n){
	let seen=new Set();
	function squareSum(n){
		return(""+n).split("").map(e=>e*e).reduce((a,b)=>a+b);
	}
	let s=squareSum(n);
	while(1){
		if(s<2)return true;
		if(seen.has(s))return false;
		seen.add(s);
		s=squareSum(s);
		await new Promise(r=>setTimeout(r));
	}
}
async function isPerfect(n){
	return await factors(n).reduce((a,b)=>a+b)==2*n;
}
function isTetrahedral(n){
	for(let i=1;;i++){
		let a=(i*(i+1)*(i+2))/6;
		if(a==n)return true;
		if(a>n)return false;
	}
}
async function isPractical(n){
	let fs=await factors(n).reverse();
	let p=true;
	for(let i=1;i<n;i++){
		let s=0;
		for(let f=0;f<fs.length;f++)
			if(s+fs[f]<=i)
				s+=fs[f];
		if(s-i)p=false;
	}
	return p;
}
function isPerfectSquare(n){
	return isInteger(sqrt(n));
}
function digitalRoot(n){
	return(""+n).split("").map(e=>parseInt(e)).reduce((a,b)=>a+b);
}
async function isChenPrime(n){
	if(! await isPrime(n))return false;
	return await isPrime(n+2)||await isSemiprime(n+2);
}
async function isCircularPrime(n){
	return await isPrime(n)&&await isPrime(parseInt((n+"").split("").reverse().join("")));
}
async function isEisensteinPrime(n){
	if(!await isPrime(n))return false;
	for(let i=1;;i++){
		let a=3*i-1;
		if(a==n)return true;
		if(a>n)return false;
	}
}
async function isGaussianPrime(n){
	if(!await isPrime(n))return false;
	for(let i=0;;i++){
		let a=4*i+3;
		if(a==n)return true;
		if(a>n)return false;
	}
}
async function isPythagoreanPrime(n){
	if(!await isPrime(n))return false;
	for(let i=0;;i++){
		let a=4*i+1;
		if(a==n)return true;
		if(a>n)return false;
	}
}
async function isSophieGermainPrime(n){
	return await isPrime(n)&& await isPrime(2*n+1);
}
async function isIsolatedPrime(n){
	return await isPrime(n)&&!(await isPrime(n-2)||await isPrime(n+2));
}
async function isSafePrime(n){
	return await isPrime(n)&& await isPrime((n-1)/2);
}
async function isSphenic(n){
	let pfs=await primeFactors(n);
	return pfs.length==3&&new Set(pfs).size==3;
}
async function isAbundant(n){
	return await factors(n).reduce((a,b)=>a+b)-n>n;
}
function bool(b){
	return b?"Yes":"No";
}
async function display(){
	let val=parseInt(num.value.replaceAll(/[^\d.]/g,""));
	if(isNaN(val))return;
	let tr=[],i=0;
	let prime=isPrime(val);
	tr[i++]=["factors",await factors(val).join(", ")];
	tr[i++]=["#factors",divisors(val)];
	tr[i++]=["primeFactorization",primeFactors(val).join(" * ")];
	tr[i++]=["digitalRoot",digitalRoot(val)];
	tr[i++]=["isPerfect",bool(isPerfect(val))];
	tr[i++]=["isPractical",bool(isPractical(val))];
	tr[i++]=["isTetrahedral",bool(isTetrahedral(val))];
	tr[i++]=["isHappy",bool(await isHappy(val))];
	tr[i++]=["isPrime",bool(prime)];
	if(prime){
		tr[i++]=["isMersennePrime",bool(isMersennePrime(val))];
		tr[i++]=["isChenPrime",bool(isChenPrime(val))];
		tr[i++]=["isCircularPrime",bool(isCircularPrime(val))];
		tr[i++]=["isEisensteinPrime",bool(isEisensteinPrime(val))];
		tr[i++]=["isGaussianPrime",bool(isGaussianPrime(val))];
		tr[i++]=["isPythagoreanPrime",bool(isPythagoreanPrime(val))];
		tr[i++]=["isSophieGermainPrime",bool(isSophieGermainPrime(val))];
		tr[i++]=["isIsolatedPrime",bool(isIsolatedPrime(val))];
		tr[i++]=["isSafePrime",bool(isSafePrime(val))];
	}else{
		tr[i++]=["isSemiprime",bool(isSemiprime(val))];
		tr[i++]=["isAntiPrime",bool(isAntiPrime(val))];
		tr[i++]=["isPerfectSquare",bool(isPerfectSquare(val))];
		tr[i++]=["isSphenic",bool(isSphenic(val))];
		tr[i++]=["isAbundant",bool(isAbundant(val))];
	}
	tb.innerHTML="";
	tr.forEach(e=>{
		let t=document.createElement("tr");
		tb.appendChild(t);
		let a=document.createElement("td");
		a.innerText=e[0];
		t.appendChild(a);
		let b=document.createElement("td");
		b.innerText=e[1];
		t.appendChild(b);
	});
}
let ar=new Array(100).fill().map((e,i)=>++i).filter(isAbundant);
		</script>
	</body>
</html>